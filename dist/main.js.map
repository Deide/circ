{"version":3,"file":null,"sources":["../src/utils/html.js","../src/utils/utils.js","../src/irc/irc_util.js","../src/chat/user_command_list.js","../src/net/remote_device.js","../src/utils/rsa.js","../src/net/remote_connection.js","../src/utils/event_emitter.js","../node_modules/lazy.js/lazy.js","../src/utils/message_handler.js","../src/chat/notification.js","../src/chat/developer_commands.js","../src/chat/nick_mentioned_notification.js","../src/chat/message_formatter.js","../src/chat/context.js","../src/chat/chat_log.js","../src/chat/irc_message_handler.js","../src/utils/globals.js","../src/irc/ctcp_handler.js","../src/utils/event.js","../src/irc/server_response_handler_map.js","../src/irc/server_response_handler.js","../src/net/abstract_tcp_socket.js","../src/net/chrome_socket.js","../src/irc/irc.js","../src/chat/user_command.js","../src/chat/custom_command_parser.js","../src/script/script.js","../src/script/script_loader.js","../src/chat/user_command_handler.js","../src/chat/window_list.js","../src/chat/notice.js","../src/chat/html_list.js","../src/chat/channel_list.js","../src/chat/notification_group.js","../src/chat/help_message_renderer.js","../src/chat/window_message_renderer.js","../src/chat/scrollable.js","../src/chat/nick_list.js","../src/chat/window.js","../src/chat/walkthrough.js","../src/chat/storage.js","../src/input/keycodes.js","../src/input/keyboard_shortcut_map.js","../src/net/remote_socket.js","../src/net/ssl_socket.js","../src/utils/timer.js","../src/net/remote_connection_handler.js","../src/chat/chat.js","../src/input/input_stack.js","../src/input/completion_finder.js","../src/input/auto_complete.js","../src/input/user_input_handler.js","../src/script/script_handler.js","../src/main.js"],"sourcesContent":["\r\nexport function escape(html) {\r\n    var escaped = {\r\n        \"&\": \"&amp;\",\r\n        \"<\": \"&lt;\",\r\n        \">\": \"&gt;\",\r\n        \"\\\"\": \"&quot;\",\r\n        \"'\": \"&apos;\"\r\n    };\r\n    return String(html).replace(/[&<>\"\\']/g, function(character) {\r\n        var _ref;\r\n        return (_ref = escaped[character]) != null ? _ref : character;\r\n    });\r\n}\r\n\r\nexport function stripColorCodes(html) {\r\n    return html.replace(/\\u0003\\d{1,2}(,\\d{1,2})?/g, \"\").replace(/[\\x0F\\x02\\x1F\\x1D]/g, \"\");\r\n}\r\n\r\n/**\r\n * Somewhat naive implementation of parsing color codes that does not respect\r\n * proper order of HTML open and close tags. Chrome doesn't seem to mind, though.\r\n */\r\nexport function parseColorCodes(html) {\r\n    var colors = [\r\n        \"rgb(255, 255, 255)\",\r\n        \"rgb(0, 0, 0)\",\r\n        \"rgb(0, 0, 128)\",\r\n        \"rgb(0, 128, 0)\",\r\n        \"rgb(255, 0, 0)\",\r\n        \"rgb(128, 0, 64)\",\r\n        \"rgb(128, 0, 128)\",\r\n        \"rgb(255, 128, 64)\",\r\n        \"rgb(255, 255, 0)\",\r\n        \"rgb(128, 255, 0)\",\r\n        \"rgb(0, 128, 128)\",\r\n        \"rgb(0, 255, 255)\",\r\n        \"rgb(0, 0, 255)\",\r\n        \"rgb(255, 0, 255)\",\r\n        \"rgb(128, 128, 128)\",\r\n        \"rgb(192, 192, 192)\"\r\n    ];\r\n\r\n    var color = null,\r\n        background = null,\r\n        bold = false,\r\n        italics = false,\r\n        underline = false;\r\n\r\n    var res = html.replace(/(\\x0F|\\x02|\\x1F|\\x1D|\\u0003(\\d{0,2})(?:,(\\d{1,2}))?)([^\\x0F\\x02\\x1F\\x1D\\u0003]*)/g, function(match, gr1, gr2, gr3, gr4) {\r\n        if (gr1 == \"\\x0F\") {\r\n            color = null;\r\n            background = null;\r\n            bold = false;\r\n            italics = false;\r\n            underline = false;\r\n        } else if (gr1 == \"\\x02\") {\r\n            bold = !bold;\r\n        } else if (gr1 == \"\\x1F\") {\r\n            underline = !underline;\r\n        } else if (gr1 == \"\\x1D\") {\r\n            italics = !italics;\r\n        } else {\r\n            if (gr2)\r\n                color = colors[parseInt(gr2)];\r\n\r\n            if (gr3)\r\n                background = colors[parseInt(gr3)];\r\n        }\r\n\r\n        if (!gr4)\r\n            return \"\";\r\n\r\n        return \"<font style='\" +\r\n            (color ? \"color: \" + color + \";\" : \"\") +\r\n            (background ? \"background-color: \" + background + \";\" : \"\") +\r\n            (bold ? \"font-weight: bold;\" : \"\") +\r\n            (underline ? \"text-decoration: underline;\" : \"\") +\r\n            (italics ? \"font-style: italic;\" : \"\") +\r\n            \"'>\" +\r\n            gr4 +\r\n            \"</font>\";\r\n    });\r\n\r\n    return res;\r\n}\r\n\r\nexport function _display(text, allowHtml, regx) {\r\n    var canonicalise, innerEscape, res, textIndex;\r\n    var escapeHTML = escape;\r\n\r\n    canonicalise = url => {\r\n        url = stripColorCodes(url);\r\n        url = escapeHTML(url);\r\n        if (url.match(/^[a-z][\\w-]+:/i)) {\r\n            return url;\r\n        } else {\r\n            return `http://${url}`;\r\n        }\r\n    };\r\n\r\n    innerEscape = str => {\r\n        if (allowHtml) return str;\r\n        // long words need to be extracted before escaping so escape HTML characters\r\n        // don't scew the word length\r\n        var longWords = (str.match(/\\S{40,}/g) || []).map(word => escapeHTML(word));\r\n\r\n        str = escapeHTML(str);\r\n\r\n        return longWords.reduce((result, word) => {\r\n            let replacement, n;\r\n            replacement = `<span class=\"longword\">${word}</span>`;\r\n            str = str.replace(word, replacement);\r\n            n = str.indexOf(replacement) + replacement.length;\r\n            result += str.slice(0, +(n - 1) + 1 || 9e9);\r\n            str = str.slice(n);\r\n            return result;\r\n        }, \"\") + str;\r\n    };\r\n\r\n    res = \"\";\r\n    textIndex = 0;\r\n    for (let m = regx.exec(text); m; m = regx.exec(text)) {\r\n        res += innerEscape(text.substr(textIndex, m.index - textIndex));\r\n        res += `<a target=\"_blank\" href=\"${canonicalise(m[0])}\">${escape(m[0])}</a>`;\r\n        textIndex = m.index + m[0].length;\r\n    }\r\n    res += innerEscape(text.substr(textIndex));\r\n    res = parseColorCodes(res);\r\n\r\n    return res;\r\n}\r\n\r\nfunction makeDisplay(rurl) {\r\n    return (text, allowHtml) => _display(text, allowHtml, rurl);\r\n}\r\n\r\n/**\r\n * Escapes HTML and linkifies\r\n */\r\nexport const display = makeDisplay(/\\b(?:(?:https?|ftp|file):\\/\\/|www\\.|ftp\\.)(?:\\([-A-Z0-9+&@#\\/%=~_|$?!:,.]*\\)|[-A-Z0-9+&@#\\/%=~_|$?!:,.])*(?:\\([-A-Z0-9+&@#\\/%=~_|$?!:,.]*\\)|[A-Z0-9+&@#\\/%=~_|$])/gi);","/*eslint no-console: 0 */\r\nimport * as HTMLUtils from \"./html\";\r\nexport const html = HTMLUtils;\r\nvar loggingEnabled = false;\r\nvar storedLogs = [];\r\nconst MAX_NUM_STORED_LOGS = 400;\r\n\r\nfunction getLoggerForType(type) {\r\n    switch (type) {\r\n    case \"w\":  // warning\r\n        return (...args) => {\r\n            if (args.length < 1) return;\r\n            if (loggingEnabled) console.warn.apply(console, args);\r\n            else storeLog(\"warn\", args);\r\n        };\r\n    case \"e\":  // error\r\n        return (...args) => {\r\n            if (args.length < 1) return;\r\n            console.error(...args);\r\n        };\r\n    default:  // info\r\n        return function (...args) {\r\n            if (args.length < 1) return;\r\n            if (loggingEnabled) console.log(...args);\r\n            else storeLog(\"log\", args);\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * @param  {any} obj Object to traverse\r\n * @param  {Array} fieldPath Array of fields to traverse in order\r\n * @return {any or null} Returns the last field if it exists, or null if it doesn't\r\n */\r\nexport function getFieldOrNull(obj, fieldPath) {\r\n    return fieldPath.reduce((o, field) => {\r\n        if (o === undefined || o === null) return null;\r\n        return o[field];\r\n    }, obj);\r\n}\r\n\r\nexport function assert(cond) {\r\n    if (!cond) {\r\n        throw new Error(\"assertion failed\");\r\n    }\r\n}\r\n\r\nexport function getLogger(caller) {\r\n    return function (...args) {\r\n        var type,\r\n            opt_type = args[0],\r\n            msg = 2 <= args.length ? args.slice(1) : [];\r\n\r\n        if (opt_type === \"l\" || opt_type === \"w\" || opt_type === \"e\") {\r\n            type = opt_type;\r\n        } else {\r\n            msg = [opt_type].concat(msg);\r\n        }\r\n        return getLoggerForType(type).apply(null, [`${caller.constructor.name}:`, ...msg]);\r\n    };\r\n}\r\n\r\nexport function enableLogging() {\r\n    loggingEnabled = true;\r\n    // Display the last 300-400 logs.\r\n    storedLogs.forEach(log => console[log.type].apply(console, log.msg));\r\n    console.log(\"---------------------------------------------------\");\r\n    console.log(`DEBUG: printed the last ${storedLogs.length} logs.`);\r\n    console.log(\"---------------------------------------------------\");\r\n}\r\n/**\r\n * @param  {string} word\r\n * @param  {number} num\r\n */\r\nexport function pluralize(word, num) {\r\n    if (!word || num === 1) {\r\n        return word;\r\n    }\r\n    if (word[word.length - 1] === \"s\") {\r\n        return word + \"es\";\r\n    } else {\r\n        return word + \"s\";\r\n    }\r\n}\r\n\r\nexport function storeLog(type, msg) {\r\n    storedLogs.push({ type: type, msg: msg });\r\n    if (storedLogs.length > MAX_NUM_STORED_LOGS) {\r\n        storedLogs = storedLogs.slice(100);\r\n    }\r\n}\r\n\r\n/**\r\n * Download an asset at the given URL and a return a local url to it that can be\r\n *  embeded in CIRC. A remote asset can not be directly embeded because of\r\n *  packaged apps content security policy.\r\n * @param {string} url\r\n * @param {function(string)} onload The callback which is passed the new url\r\n */\r\nexport function getEmbedableUrl(url, onload) {\r\n    const xhr = new XMLHttpRequest();\r\n    xhr.open(\"GET\", url);\r\n    xhr.responseType = \"blob\";\r\n    xhr.onload = function onXHRLoad() {\r\n        return onload(window.URL.createObjectURL(this.response));\r\n    };\r\n    xhr.onerror = (...args) => {\r\n        return console.error(\"Failed to get embedable url for asset:\", url, ...args);\r\n    };\r\n    return xhr.send();\r\n}\r\n\r\n/**\r\n * Returns a human readable representation of a list.\r\n * For example, [1, 2, 3] becomes \"1, 2 and 3\".\r\n * @param {Array<Object>} array\r\n * @return {string} readable list\r\n */\r\nexport function getReadableList(array) {\r\n    if (array.size() === 1) {\r\n        return array.first().toString();\r\n    } else {\r\n        return `${array.initial().join(\", \")} and ${array.last()}`;\r\n    }\r\n}\r\n\r\nexport function getReadableTime(epochMilliseconds) {\r\n    var date = new Date();\r\n    //The time coming from the server here is actually epoc time, so we need to set it accordingly.\r\n    date.setTime(epochMilliseconds);\r\n    return date.toString();\r\n}\r\n\r\nexport function isOnline() {\r\n    return window.navigator.onLine;\r\n}\r\n\r\nexport function removeFromArray(array, toRemove) {\r\n    var i = array.indexOf(toRemove);\r\n    if (i < 0) {\r\n        return false;\r\n    }\r\n    return array.splice(i, 1);\r\n}\r\n\r\nexport function truncateIfTooLarge(text, maxSize, suffix) {\r\n    if (suffix == null) {\r\n        suffix = \"...\";\r\n    }\r\n    if (text.length > maxSize) {\r\n        return text.slice(0, +(maxSize - suffix.length - 1) + 1 || 9e9) + suffix;\r\n    } else {\r\n        return text;\r\n    }\r\n}\r\n\r\n/**\r\n * Capitalizes the given string.\r\n * @param {string} sentence\r\n * @return {string} upper case string\r\n */\r\nexport function capitalizeString(sentence) {\r\n    if (!sentence) return sentence;\r\n    return sentence[0].toUpperCase() + sentence.slice(1);\r\n}\r\n\r\n/**\r\n * Returns whether or not the given string has non-whitespace characters.\r\n * @param {string} phrase\r\n * @return {boolean} result\r\n */\r\nexport function stringHasContent(phrase) {\r\n    if (!phrase) return false;\r\n    return /\\S/.test(phrase);\r\n}\r\n\r\n/**\r\n * Opens a file browser and returns the contents of the selected file.\r\n * @param {function(string)} callback The function to call after the file content has be retrieved.\r\n */\r\nexport function loadFromFileSystem(callback) {\r\n    return chrome.fileSystem.chooseFile({\r\n        type: \"openFile\"\r\n    }, function (fileEntry) {\r\n        if (!fileEntry) {\r\n            return;\r\n        }\r\n        return fileEntry.file(function (file) {\r\n            var fileReader;\r\n            fileReader = new FileReader();\r\n            fileReader.onload = function (e) {\r\n                return callback(e.target.result);\r\n            };\r\n            fileReader.onerror = function (e) {\r\n                return console.error(\"Read failed:\", e);\r\n            };\r\n            return fileReader.readAsText(file);\r\n        });\r\n    });\r\n}\r\n\r\nexport function registerSocketConnection(socketId, remove) {\r\n    if (window.chrome && chrome.runtime) {\r\n        chrome.runtime.getBackgroundPage(function (page) {\r\n            if (!page || !page.registerSocketId || !page.unregisterSocketId)\r\n                return;\r\n            if (remove)\r\n                page.unregisterSocketId(socketId);\r\n            else\r\n                page.registerSocketId(socketId);\r\n        });\r\n    }\r\n}\r\n\r\nexport function registerTcpServer(socketId, remove) {\r\n    if (window.chrome && chrome.runtime) {\r\n        chrome.runtime.getBackgroundPage(function (page) {\r\n            if (!page || !page.registerTcpServer || !page.unregisterTcpServer)\r\n                return;\r\n            if (remove) page.unregisterTcpServer(socketId);\r\n            else page.registerTcpServer(socketId);\r\n        });\r\n    }\r\n}\r\n","\r\nexport var arrayBufferConversionCount = 0;\r\n\r\nfunction createBlob(src) {\r\n    var BB = window.BlobBuilder || window.WebKitBlobBuilder;\r\n    if (BB) {\r\n        var bb = new BB();\r\n        bb.append(src);\r\n        return bb.getBlob();\r\n    }\r\n    return new Blob([src]);\r\n}\r\n\r\nfunction concatArrayBuffers(a, b) {\r\n    var result = new ArrayBuffer(a.byteLength + b.byteLength),\r\n        resultView = new Uint8Array(result);\r\n\r\n    resultView.set(new Uint8Array(a));\r\n    resultView.set(new Uint8Array(b), a.byteLength);\r\n    return result;\r\n}\r\n\r\nfunction string2ArrayBuffer(string, callback) {\r\n    var blob = createBlob(string),\r\n        f = new FileReader();\r\n\r\n    arrayBufferConversionCount++;\r\n    f.onload = e => {\r\n        arrayBufferConversionCount--;\r\n        return callback(e.target.result);\r\n    };\r\n    return f.readAsArrayBuffer(blob);\r\n}\r\n\r\nfunction arrayBuffer2String(buf, callback) {\r\n    var blob = createBlob(buf),\r\n        f = new FileReader();\r\n\r\n    arrayBufferConversionCount++;\r\n    f.onload = e => {\r\n        arrayBufferConversionCount--;\r\n        return callback(e.target.result);\r\n    };\r\n    return f.readAsText(blob);\r\n}\r\n\r\nexport const parseCommand = (() => {\r\n    const partsRegx = /^(?::([^\\x20]+?)\\x20)?([^\\x20]+?)((?:\\x20[^\\x20:][^\\x20]*)+)?(?:\\x20:(.*))?$/;\r\n    return function _parseCommand(data) {\r\n        const str = $.trim(data.toString(\"utf8\"));\r\n        let parts = partsRegx.exec(str);\r\n        if (!parts) {\r\n            throw new Error(`invalid IRC message: ${data}`);\r\n        }\r\n        /*\r\n        * Could do more validation here...\r\n        * prefix = servername | nickname((!user)?@host)?\r\n        * command = letter+ | digit{3}\r\n        * params has weird stuff going on when there are 14 arguments\r\n        */\r\n        // trim whitespace\r\n        if (parts[3] != null)\r\n            parts[3] = parts[3].slice(1).split(/\\x20/);\r\n        else\r\n            parts[3] = [];\r\n\r\n        if (parts[4] != null)\r\n            parts[3].push(parts[4]);\r\n        return {\r\n            prefix: parts[1],\r\n            command: parts[2],\r\n            params: parts[3]\r\n        };\r\n    };\r\n})();\r\n\r\nexport function hashString(s) {\r\n    var ret = 0;\r\n    for (let i = 0, len = s.length; i < len; i++) {\r\n        ret = (31 * ret + s.charCodeAt(i)) << 0;\r\n    }\r\n    return Math.abs(ret);\r\n}\r\n\r\nexport function parsePrefix(prefix) {\r\n    var p = /^([^!]+?)(?:!(.+?)(?:@(.+?))?)?$/.exec(prefix);\r\n    return {\r\n        nick: p[1],\r\n        user: p[2],\r\n        host: p[3]\r\n    };\r\n}\r\n\r\nconst resolveParams = (() => {\r\n    const spacesColons = /^:|\\x20/,\r\n        errorString = \"some non-final arguments had spaces or initial colons in them\";\r\n\r\n    return (params) => {\r\n        let last = params.length - 1,\r\n            lastArgIsMsg = params.length > 1 ? params[last] : false;\r\n\r\n        if (lastArgIsMsg === true) {\r\n            params.pop();\r\n            last -= 1;\r\n        }\r\n\r\n        if (params && params.length > 0) {\r\n            if (params.slice(0, last).some(p => spacesColons.test(p))) {\r\n                throw new Error(`${errorString}\\n[PARAMS] ${JSON.stringify(params)}`);\r\n            }\r\n            if (spacesColons.test(params[last]) || lastArgIsMsg === true) {\r\n                params[last] = `:${params[last]}`;\r\n            }\r\n            return params.join(\" \");\r\n        } else {\r\n            return \"\";\r\n        }\r\n    };\r\n})();\r\n\r\nexport function makeCommand(cmd, ...params) {\r\n    return `${cmd} ${resolveParams(params)}\\x0d\\x0a`;\r\n}\r\n\r\nexport function randomName(length) {\r\n    var chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\r\n    if (length == null) length = 10;\r\n    return Array(length).fill().map(() => chars[Math.floor(Math.random() * chars.length)])\r\n        .join(\"\");\r\n}\r\n\r\nexport function normaliseNick(nick) {\r\n    return nick.toLowerCase().replace(/[\\[\\]\\\\]/g, x => ({\r\n        \"[\": \"{\",\r\n        \"]\": \"}\",\r\n        \"|\": \"\\\\\"\r\n    }[x]));\r\n}\r\n\r\nexport function nicksEqual(a, b) {\r\n    var _ref2;\r\n    if (!((typeof a === (_ref2 = typeof b) && _ref2 === \"string\"))) {\r\n        return false;\r\n    }\r\n    return (a != null) && (b != null) && normaliseNick(a) === normaliseNick(b);\r\n}\r\n\r\nexport function toSocketData(str, cb) {\r\n    return string2ArrayBuffer(str, ab => cb(ab));\r\n}\r\n\r\nexport function fromSocketData(ab, cb) {\r\n    return arrayBuffer2String(ab, cb);\r\n}\r\n\r\nexport function emptySocketData() {\r\n    return new ArrayBuffer(0);\r\n}\r\n\r\nexport function concatSocketData(a, b) {\r\n    return concatArrayBuffers(a, b);\r\n}\r\n\r\nexport function isConvertingArrayBuffers() {\r\n    return arrayBufferConversionCount > 0;\r\n}\r\n\r\n/**\r\n * Converts an array containing uint8 values to an ArrayBuffer.\r\n * @param {Array.<number>} array An array of values in the range [0, 255].\r\n * @return {ArrayBuffer} An array buffer containing the byte representation of\r\n *     the passed in array.\r\n */\r\nexport function arrayToArrayBuffer(array) {\r\n    var arrayBuffer = new ArrayBuffer(array.length);\r\n    var arrayView = new Uint8Array(arrayBuffer);\r\n    arrayView.set(array);\r\n    return arrayBuffer;\r\n}\r\n","/*eslint no-console: [\"error\", { allow: [\"info\", \"error\"] }] */\r\nimport customCommandParser from \"./custom_command_parser\";\r\nimport loader from \"../script/script_loader\";\r\nimport {\r\n    getFieldOrNull,\r\n    stringHasContent,\r\n    pluralize,\r\n    getReadableList,\r\n    loadFromFileSystem,\r\n    getEmbedableUrl,\r\n    enableLogging\r\n} from \"../utils/utils\";\r\nimport {ISSUES_URL} from \"../utils/globals\";\r\nimport {listenSupported} from \"../utils/api\";\r\nimport iter from \"lazy.js\";\r\n\r\nfunction errorHandler(e) {\r\n    console.error(\"[Error]\", e);\r\n}\r\n\r\nexport default {\r\n    \"nick\": {\r\n        description: \"sets your nick\",\r\n        category: \"common\",\r\n        params: [\"nick\"],\r\n        run() {\r\n            var _ref1;\r\n            return this.chat.setNick((_ref1 = this.conn) != null ? _ref1.name : void 0, this.nick);\r\n        }\r\n    },\r\n    \"server\": {\r\n        description: \"connects to the server, port 6667 is used by default, reconnects to the current server if no server is specified, use '+' to enable SSL (i.e. +6667)\",\r\n        category: \"common\",\r\n        params: [\"opt_server\", \"opt_port\", \"opt_password\"],\r\n        requires: [\"online\"],\r\n        validateArgs() {\r\n            if (!this.port) this.port = 6667;\r\n            if (this.server == null) {\r\n                this.server = getFieldOrNull(this.conn, [\"name\"]);\r\n            }\r\n            return this.server && !isNaN(this.port);\r\n        },\r\n        run() {\r\n            return this.chat.connect(this.server, this.port, this.password);\r\n        }\r\n    },\r\n    \"join\": {\r\n        description: \"joins the channel with the key if provided, reconnects to the current channel if no channel is specified\",\r\n        category: \"common\",\r\n        params: [\"opt_channel\", \"opt_key\"],\r\n        requires: [\"connection\"],\r\n        validateArgs() {\r\n            if (this.channel == null) {\r\n                this.channel = this.chan;\r\n            }\r\n            this.channel = this.channel.toLowerCase();\r\n            return true;\r\n        },\r\n        run() {\r\n            return this.chat.join(this.conn, this.channel, this.key);\r\n        }\r\n    },\r\n    \"part\": {\r\n        description: \"closes the current window and disconnects from the channel\",\r\n        category: \"common\",\r\n        params: [\"opt_reason...\"],\r\n        requires: [\"connection\", \"channel\"],\r\n        run() {\r\n            this.chat.disconnectAndRemoveRoom(this.conn.name, this.chan, this.reason);\r\n        }\r\n    },\r\n    \"leave\": {\r\n        \"extends\": \"part\"\r\n    },\r\n    \"close\": {\r\n        \"extends\": \"part\"\r\n    },\r\n    \"invite\": {\r\n        description: \"invites the specified nick to the current or specified channel\",\r\n        category: \"common\",\r\n        params: [\"nick...\", \"opt_channel\"],\r\n        requires: [\"connection\"],\r\n        usage: \"<nick> [channel]\",\r\n        run() {\r\n            if (!this.channel) {\r\n                if (this.chan) {\r\n                    this.channel = this.chan;\r\n                } else {\r\n                    return this.displayMessage(\"error\", \"you must be in a channel or specify one\");\r\n                }\r\n            }\r\n            if (!this.conn.irc.channels[this.channel]) {\r\n                /*\r\n                * According to spec you can invite users to a channel that you are\r\n                *  not a member of if it doesn\"t exist\r\n                */\r\n                return this.displayMessage(\"error\", `you must be in ${this.channel} to invite someone to it`);\r\n            }\r\n            this.displayMessage(\"notice\", `inviting ${this.nick} to join ${this.channel}`);\r\n            return this.conn.irc.doCommand(\"INVITE\", this.nick, this.channel);\r\n        }\r\n    },\r\n    \"win\": {\r\n        description: \"switches windows, only channel windows are selected this way\",\r\n        category: \"misc\",\r\n        params: [\"windowNum\"],\r\n        validateArgs() {\r\n            this.windowNum = parseInt(this.windowNum);\r\n            return !isNaN(this.windowNum);\r\n        },\r\n        run() {\r\n            return this.chat.switchToChannelByIndex(this.windowNum - 1);\r\n        }\r\n    },\r\n    \"debug\": {\r\n        description: \"prints the last 300-400 logs to the developer console and enables future logging of info and warning messages\",\r\n        category: \"misc\",\r\n        run() {\r\n            enableLogging();\r\n            this.displayMessage(\"notice\", \"logging enabled. See developer \"\r\n                + \"console for previous logs. Have a bug to report? File an \"\r\n                + \"issue at \" + ISSUES_URL);\r\n        }\r\n    },\r\n    \"say\": {\r\n        description: \"sends text to the current channel\",\r\n        category: \"uncommon\",\r\n        params: [\"text...\"],\r\n        requires: [\"connection\", \"channel\", \"connected\"],\r\n        run() {\r\n            this.conn.irc.doCommand(\"PRIVMSG\", this.chan, this.text);\r\n            return this.displayMessage(\"privmsg\", this.conn.irc.nick, this.text);\r\n        }\r\n    },\r\n    \"list\": {\r\n        description: \"lists all channels on the server.\",\r\n        category: \"uncommon\",\r\n        params: [\"opt_channels\"],\r\n        requires: [\"connection\"],\r\n        run() {\r\n            return this.conn.irc.doCommand(\"LIST\", this.channels);\r\n        }\r\n    },\r\n    \"me\": {\r\n        description: \"sends text to the current channel, spoken in the 3rd person\",\r\n        category: \"uncommon\",\r\n        \"extends\": \"say\",\r\n        validateArgs() {\r\n            return this.text = `\\u0001ACTION ${this.text}\\u0001`;\r\n        }\r\n    },\r\n    \"quit\": {\r\n        description: \"disconnects from the current server\",\r\n        category: \"common\",\r\n        params: [\"opt_reason...\"],\r\n        requires: [\"connection\"],\r\n        run() {\r\n            this.chat.disconnectAndRemoveRoom(this.conn.name, null /* channel */, this.reason);\r\n        }\r\n    },\r\n    \"names\": {\r\n        description: \"lists nicks in the current channel\",\r\n        category: \"uncommon\",\r\n        requires: [\"connection\", \"channel\", \"connected\"],\r\n        run() {\r\n            var msg, names;\r\n            if (this.win.isPrivate()) {\r\n                msg = `You're in a private conversation with ${this.chan}.`;\r\n            }\r\n            else {\r\n                names = iter(this.conn.irc.channels[this.chan].names).values().sort().toArray();\r\n                msg = `Users in ${this.chan}: ${JSON.stringify(names)}`;\r\n            }\r\n            return this.win.message(\"\", msg, \"notice names\");\r\n        }\r\n    },\r\n    \"clear\": {\r\n        description: \"clears messages in the current window or from all windows if all is passed\",\r\n        category: \"uncommon\",\r\n        params: [\"opt_all\"],\r\n        validateArgs() {\r\n            if (!this.all || this.all === \"all\") {\r\n                return true;\r\n            }\r\n        },\r\n        run() {\r\n            if (this.all === \"all\") {\r\n                let winList = this.chat.winList;\r\n                return winList.map((_, i) => winList.get(i).clear());\r\n            } else {\r\n                return this.win.clear();\r\n            }\r\n        }\r\n    },\r\n    \"help\": {\r\n        description: \"displays information about a command, lists all commands if no command is specified\",\r\n        category: \"misc\",\r\n        params: [\"opt_command\"],\r\n        run() {\r\n            var commands;\r\n            this.command = this.chat.userCommands.getCommand(this.command);\r\n            if (this.command) {\r\n                return this.command.displayHelp(this.win);\r\n            } else {\r\n                commands = this.chat.userCommands.getCommands();\r\n                return this.win.messageRenderer.displayHelp(commands);\r\n            }\r\n        }\r\n    },\r\n    \"hotkeys\": {\r\n        description: \"lists keyboard shortcuts\",\r\n        category: \"misc\",\r\n        run() {\r\n            return this.win.messageRenderer.displayHotkeys(this.chat.getKeyboardShortcuts().getMap());\r\n        }\r\n    },\r\n    \"raw\": {\r\n        description: \"sends a raw event to the IRC server, use the -c flag to make the command apply to the current channel\",\r\n        category: \"uncommon\",\r\n        params: [\"command\", \"opt_arguments...\"],\r\n        usage: \"<command> [-c] [arguments...]\",\r\n        requires: [\"connection\"],\r\n        validateArgs() {\r\n            return this[\"arguments\"] = this[\"arguments\"] ? this[\"arguments\"].split(\" \") : [];\r\n        },\r\n        run() {\r\n            var command = customCommandParser.parse(this.chan, this.command, ...this[\"arguments\"]);\r\n            return this.conn.irc.send(...command);\r\n        }\r\n    },\r\n    \"quote\": {\r\n        \"extends\": \"raw\"\r\n    },\r\n    \"install\": {\r\n        description: \"loads a script by opening a file browser dialog\",\r\n        category: \"scripts\",\r\n        run() {\r\n            return loader.createScriptFromFileSystem(script => this.chat.addScript(script));\r\n        }\r\n    },\r\n    \"uninstall\": {\r\n        description: \"uninstalls a script, currently installed scripts can be listed with /scripts\",\r\n        params: [\"scriptName\"],\r\n        usage: \"<script name>\",\r\n        category: \"scripts\",\r\n        run() {\r\n            var message, script;\r\n            script = this.chat.scriptHandler.getScriptByName(this.scriptName);\r\n            if (script) {\r\n                this.chat.storage.clearScriptStorage(this.scriptName);\r\n                this.chat.scriptHandler.removeScript(script);\r\n                this.chat.storage.scriptRemoved(script);\r\n                return this.displayMessage(\"notice\", `Script ${this.scriptName} was successfully uninstalled`);\r\n            } else {\r\n                message = `No script by the name '${this.scriptName}' was found. ${this.listInstalledScripts()}`;\r\n                return this.displayMessage(\"error\", message);\r\n            }\r\n        }\r\n    },\r\n    \"scripts\": {\r\n        description: \"displays a list of installed scripts\",\r\n        category: \"scripts\",\r\n        run() {\r\n            return this.displayMessage(\"notice\", this.listInstalledScripts());\r\n        }\r\n    },\r\n    \"topic\": {\r\n        description: \"sets the topic of the current channel, displays the current topic if no topic is specified\",\r\n        category: \"uncommon\",\r\n        params: [\"opt_topic...\"],\r\n        requires: [\"connection\", \"channel\"],\r\n        run() {\r\n            return this.conn.irc.doCommand(\"TOPIC\", this.chan, this.topic);\r\n        }\r\n    },\r\n    \"kick\": {\r\n        description: \"removes a user from the current channel\",\r\n        category: \"uncommon\",\r\n        params: [\"nick\", \"opt_reason...\"],\r\n        requires: [\"connection\", \"channel\"],\r\n        run() {\r\n            return this.conn.irc.doCommand(\"KICK\", this.chan, this.nick, this.reason);\r\n        }\r\n    },\r\n    \"mode\": {\r\n        /*\r\n        * TODO when used with no args, display current modes\r\n        */\r\n        description: \"sets or gets the modes of a channel or user(s), the current channel is used by default\",\r\n        category: \"uncommon\",\r\n        params: [\"opt_target\", \"opt_mode\", \"opt_nicks...\"],\r\n        usage: \"< [channel|nick] | [channel] <mode> [nick1] [nick2] ...>\",\r\n        requires: [\"connection\"],\r\n        validateArgs() {\r\n            var _ref1, _ref2;\r\n            if (this.args.length === 0) return true;\r\n            this.nicks = (_ref1 = (_ref2 = this.nicks) != null ? _ref2.split(\" \") : void 0) != null ? _ref1 : [];\r\n            if (this.args.length === 1 && !this.isValidMode(this.target)) {\r\n                return true;\r\n            }\r\n            if (this.isValidMode(this.target) && this.target !== this.chan) {\r\n                /*\r\n                * A target wasn't specified, shift variables over by one\r\n                */\r\n                this.nicks.push(this.mode);\r\n                this.mode = this.target;\r\n                this.target = this.chan;\r\n            }\r\n            return this.target && this.isValidMode(this.mode);\r\n        },\r\n        run() {\r\n            if (this.args.length === 0) {\r\n                if (this.chan) {\r\n                    this.conn.irc.doCommand(\"MODE\", this.chan);\r\n                }\r\n                return this.conn.irc.doCommand(\"MODE\", this.conn.irc.nick);\r\n            } else {\r\n                return this.conn.irc.doCommand(\"MODE\", this.target, this.mode, ...this.nicks);\r\n            }\r\n        }\r\n    },\r\n    \"op\": {\r\n        description: \"gives operator status\",\r\n        params: [\"nick\"],\r\n        \"extends\": \"mode\",\r\n        usage: \"<nick>\",\r\n        requires: [\"connection\", \"channel\"],\r\n        validateArgs() {\r\n            return this.setModeArgs(\"+o\");\r\n        }\r\n    },\r\n    \"deop\": {\r\n        description: \"removes operator status\",\r\n        params: [\"nick\"],\r\n        \"extends\": \"mode\",\r\n        usage: \"<nick>\",\r\n        requires: [\"connection\", \"channel\"],\r\n        validateArgs() {\r\n            return this.setModeArgs(\"-o\");\r\n        }\r\n    },\r\n    \"voice\": {\r\n        description: \"gives voice\",\r\n        params: [\"nick\"],\r\n        \"extends\": \"mode\",\r\n        usage: \"<nick>\",\r\n        requires: [\"connection\", \"channel\"],\r\n        validateArgs() {\r\n            return this.setModeArgs(\"+v\");\r\n        }\r\n    },\r\n    \"devoice\": {\r\n        description: \"removes voice\",\r\n        params: [\"nick\"],\r\n        \"extends\": \"mode\",\r\n        usage: \"<nick>\",\r\n        requires: [\"connection\", \"channel\"],\r\n        validateArgs() {\r\n            return this.setModeArgs(\"-v\");\r\n        }\r\n    },\r\n    \"away\": {\r\n        description: \"sets your status to away, a response is automatically sent when people /msg or WHOIS you\",\r\n        category: \"uncommon\",\r\n        params: [\"opt_response...\"],\r\n        requires: [\"connection\"],\r\n        validateArgs() {\r\n            if (!stringHasContent(this.response)) {\r\n                this.response = \"I'm currently away from my computer\";\r\n            }\r\n            return true;\r\n        },\r\n        run() {\r\n            return this.conn.irc.doCommand(\"AWAY\", this.response);\r\n        }\r\n    },\r\n    \"back\": {\r\n        description: \"sets your status to no longer being away\",\r\n        category: \"uncommon\",\r\n        requires: [\"connection\"],\r\n        run() {\r\n            return this.conn.irc.doCommand(\"AWAY\", this.response);\r\n        }\r\n    },\r\n    \"msg\": {\r\n        description: \"sends a private message\",\r\n        category: \"common\",\r\n        params: [\"nick\", \"message...\"],\r\n        requires: [\"connection\"],\r\n        run() {\r\n            this.conn.irc.doCommand(\"PRIVMSG\", this.nick, this.message);\r\n            return this.displayDirectMessage();\r\n        }\r\n    },\r\n    \"whois\": {\r\n        description: \"displays information about a nick\",\r\n        category: \"uncommon\",\r\n        params: [\"opt_nick\"],\r\n        requires: [\"connection\"],\r\n        run() {\r\n            return this.conn.irc.doCommand(\"WHOIS\", this.nick);\r\n        }\r\n    },\r\n    \"swhois\": {\r\n        description: \"displays detailed information about a nick (by querying user's connecting server)\",\r\n        category: \"uncommon\",\r\n        params: [\"opt_nick\"],\r\n        requires: [\"connection\"],\r\n        run() {\r\n            // Same as WHOIS, but send the nick twice.\r\n            return this.conn.irc.doCommand(\"WHOIS\", this.nick, this.nick);\r\n        }\r\n    },\r\n    \"whowas\": {\r\n        description: \"displays recent login information about a nick\",\r\n        category: \"uncommon\",\r\n        params: [\"opt_nick\"],\r\n        requires: [\"connection\"],\r\n        run() {\r\n            return this.conn.irc.doCommand(\"WHOWAS\", this.nick);\r\n        }\r\n    },\r\n    \"who\": {\r\n        description: \"displays detailed user list to server window; add 'o' as second option to restrict to IRCOps\",\r\n        category: \"uncommon\",\r\n        params: [\"channel_or_pattern\", \"opt_o\"],\r\n        requires: [\"connection\"],\r\n        run() {\r\n            return this.conn.irc.doCommand(\"WHO\", this.channel_or_pattern, this.o);\r\n        }\r\n    },\r\n    \"about\": {\r\n        description: \"displays information about this IRC client\",\r\n        category: \"misc\",\r\n        run() {\r\n            return this.win.messageRenderer.displayAbout();\r\n        }\r\n    },\r\n    \"join-server\": {\r\n        description: \"use the IRC connection of another device, allowing you to be logged in with the same nick on multiple devices. Connects to the device that called /make-server if no arguments are given\",\r\n        category: \"one_identity\",\r\n        requires: [\"online\"],\r\n        params: [\"opt_addr\", \"opt_port\"],\r\n        validateArgs() {\r\n            var connectInfo, parsedPort;\r\n            parsedPort = parseInt(this.port);\r\n            if ((this.port || this.addr) && !(parsedPort || this.addr)) {\r\n                return false;\r\n            }\r\n            connectInfo = this.chat.storage.serverDevice;\r\n            this.port = parsedPort || (connectInfo != null ? connectInfo.port : void 0);\r\n            if (this.addr == null) {\r\n                this.addr = connectInfo != null ? connectInfo.addr : void 0;\r\n            }\r\n            return true;\r\n        },\r\n        run() {\r\n            if (this.port && this.addr) {\r\n                if (this.addr === this.chat.remoteConnection.getConnectionInfo().addr) {\r\n                    return this.displayMessage(\"error\", \"this device is the server and cannot connect to itself. Call /join-server on other devices to have them connect to this device or call /make-server on another device to make it the server\");\r\n                } else {\r\n                    this.chat.remoteConnectionHandler.isManuallyConnecting();\r\n                    return this.chat.remoteConnection.connectToServer({\r\n                        port: this.port,\r\n                        addr: this.addr\r\n                    });\r\n                }\r\n            } else {\r\n                return this.displayMessage(\"error\", \"No server exists. Use /make-server on the device you wish to become the server.\");\r\n            }\r\n        }\r\n    },\r\n    \"make-server\": {\r\n        description: \"makes this device a server to which other devices can connect. Connected devices use the IRC connection of this device\",\r\n        category: \"one_identity\",\r\n        requires: [\"online\"],\r\n        run() {\r\n            var state = this.chat.remoteConnection.getState();\r\n            if (this.chat.remoteConnectionHandler.shouldBeServerDevice()) {\r\n                return this.displayMessage(\"error\", \"this device is already acting as a server\");\r\n            } else if (!listenSupported()) {\r\n                return this.displayMessage(\"error\", \"this command cannot be used with your current version of Chrome because it does not support chrome.sockets.tcpServer\");\r\n            } else if (state === \"no_addr\") {\r\n                return this.displayMessage(\"error\", \"this device can not be used as a server at this time because it cannot find its own IP address\");\r\n            } else if (state === \"no_port\") {\r\n                return this.displayMessage(\"error\", \"this device can not be used as a server at this time because no valid port was found\");\r\n            } else if (state === \"finding_port\") {\r\n                return this.chat.remoteConnection.waitForPort(() => this.run);\r\n            } else {\r\n                this.chat.storage.becomeServerDevice(this.chat.remoteConnection.getConnectionInfo());\r\n                return this.chat.remoteConnectionHandler.determineConnection();\r\n            }\r\n        }\r\n    },\r\n    \"network-info\": {\r\n        description: \"displays network information including port, ip address and remote connection status\",\r\n        category: \"one_identity\",\r\n        run() {\r\n            var connectionInfo;\r\n            this.displayMessage(\"breakgroup\");\r\n            if (this.chat.remoteConnection.isServer()) {\r\n                let numClients = this.chat.remoteConnection.devices.length;\r\n                if (numClients > 0) {\r\n                    this.displayMessage(\"notice\", `acting as a server for ${numClients} other ${pluralize(\"device\", numClients)}`);\r\n                } else {\r\n                    this.displayMessage(\"notice\", \"Acting as a server device. No clients have connected.\");\r\n                }\r\n            } else if (this.chat.remoteConnection.isClient()) {\r\n                let serverDevice = this.chat.remoteConnection.serverDevice;\r\n                this.displayMessage(\"notice\", `connected to server device ${serverDevice.addr} on port ${serverDevice.port}`);\r\n            } else {\r\n                this.displayMessage(\"notice\", \"not connected to any other devices\");\r\n            }\r\n            if (this.chat.remoteConnection.getConnectionInfo().getState() !== \"found_port\") return;\r\n            this.displayMessage(\"breakgroup\");\r\n            connectionInfo = this.chat.remoteConnection.getConnectionInfo();\r\n            this.displayMessageWithStyle(\"notice\", `Port: ${connectionInfo.port}`, \"no-pretty-format\");\r\n            this.displayMessage(\"breakgroup\");\r\n            this.displayMessage(\"notice\", \"IP addresses:\");\r\n\r\n            return connectionInfo.possibleAddrs\r\n                .map(addr => this.displayMessageWithStyle(\"notice\", `    ${addr}`, \"no-pretty-format\"));\r\n        }\r\n    },\r\n    \"stop-server\": {\r\n        description: \"stops connecting through another device's IRC connection and starts using a new IRC connection (see /join-server)\",\r\n        category: \"one_identity\",\r\n        requires: [\"online\"],\r\n        run() {\r\n            this.chat.remoteConnectionHandler.useOwnConnection();\r\n            this.displayMessage(\"notice\", \"this device is now using its own IRC connection\");\r\n        }\r\n    },\r\n    \"autostart\": {\r\n        description: \"sets whether the application will run on startup, toggles if no arguments are given\",\r\n        category: \"misc\",\r\n        usage: \"[ON|OFF]\",\r\n        params: [\"opt_state\"],\r\n        validateArgs() {\r\n            if (!this.state) {\r\n                this.enabled = void 0;\r\n                return true;\r\n            }\r\n            this.state = this.state.toLowerCase();\r\n            if (!(this.state === \"on\" || this.state === \"off\")) {\r\n                return false;\r\n            }\r\n            this.enabled = this.state === \"on\";\r\n            return true;\r\n        },\r\n        run() {\r\n            var willAutostart;\r\n            willAutostart = this.chat.storage.setAutostart(this.enabled);\r\n            if (willAutostart) {\r\n                return this.displayMessage(\"notice\", \"CIRC will now automatically run on startup\");\r\n            } else {\r\n                return this.displayMessage(\"notice\", \"CIRC will no longer automatically run on startup\");\r\n            }\r\n        }\r\n    },\r\n    \"query\": {\r\n        description: \"opens a new window for a private conversation with someone\",\r\n        category: \"uncommon\",\r\n        params: [\"nick\"],\r\n        requires: [\"connection\"],\r\n        run() {\r\n            var win = this.chat.createPrivateMessageWindow(this.conn, this.nick);\r\n            return this.chat.switchToWindow(win);\r\n        }\r\n    },\r\n    \"kill\": {\r\n        description: \"kicks a user from the server\",\r\n        category: \"uncommon\",\r\n        params: [\"nick\", \"opt_reason\"],\r\n        requires: [\"connection\"],\r\n        run() {\r\n            return this.conn.irc.doCommand(\"KILL\", this.nick, this.reason);\r\n        }\r\n    },\r\n    \"version\": {\r\n        description: \"get the user's IRC version\",\r\n        category: \"uncommon\",\r\n        params: [\"nick\"],\r\n        requires: [\"connection\"],\r\n        run() {\r\n            return this.handleCTCPRequest(this.nick, \"VERSION\");\r\n        }\r\n    },\r\n    \"ignore\": {\r\n        description: \"stop certain message(s) from being displayed in the current channel, for example '/ignore join part' stops join and part messages from being displayed, a list of ignored messages is displayed if no arguments are given\",\r\n        category: \"misc\",\r\n        params: [\"opt_types...\"],\r\n        requires: [\"connection\"],\r\n        usage: \"[<message type 1> <message type 2> ...]\",\r\n        run() {\r\n            var types;\r\n            const context = this.win.getContext();\r\n            if (this.types) {\r\n                types = iter(this.types.split(\" \"));\r\n                types.each(type => this.chat.messageHandler.ignoreMessageType(context, type));\r\n                return this.displayMessage(\"notice\", `Messages of type ${getReadableList(types)} will no longer be displayed in this room.`);\r\n            } else {\r\n                types = iter(this.chat.messageHandler.getIgnoredMessages()[context]).keys();\r\n                if (!types.isEmpty()) {\r\n                    return this.displayMessage(\"notice\", `Messages of type ${getReadableList(types)} are being ignored in this room.`);\r\n                }\r\n                else\r\n                    return this.displayMessage(\"notice\", \"There are no messages being ignored in this room.\");\r\n            }\r\n        }\r\n    },\r\n    \"unignore\": {\r\n        description: \"stop ignoring certain message(s)\",\r\n        extends: \"ignore\",\r\n        usage: \"<message type 1> <message type 2> ...\",\r\n        run() {\r\n            if (this.types) {\r\n                let types = iter(this.types.split(\" \"));\r\n                types.each(type => this.chat.messageHandler.stopIgnoringMessageType(this.win.getContext(), type));\r\n                return this.displayMessage(\"notice\", `Messages of type ${getReadableList(types)} are no longer being ignored.`);\r\n            }\r\n            else\r\n                return this.displayHelp();\r\n        }\r\n    },\r\n    \"theme\": {\r\n        description: \"upload and use a custom CSS file, opens a file browser\",\r\n        category: \"misc\",\r\n        run() {\r\n            return loadFromFileSystem(content => {\r\n                window.webkitStorageInfo.requestQuota(PERSISTENT, 50 * 1024, grantedBytes => {\r\n                    window.requestFileSystem(PERSISTENT, grantedBytes, () => { }, errorHandler);\r\n                }, errorHandler);\r\n                return window.webkitRequestFileSystem(PERSISTENT, 50 * 1024, fileSystem => {\r\n                    return fileSystem.root.getFile(\"custom_style.css\", {\r\n                        create: true\r\n                    }, function (fileEntry) {\r\n                        return fileEntry.createWriter(writer => {\r\n                            var blob = new Blob([content], {\r\n                                type: \"text/css\"\r\n                            });\r\n                            writer.onwriteend = () => {\r\n                                return $(\"#main-style\").attr(\"href\", fileEntry.toURL());\r\n                            };\r\n                            return writer.write(blob);\r\n                        });\r\n                    });\r\n                });\r\n            });\r\n        }\r\n    },\r\n    \"untheme\": {\r\n        description: \"Remove the custom CSS file\",\r\n        category: \"misc\",\r\n        run() {\r\n            return window.webkitRequestFileSystem(PERSISTENT, 50 * 1024, fileSystem => {\r\n                fileSystem.root.getFile(\"custom_style.css\", { create: false },\r\n                    function (fileEntry) {\r\n                        fileEntry.remove(() => {\r\n                            console.info(\"custom_style.css removed\");\r\n                            return $(\"#main-style\").attr(\"href\", \"style.css\");\r\n                        });\r\n                    });\r\n            });\r\n        }\r\n    },\r\n    /**\r\n     * Hidden commands.\r\n     * These commands don't display in /help or autocomplete. They're used for\r\n     *  scripts and keyboard shortcuts.\r\n     */\r\n\r\n    \"next-server\": {\r\n        description: \"switches to the next server window\",\r\n        category: \"hidden\",\r\n        run() {\r\n            var nextServer, server, serverIndex, winList, _ref1;\r\n            winList = this.chat.winList;\r\n            server = winList.getServerForWindow(this.win);\r\n            if (!server) return;\r\n            serverIndex = winList.serverIndexOf(server);\r\n            nextServer = (_ref1 = winList.getServerWindow(serverIndex + 1)) != null ? _ref1 : winList.getServerWindow(0);\r\n            return this.chat.switchToWindow(nextServer);\r\n        }\r\n    },\r\n    \"next-room\": {\r\n        description: \"switches to the next window\",\r\n        category: \"hidden\",\r\n        run() {\r\n            var index, nextWin, winList, _ref1;\r\n            winList = this.chat.winList;\r\n            index = winList.indexOf(this.win);\r\n            if (index < 0) {\r\n                return;\r\n            }\r\n            nextWin = (_ref1 = winList.get(index + 1)) != null ? _ref1 : winList.get(0);\r\n            return this.chat.switchToWindow(nextWin);\r\n        }\r\n    },\r\n    \"previous-room\": {\r\n        description: \"switches to the next window\",\r\n        category: \"hidden\",\r\n        run() {\r\n            var index, nextWin, winList, _ref1;\r\n            winList = this.chat.winList;\r\n            index = winList.indexOf(this.win);\r\n            if (index < 0) {\r\n                return;\r\n            }\r\n            nextWin = (_ref1 = winList.get(index - 1)) != null ? _ref1 : winList.get(winList.length - 1);\r\n            return this.chat.switchToWindow(nextWin);\r\n        }\r\n    },\r\n    \"reply\": {\r\n        description: \"begin replying to the user who last mentioned your nick\",\r\n        category: \"hidden\",\r\n        run() {\r\n            var user;\r\n            user = this.chat.getLastUserToMention(this.win.getContext());\r\n            if (!user) {\r\n                return;\r\n            }\r\n            return this.chat.emit(\"set_input_if_empty\", `${user}: `);\r\n        }\r\n    },\r\n    \"image\": {\r\n        description: \"embed an image in a message\",\r\n        category: \"hidden\",\r\n        params: [\"src\"],\r\n        run() {\r\n            const win = this.win;\r\n            return getEmbedableUrl(this.src, url => {\r\n                var img = $(\"<img>\");\r\n                img.on(\"load\", () => {\r\n                    img.css(\"max-width\", `${img[0].width}px`);\r\n                    img.css(\"width\", \"100%\");\r\n                    return win.rawMessage(\"\", img[0].outerHTML);\r\n                });\r\n                return img.attr(\"src\", url);\r\n            });\r\n        }\r\n    },\r\n    \"suspend-notifications\": {\r\n        description: \"suspends notifications temporarily\",\r\n        category: \"hidden\",\r\n        params: [\"suspend\"],\r\n        run() {\r\n            this.chat.messageHandler.setSuspendNotifications(this.suspend.toLowerCase() == \"on\");\r\n        }\r\n    }\r\n};","import EventEmitter from \"../utils/event_emitter\";\r\nimport {listenSupported, getNetworkInterfacesSupported} from \"../utils/api\";\r\nimport {registerTcpServer, registerSocketConnection} from \"../utils/utils\";\r\nimport {toSocketData, fromSocketData} from \"../irc/irc_util\";\r\n\r\nfunction isDigit(c) {\r\n    return c >= \"0\" && c <= \"9\";\r\n}\r\n\r\n/**\r\n * Represents a device running CIRC and handles communication to/from that\r\n *  device.\r\n */\r\nexport default class RemoteDevice extends EventEmitter {\r\n    constructor(addr, port) {\r\n        super();\r\n        this._listenOnValidPort = this._listenOnValidPort.bind(this);\r\n        this._onReceive = this._onReceive.bind(this);\r\n        this._onReceiveError = this._onReceiveError.bind(this);\r\n\r\n        this._receivedMessages = \"\";\r\n        this.id = addr;\r\n        this._isClient = false;\r\n        if (typeof addr === \"string\") {\r\n            this._initFromAddress(addr, port);\r\n        } else if (addr) {\r\n            this._initFromSocketId(addr);\r\n        } else {\r\n            this.port = RemoteDevice.FINDING_PORT;\r\n        }\r\n    }\r\n\r\n    equals(otherDevice) {\r\n        return this.id === (otherDevice != null ? otherDevice.id : void 0);\r\n    }\r\n\r\n    usesConnection(connectionInfo) {\r\n        return connectionInfo.addr === this.addr && connectionInfo.port === this.port;\r\n    }\r\n\r\n    getState() {\r\n        if (!this.addr) {\r\n            return \"no_addr\";\r\n        }\r\n        switch (this.port) {\r\n        case RemoteDevice.FINDING_PORT:\r\n            return \"finding_port\";\r\n        case RemoteDevice.NO_PORT:\r\n            return \"no_port\";\r\n        default:\r\n            return \"found_port\";\r\n        }\r\n    }\r\n\r\n    _initFromAddress(addr, port) {\r\n        this.addr = addr;\r\n        this.port = port;\r\n    }\r\n\r\n    _initFromSocketId(_socketId) {\r\n        this._socketId = _socketId;\r\n        this._isClient = true;\r\n        return this._listenForData();\r\n    }\r\n\r\n    findPossibleAddrs(callback) {\r\n        return chrome.system.network.getNetworkInterfaces(networkInfoList => {\r\n            this.possibleAddrs = networkInfoList.map(networkInfo => networkInfo.address);\r\n            this.addr = this._getValidAddr(this.possibleAddrs);\r\n            return callback();\r\n        });\r\n    }\r\n\r\n    _getValidAddr(addrs) {\r\n        if (!addrs || addrs.length === 0) {\r\n            return void 0;\r\n        }\r\n        /**\r\n         * TODO: currently we return the first IPv4 address. Will this always work?\r\n         */\r\n        return addrs.reduce((shortest, addr) => addr.length < shortest.length ? addr: shortest);\r\n    }\r\n\r\n    hasGetNetworkInterfacesSupport() {\r\n        if (getNetworkInterfacesSupported()) return true;\r\n        this._log(\"w\", \"chrome.system.network.getNetworkInterfaces is not supported!\");\r\n        this.possibleAddrs = [];\r\n        this.port = RemoteDevice.NO_PORT;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Call chrome.system.network.getNetworkInterfaces in an attempt to find a valid address.\r\n     */\r\n    searchForAddress(callback, timeout) {\r\n        if (timeout == null) timeout = 500;\r\n        if (!this.hasGetNetworkInterfacesSupport()) return;\r\n        if (timeout > 60000) timeout = 60000;\r\n        return setTimeout(() => this.findPossibleAddrs(() => {\r\n            return this.addr ? callback() : this.searchForAddress(callback, timeout *= 1.2);\r\n        }), timeout);\r\n    }\r\n\r\n    /**\r\n     * Called when the device is your own device. Listens for connecting client\r\n     *  devices.\r\n     */\r\n    listenForNewDevices(callback) {\r\n        var _ref;\r\n        return (_ref = chrome.sockets.tcpServer) != null ? _ref.create({}, socketInfo => {\r\n            this._socketId = socketInfo.socketId;\r\n            registerTcpServer(socketInfo.socketId);\r\n            if (listenSupported()) {\r\n                return this._listenOnValidPort(callback);\r\n            }\r\n        }) : void 0;\r\n    }\r\n\r\n    /**\r\n     * Attempt to listen on the default port, then increment the port by a random\r\n     *  amount if the attempt fails and try again.\r\n     */\r\n    _listenOnValidPort(callback, port) {\r\n        if (!(port >= 0)) {\r\n            port = RemoteDevice.BASE_PORT;\r\n        }\r\n        return chrome.sockets.tcpServer.listen(this._socketId, \"0.0.0.0\", port, result => {\r\n            return this._onListen(callback, port, result);\r\n        });\r\n    }\r\n\r\n    _onListen(callback, port, result) {\r\n        if (result < 0) {\r\n            return this._onFailedToListen(callback, port, result);\r\n        } else {\r\n            this.port = port;\r\n            this.emit(\"found_port\", this);\r\n            this._acceptNewConnection(callback);\r\n        }\r\n    }\r\n\r\n    _onFailedToListen(callback, port, result) {\r\n        if (port - RemoteDevice.BASE_PORT > RemoteDevice.MAX_CONNECTION_ATTEMPTS) {\r\n            this._log(\"w\", \"Couldn't listen to 0.0.0.0 on any attempted ports\",\r\n                `${chrome.runtime.lastError.message} (error ${-result})`);\r\n            this.port = RemoteDevice.NO_PORT;\r\n            return this.emit(\"no_port\");\r\n        } else {\r\n            return this._listenOnValidPort(callback, port + Math.floor(Math.random() * 100));\r\n        }\r\n    }\r\n\r\n    _acceptNewConnection(callback) {\r\n        this._log(\"listening for new connections on port\", this.port);\r\n        // TODO(rpaquay): When do we remove the listener?\r\n        chrome.sockets.tcpServer.onAccept.addListener(acceptInfo => {\r\n            if (this._socketId != acceptInfo.socketId) return;\r\n            this._onAccept(acceptInfo, callback);\r\n        });\r\n    }\r\n\r\n    _onAccept(acceptInfo, callback) {\r\n        this._log(\"Connected to a client device\", this._socketId);\r\n        registerSocketConnection(acceptInfo.clientSocketId);\r\n        var device = new RemoteDevice(acceptInfo.clientSocketId);\r\n        device.getAddr(function() {\r\n            return callback(device);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Called when acting as a server. Finds the client ip address.\r\n     */\r\n    getAddr(callback) {\r\n        var _ref;\r\n        return (_ref = chrome.sockets.tcp) != null ? _ref.getInfo(this._socketId, socketInfo => {\r\n            this.addr = socketInfo.peerAddress;\r\n            return callback();\r\n        }) : void 0;\r\n    }\r\n\r\n    send(type, args) {\r\n        if (args) {\r\n            // Convert Uint8Arrays to regular JS arrays for stringify.\r\n            // TODO(flackr): Preferably this would be done earlier so that send\r\n            // doesn't need to know what's being sent.\r\n            args = args.map(arg => arg instanceof Uint8Array ? Array.from(arg) : arg);\r\n        }\r\n        var msg = JSON.stringify({type, args});\r\n        msg = `${msg.length}$${msg}`;\r\n        return toSocketData(msg, data => {\r\n            var _ref;\r\n            return (_ref = chrome.sockets.tcp) != null ? _ref.send(this._socketId, data, sendInfo => {\r\n                if (sendInfo.resultCode < 0 || sendInfo.bytesSent !== data.byteLength) {\r\n                    this._log(\"w\", \"closing b/c failed to send:\", type, args,\r\n                        `${chrome.runtime.lastError.message} (error ${-sendInfo.resultCode})`);\r\n                    return this.close();\r\n                } else {\r\n                    return this._log(\"sent\", type, args);\r\n                }\r\n            }) : void 0;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Called when the device represents a remote server. Creates a connection\r\n     *  to that remote server.\r\n     */\r\n    connect(callback) {\r\n        var tcp = chrome.sockets.tcp;\r\n        this.close();\r\n        return tcp != null ? tcp.create(socketInfo => {\r\n            this._socketId = socketInfo.socketId;\r\n            this._isClient = true;\r\n            if (!this._socketId) callback(false);\r\n            tcp.setPaused(this._socketId, true, () => {\r\n                return tcp != null ? tcp.connect(this._socketId, this.addr, this.port, result => {\r\n                    return this._onConnect(result, callback);\r\n                }) : void 0;\r\n            });\r\n        }) : void 0;\r\n    }\r\n\r\n    _onConnect(result, callback) {\r\n        if (result < 0) {\r\n            this._log(\"w\", \"Couldn't connect to server\", this.addr, \"on port\", this.port, \"-\",\r\n                `${chrome.runtime.lastError} (error ${-result})`);\r\n            return callback(false);\r\n        } else {\r\n            this._listenForData();\r\n            return callback(true);\r\n        }\r\n    }\r\n\r\n    close() {\r\n        if (this._socketId) {\r\n            if (this._isClient) {\r\n                chrome.sockets.tcp.onReceive.removeListener(this._onReceive);\r\n                chrome.sockets.tcp.onReceiveError.removeListener(this._onReceiveError);\r\n                registerSocketConnection(this._socketId, true);\r\n                chrome.sockets.tcp.disconnect(this._socketId);\r\n                chrome.sockets.tcp.close(this._socketId);\r\n            } else {\r\n                //chrome.sockets.tcp.onAccept.removeListener(this._onAccept);\r\n                registerTcpServer(this._socketId, true);\r\n                chrome.sockets.tcp.disconnect(this._socketId);\r\n                chrome.sockets.tcp.close(this._socketId);\r\n            }\r\n            this._socketId = undefined;\r\n            return this.emit(\"closed\", this);\r\n        }\r\n    }\r\n\r\n    _onReceive(receiveInfo) {\r\n        if (receiveInfo.socketId != this._socketId) return;\r\n\r\n        fromSocketData(receiveInfo.data, partialMessage => {\r\n            var completeMessages;\r\n            this._receivedMessages += partialMessage;\r\n            completeMessages = this._parseReceivedMessages();\r\n\r\n            return completeMessages.map(data => {\r\n                this._log.apply(this, [\"received\", data.type, ...data.args]);\r\n                return this.emit.apply(this, [data.type, this, ...data.args]);\r\n            });\r\n        });\r\n    }\r\n\r\n    _onReceiveError(receiveInfo) {\r\n        if (receiveInfo.socketId != this._socketId)\r\n            return;\r\n\r\n        this._log(\"w\", \"bad read - closing socket: \", `(error ${-receiveInfo.resultCode})`);\r\n        this.emit(\"closed\", this);\r\n        this.close();\r\n    }\r\n\r\n    _listenForData() {\r\n        chrome.sockets.tcp.onReceive.addListener(this._onReceive);\r\n        chrome.sockets.tcp.onReceiveError.addListener(this._onReceiveError);\r\n        chrome.sockets.tcp.setPaused(this._socketId, false, function() { });\r\n    }\r\n\r\n    _parseReceivedMessages(result) {\r\n        var length, message, prefixEnd;\r\n        result = result || [];\r\n        if (!this._receivedMessages) return result;\r\n        if (this._receivedMessages.length && !isDigit(this._receivedMessages[0])) {\r\n            this._log.apply(this, [\"received message doesn't begin with digit: \", this._receivedMessages]);\r\n        }\r\n        prefixEnd = this._receivedMessages.indexOf(\"$\");\r\n        if (!(prefixEnd >= 0)) return result;\r\n        length = parseInt(this._receivedMessages.slice(0, +(prefixEnd - 1) + 1 || 9e9));\r\n        if (!(this._receivedMessages.length > prefixEnd + length)) return result;\r\n        message = this._receivedMessages.slice(prefixEnd + 1, +(prefixEnd + length) + 1 || 9e9);\r\n        try {\r\n            let json = JSON.parse(message);\r\n            result.push(json);\r\n            if (JSON.stringify(json).length != length) {\r\n                this._log(\"e\", \"json length mismatch\");\r\n            }\r\n        } catch (e) {\r\n            this._log(\"e\", `failed to parse json: ${message}`);\r\n        }\r\n        if (this._receivedMessages.length > prefixEnd + length + 1 &&\r\n                !isDigit(this._receivedMessages[prefixEnd + length + 1])) {\r\n            this._log(\"e\", `message after split doesn't begin with digit: ${this._receivedMessages}`);\r\n        }\r\n        this._receivedMessages = this._receivedMessages.slice(prefixEnd + length + 1);\r\n        return this._parseReceivedMessages(result);\r\n    }\r\n\r\n    toString() {\r\n        if (this.addr) {\r\n            return `${this.addr} on port ${this.port}`;\r\n        } else {\r\n            return `${this.socketId}`;\r\n        }\r\n    }\r\n}\r\n\r\nRemoteDevice.getOwnDevice = function (callback) {\r\n    var device = new RemoteDevice;\r\n    if (!device.hasGetNetworkInterfacesSupport()) {\r\n        callback(device);\r\n        return;\r\n    }\r\n    if (!listenSupported()) {\r\n        device.port = RemoteDevice.NO_PORT;\r\n    }\r\n    return device.findPossibleAddrs(() => callback(device));\r\n};\r\n\r\n/**\r\n * Begin at this port and increment by one until an open port is found.\r\n */\r\nRemoteDevice.BASE_PORT = 1329;\r\n\r\nRemoteDevice.MAX_CONNECTION_ATTEMPTS = 30;\r\n\r\nRemoteDevice.FINDING_PORT = -1;\r\n\r\nRemoteDevice.NO_PORT = -2;\r\n","/*\r\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\r\n * Digest Algorithm, as defined in RFC 1321.\r\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\r\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\r\n * Distributed under the BSD License\r\n * See http://pajhome.org.uk/crypt/md5 for more info.\r\n */\r\n\r\n/*\r\n * Configurable variables. You may need to tweak these to be compatible with\r\n * the server-side, but the defaults work in most cases.\r\n */\r\nvar hexcase = 0;   /* hex output format. 0 - lowercase; 1 - uppercase        */\r\nvar b64pad = \"\";  /* base-64 pad character. \"=\" for strict RFC compliance   */\r\n\r\n/*\r\n * These are the functions you'll usually want to call\r\n * They take string arguments and return either hex or base-64 encoded strings\r\n */\r\nexport function hex_md5(s) { return rstr2hex(rstr_md5(str2rstr_utf8(s))); }\r\nexport function b64_md5(s) { return rstr2b64(rstr_md5(str2rstr_utf8(s))); }\r\nexport function any_md5(s, e) { return rstr2any(rstr_md5(str2rstr_utf8(s)), e); }\r\nexport function hex_hmac_md5(k, d) {\r\n    return rstr2hex(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)));\r\n}\r\nexport function b64_hmac_md5(k, d) {\r\n    return rstr2b64(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)));\r\n}\r\nexport function any_hmac_md5(k, d, e) {\r\n    return rstr2any(rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d)), e);\r\n}\r\n\r\n/*\r\n * Perform a simple self-test to see if the VM is working\r\n */\r\nexport function md5_vm_test() {\r\n    return hex_md5(\"abc\").toLowerCase() == \"900150983cd24fb0d6963f7d28e17f72\";\r\n}\r\n\r\n/*\r\n * Calculate the MD5 of a raw string\r\n */\r\nfunction rstr_md5(s) {\r\n    return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));\r\n}\r\n\r\n/*\r\n * Calculate the HMAC-MD5, of a key and some data (raw strings)\r\n */\r\nfunction rstr_hmac_md5(key, data) {\r\n    var bkey = rstr2binl(key);\r\n    if (bkey.length > 16) bkey = binl_md5(bkey, key.length * 8);\r\n\r\n    var ipad = Array(16), opad = Array(16);\r\n    for (var i = 0; i < 16; i++) {\r\n        ipad[i] = bkey[i] ^ 0x36363636;\r\n        opad[i] = bkey[i] ^ 0x5C5C5C5C;\r\n    }\r\n\r\n    var hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);\r\n    return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));\r\n}\r\n\r\n/*\r\n * Convert a raw string to a hex string\r\n */\r\nfunction rstr2hex(input) {\r\n    try { hexcase; } catch (e) { hexcase = 0; }\r\n    var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\";\r\n    var output = \"\";\r\n    var x;\r\n    for (var i = 0; i < input.length; i++) {\r\n        x = input.charCodeAt(i);\r\n        output += hex_tab.charAt((x >>> 4) & 0x0F)\r\n            + hex_tab.charAt(x & 0x0F);\r\n    }\r\n    return output;\r\n}\r\n\r\n/*\r\n * Convert a raw string to a base-64 string\r\n */\r\nfunction rstr2b64(input) {\r\n    try { b64pad; } catch (e) { b64pad = \"\"; }\r\n    var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n    var output = \"\";\r\n    var len = input.length;\r\n    for (var i = 0; i < len; i += 3) {\r\n        var triplet = (input.charCodeAt(i) << 16)\r\n            | (i + 1 < len ? input.charCodeAt(i + 1) << 8 : 0)\r\n            | (i + 2 < len ? input.charCodeAt(i + 2) : 0);\r\n        for (var j = 0; j < 4; j++) {\r\n            if (i * 8 + j * 6 > input.length * 8) output += b64pad;\r\n            else output += tab.charAt((triplet >>> 6 * (3 - j)) & 0x3F);\r\n        }\r\n    }\r\n    return output;\r\n}\r\n\r\n/*\r\n * Convert a raw string to an arbitrary string encoding\r\n */\r\nfunction rstr2any(input, encoding) {\r\n    var divisor = encoding.length;\r\n    var i, j, q, x, quotient;\r\n\r\n    /* Convert to an array of 16-bit big-endian values, forming the dividend */\r\n    var dividend = Array(Math.ceil(input.length / 2));\r\n    for (i = 0; i < dividend.length; i++) {\r\n        dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);\r\n    }\r\n\r\n    /*\r\n     * Repeatedly perform a long division. The binary array forms the dividend,\r\n     * the length of the encoding is the divisor. Once computed, the quotient\r\n     * forms the dividend for the next step. All remainders are stored for later\r\n     * use.\r\n     */\r\n    var full_length = Math.ceil(input.length * 8 /\r\n        (Math.log(encoding.length) / Math.log(2)));\r\n    var remainders = Array(full_length);\r\n    for (j = 0; j < full_length; j++) {\r\n        quotient = Array();\r\n        x = 0;\r\n        for (i = 0; i < dividend.length; i++) {\r\n            x = (x << 16) + dividend[i];\r\n            q = Math.floor(x / divisor);\r\n            x -= q * divisor;\r\n            if (quotient.length > 0 || q > 0)\r\n                quotient[quotient.length] = q;\r\n        }\r\n        remainders[j] = x;\r\n        dividend = quotient;\r\n    }\r\n\r\n    /* Convert the remainders to the output string */\r\n    var output = \"\";\r\n    for (i = remainders.length - 1; i >= 0; i--)\r\n        output += encoding.charAt(remainders[i]);\r\n\r\n    return output;\r\n}\r\n\r\n/*\r\n * Encode a string as utf-8.\r\n * For efficiency, this assumes the input is valid utf-16.\r\n */\r\nfunction str2rstr_utf8(input) {\r\n    var output = \"\";\r\n    var i = -1;\r\n    var x, y;\r\n\r\n    while (++i < input.length) {\r\n        /* Decode utf-16 surrogate pairs */\r\n        x = input.charCodeAt(i);\r\n        y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;\r\n        if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF) {\r\n            x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);\r\n            i++;\r\n        }\r\n\r\n        /* Encode output as utf-8 */\r\n        if (x <= 0x7F)\r\n            output += String.fromCharCode(x);\r\n        else if (x <= 0x7FF)\r\n            output += String.fromCharCode(0xC0 | ((x >>> 6) & 0x1F),\r\n                0x80 | (x & 0x3F));\r\n        else if (x <= 0xFFFF)\r\n            output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),\r\n                0x80 | ((x >>> 6) & 0x3F),\r\n                0x80 | (x & 0x3F));\r\n        else if (x <= 0x1FFFFF)\r\n            output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),\r\n                0x80 | ((x >>> 12) & 0x3F),\r\n                0x80 | ((x >>> 6) & 0x3F),\r\n                0x80 | (x & 0x3F));\r\n    }\r\n    return output;\r\n}\r\n\r\n/*\r\n * Encode a string as utf-16\r\n */\r\nexport function str2rstr_utf16le(input) {\r\n    var output = \"\";\r\n    for (var i = 0; i < input.length; i++)\r\n        output += String.fromCharCode(input.charCodeAt(i) & 0xFF,\r\n            (input.charCodeAt(i) >>> 8) & 0xFF);\r\n    return output;\r\n}\r\n\r\nexport function str2rstr_utf16be(input) {\r\n    var output = \"\";\r\n    for (var i = 0; i < input.length; i++)\r\n        output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,\r\n            input.charCodeAt(i) & 0xFF);\r\n    return output;\r\n}\r\n\r\n/*\r\n * Convert a raw string to an array of little-endian words\r\n * Characters >255 have their high-byte silently ignored.\r\n */\r\nfunction rstr2binl(input) {\r\n    var output = Array(input.length >> 2);\r\n    for (let i = 0; i < output.length; i++) output[i] = 0;\r\n    for (let i = 0; i < input.length * 8; i += 8)\r\n        output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32);\r\n    return output;\r\n}\r\n\r\n/*\r\n * Convert an array of little-endian words to a string\r\n */\r\nfunction binl2rstr(input) {\r\n    var output = \"\";\r\n    for (var i = 0; i < input.length * 32; i += 8)\r\n        output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF);\r\n    return output;\r\n}\r\n\r\n/*\r\n * Calculate the MD5 of an array of little-endian words, and a bit length.\r\n */\r\nfunction binl_md5(x, len) {\r\n    /* append padding */\r\n    x[len >> 5] |= 0x80 << ((len) % 32);\r\n    x[(((len + 64) >>> 9) << 4) + 14] = len;\r\n\r\n    var a = 1732584193;\r\n    var b = -271733879;\r\n    var c = -1732584194;\r\n    var d = 271733878;\r\n\r\n    for (var i = 0; i < x.length; i += 16) {\r\n        var olda = a;\r\n        var oldb = b;\r\n        var oldc = c;\r\n        var oldd = d;\r\n\r\n        a = md5_ff(a, b, c, d, x[i + 0], 7, -680876936);\r\n        d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);\r\n        c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);\r\n        b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);\r\n        a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);\r\n        d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);\r\n        c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);\r\n        b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);\r\n        a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);\r\n        d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);\r\n        c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);\r\n        b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);\r\n        a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);\r\n        d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);\r\n        c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);\r\n        b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);\r\n\r\n        a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);\r\n        d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);\r\n        c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);\r\n        b = md5_gg(b, c, d, a, x[i + 0], 20, -373897302);\r\n        a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);\r\n        d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);\r\n        c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);\r\n        b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);\r\n        a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);\r\n        d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);\r\n        c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);\r\n        b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);\r\n        a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);\r\n        d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);\r\n        c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);\r\n        b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);\r\n\r\n        a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);\r\n        d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);\r\n        c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);\r\n        b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);\r\n        a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);\r\n        d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);\r\n        c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);\r\n        b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);\r\n        a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);\r\n        d = md5_hh(d, a, b, c, x[i + 0], 11, -358537222);\r\n        c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);\r\n        b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);\r\n        a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);\r\n        d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);\r\n        c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);\r\n        b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);\r\n\r\n        a = md5_ii(a, b, c, d, x[i + 0], 6, -198630844);\r\n        d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);\r\n        c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);\r\n        b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);\r\n        a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);\r\n        d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);\r\n        c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);\r\n        b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);\r\n        a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);\r\n        d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);\r\n        c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);\r\n        b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);\r\n        a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);\r\n        d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);\r\n        c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);\r\n        b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);\r\n\r\n        a = safe_add(a, olda);\r\n        b = safe_add(b, oldb);\r\n        c = safe_add(c, oldc);\r\n        d = safe_add(d, oldd);\r\n    }\r\n    return Array(a, b, c, d);\r\n}\r\n\r\n/*\r\n * These functions implement the four basic operations the algorithm uses.\r\n */\r\nfunction md5_cmn(q, a, b, x, s, t) {\r\n    return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);\r\n}\r\nfunction md5_ff(a, b, c, d, x, s, t) {\r\n    return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);\r\n}\r\nfunction md5_gg(a, b, c, d, x, s, t) {\r\n    return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);\r\n}\r\nfunction md5_hh(a, b, c, d, x, s, t) {\r\n    return md5_cmn(b ^ c ^ d, a, b, x, s, t);\r\n}\r\nfunction md5_ii(a, b, c, d, x, s, t) {\r\n    return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);\r\n}\r\n\r\n/*\r\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\r\n * to work around bugs in some JS interpreters.\r\n */\r\nfunction safe_add(x, y) {\r\n    var lsw = (x & 0xFFFF) + (y & 0xFFFF);\r\n    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\r\n    return (msw << 16) | (lsw & 0xFFFF);\r\n}\r\n\r\n/*\r\n * Bitwise rotate a 32-bit number to the left.\r\n */\r\nfunction bit_rol(num, cnt) {\r\n    return (num << cnt) | (num >>> (32 - cnt));\r\n}","import EventEmitter from \"../utils/event_emitter\";\r\nimport RemoteDevice from \"./remote_device\";\r\nimport RemoteSocket from \"./remote_socket\";\r\nimport SslSocket from \"./ssl_socket\";\r\nimport ChromeSocket from \"./chrome_socket\";\r\nimport {randomName, arrayToArrayBuffer} from \"../irc/irc_util\";\r\nimport {hex_md5} from \"../utils/rsa\";\r\n\r\n/**\r\n * Handles sending and receiving data from connected devices running different\r\n * instances of CIRC.\r\n */\r\nexport default class RemoteConnection extends EventEmitter {\r\n    constructor() {\r\n        super();\r\n        this._onDeviceClosed = this._onDeviceClosed.bind(this);\r\n        this._onConnectionMessage = this._onConnectionMessage.bind(this);\r\n        this._onSocketData = this._onSocketData.bind(this);\r\n        this._onUserInput = this._onUserInput.bind(this);\r\n        this._authenticateDevice = this._authenticateDevice.bind(this);\r\n        this._addUnauthenticatedDevice = this._addUnauthenticatedDevice.bind(this);\r\n        this._onHasOwnDevice = this._onHasOwnDevice.bind(this);\r\n        this._getAuthToken = this._getAuthToken.bind(this);\r\n\r\n        this.serverDevice = void 0;\r\n        this._connectingTo = void 0;\r\n        this._type = void 0;\r\n        this.devices = [];\r\n        this._ircSocketMap = {};\r\n        this._thisDevice = {};\r\n        this._state = \"device_state\";\r\n        this._getIRCState = function () { };\r\n        this._getChatLog = function () { };\r\n    }\r\n    /**\r\n     * Begin finding own IP addr and then listen for incoming connections.\r\n     */\r\n    init() {\r\n        return RemoteDevice.getOwnDevice(this._onHasOwnDevice);\r\n    }\r\n\r\n    setPassword(password) {\r\n        return this._password = password;\r\n    }\r\n\r\n    _getAuthToken(value) {\r\n        return hex_md5(this._password + value);\r\n    }\r\n\r\n    getConnectionInfo() {\r\n        return this._thisDevice;\r\n    }\r\n\r\n    getState() {\r\n        if (this._state === \"device_state\") {\r\n            if (!this._thisDevice.port) {\r\n                return \"finding_port\";\r\n            }\r\n            return this._thisDevice.getState();\r\n        } else {\r\n            return this._state;\r\n        }\r\n    }\r\n\r\n    setIRCStateFetcher(getState) {\r\n        return this._getIRCState = getState;\r\n    }\r\n\r\n    setChatLogFetcher(getChatLog) {\r\n        return this._getChatLog = getChatLog;\r\n    }\r\n\r\n    _onHasOwnDevice(device) {\r\n        this._thisDevice = device;\r\n        if (this._thisDevice.getState() === \"no_addr\") {\r\n            this._log(\"w\", \"Wasn't able to find address of own device\");\r\n            this.emit(\"no_addr\");\r\n            this._thisDevice.searchForAddress(() => this._onHasOwnDevice(this._thisDevice));\r\n            return;\r\n        }\r\n        this.emit(\"found_addr\");\r\n        return this._thisDevice.listenForNewDevices(this._addUnauthenticatedDevice);\r\n    }\r\n\r\n    _addUnauthenticatedDevice(device) {\r\n        this._log(\"adding unauthenticated device\", device.id);\r\n        device.password = randomName();\r\n        device.send(\"authentication_offer\", [device.password]);\r\n        return device.on(\"authenticate\", this._authenticateDevice);\r\n    }\r\n\r\n    _authenticateDevice(device, authToken) {\r\n        if (authToken === this._getAuthToken(device.password)) {\r\n            return this._addClientDevice(device);\r\n        } else {\r\n            this._log(\"w\", \"AUTH FAILED\", authToken, \"should be\", this._getAuthToken(device.password));\r\n            return device.close();\r\n        }\r\n    }\r\n\r\n    _addClientDevice(device) {\r\n        this._log(\"auth passed, adding client device\", device.id, device.addr);\r\n        this._listenToDevice(device);\r\n        this._addDevice(device);\r\n        this.emit(\"client_joined\", device);\r\n        device.send(\"connection_message\", [\"irc_state\", this._getIRCState()]);\r\n        return device.send(\"connection_message\", [\"chat_log\", this._getChatLog()]);\r\n    }\r\n\r\n    _addDevice(newDevice) {\r\n        this.devices.forEach(device => {\r\n            if (device.addr === newDevice.addr) device.close();\r\n        });\r\n        return this.devices.push(newDevice);\r\n    }\r\n\r\n    _listenToDevice(device) {\r\n        device.on(\"user_input\", this._onUserInput);\r\n        device.on(\"socket_data\", this._onSocketData);\r\n        device.on(\"connection_message\", this._onConnectionMessage);\r\n        device.on(\"closed\", this._onDeviceClosed);\r\n        return device.on(\"no_port\", () => this.emit(\"no_port\"));\r\n    }\r\n\r\n    _onUserInput(device, event) {\r\n        if (this.isServer()) {\r\n            this._broadcast(device, \"user_input\", event);\r\n        }\r\n        return this.emit(event.type, Event.wrap(event));\r\n    }\r\n\r\n    _onSocketData(device, server, type, data) {\r\n        var _ref;\r\n        if (type === \"data\") {\r\n            data = arrayToArrayBuffer(data);\r\n        }\r\n        return (_ref = this._ircSocketMap[server]) != null ? _ref.emit(type, data) : void 0;\r\n    }\r\n\r\n    _onConnectionMessage(...args) {\r\n        var isValid,\r\n            device = args[0],\r\n            type = args[1],\r\n            rest = 3 <= args.length ? args.slice(2) : [];\r\n        if (type === \"irc_state\") {\r\n            isValid = this._onIRCState(device, rest);\r\n            if (!isValid) return;\r\n        }\r\n        return this.emit(type, ...args);\r\n    }\r\n\r\n    _onIRCState(device, args) {\r\n        if (this.getState() !== \"connecting\") {\r\n            this._log(\"w\", \"got IRC state, but we're not connecting to a server -\", device.toString(), args);\r\n            device.close();\r\n            return false;\r\n        }\r\n        this._setServerDevice(device);\r\n        this._becomeClient();\r\n        return true;\r\n    }\r\n\r\n    _setServerDevice(device) {\r\n        var _ref;\r\n        if ((_ref = this.serverDevice) != null) {\r\n            _ref.close();\r\n        }\r\n        return this.serverDevice = device;\r\n    }\r\n\r\n    _onDeviceClosed(closedDevice) {\r\n        if (this._deviceIsClient(closedDevice)) {\r\n            this.emit(\"client_parted\", closedDevice);\r\n        }\r\n        if (this._deviceIsServer(closedDevice) && this.getState() === \"connected\") {\r\n            this._log(\"w\", \"lost connection to server -\", closedDevice.addr);\r\n            this._state = \"device_state\";\r\n            this._type = void 0;\r\n            this.emit(\"server_disconnected\");\r\n        }\r\n        else if (closedDevice.equals(this._connectingTo) && this.getState() !== \"connected\") {\r\n            this.emit(\"invalid_server\");\r\n        }\r\n\r\n        this.devices = this.devices.filter(device => device.id !== closedDevice.id);\r\n        return this.devices;\r\n    }\r\n\r\n    _deviceIsServer(device) {\r\n        return device != null ? device.equals(this.serverDevice) : void 0;\r\n    }\r\n\r\n    _deviceIsClient(device) {\r\n        if (device.equals(this.serverDevice || device.equals(this._thisDevice))) {\r\n            return false;\r\n        }\r\n        return this.devices.some(clientDevice => device.equals(clientDevice));\r\n    }\r\n\r\n    /**\r\n     * Create a socket for the given server. A fake socket is used when using\r\n     *  another devices IRC connection.\r\n     * @param {string} server The name of the IRC server that the socket is\r\n     *  connected to.\r\n     */\r\n    createSocket(server, port) {\r\n        var socket;\r\n        if (this.isClient()) {\r\n            socket = new RemoteSocket;\r\n            this._ircSocketMap[server] = socket;\r\n        } else {\r\n            if (port && port.substr && port.substr(0, 1) === \"+\")\r\n                socket = new SslSocket;\r\n            else\r\n                socket = new ChromeSocket;\r\n            this.broadcastSocketData(socket, server);\r\n        }\r\n        return socket;\r\n    }\r\n\r\n    broadcastUserInput(userInput) {\r\n        return userInput.on(\"command\", event => {\r\n            var name = event.name;\r\n            if (name !== \"network-info\"\r\n                    && name !== \"join-server\"\r\n                    && name !== \"make-server\"\r\n                    && name !== \"about\") {\r\n                return this._broadcast(\"user_input\", event);\r\n            }\r\n        });\r\n    }\r\n\r\n    broadcastSocketData(socket, server) {\r\n        return socket.onAny((type, data) => {\r\n            if (type === \"data\") {\r\n                data = new Uint8Array(data);\r\n            }\r\n            return this._broadcast(\"socket_data\", server, type, data);\r\n        });\r\n    }\r\n\r\n    _broadcast(opt_blacklistedDevice, type, ...rest) {\r\n        var blacklistedDevice;\r\n        if (typeof opt_blacklistedDevice === \"string\") {\r\n            rest = [type, ...rest];\r\n            type = opt_blacklistedDevice;\r\n            blacklistedDevice = void 0;\r\n        } else {\r\n            blacklistedDevice = opt_blacklistedDevice;\r\n        }\r\n\r\n        return this.devices\r\n            .filter(device => !device.equals(blacklistedDevice))\r\n            .map(device => device.send(type, rest));\r\n    }\r\n\r\n    disconnectDevices() {\r\n        this.devices.forEach(device => device.close());\r\n        return this.becomeIdle();\r\n    }\r\n\r\n    waitForPort(callback) {\r\n        if (this.getState() === \"found_port\") {\r\n            return callback(true);\r\n        }\r\n        if (this.getState() === \"no_port\" || this.getState() === \"no_addr\") {\r\n            return callback(false);\r\n        }\r\n        if (this._thisDevice != null) {\r\n            this._thisDevice.once(\"found_port\", () => callback(true));\r\n        }\r\n        if (this._thisDevice != null) {\r\n            this._thisDevice.once(\"no_port\", () => callback(false));\r\n        }\r\n        return this.once(\"no_addr\", () => callback(false));\r\n    }\r\n\r\n    becomeServer() {\r\n        if (this.isClient()) {\r\n            this.disconnectDevices();\r\n        }\r\n        this._type = \"server\";\r\n        return this._state = \"device_state\";\r\n    }\r\n\r\n    becomeIdle() {\r\n        this._type = \"idle\";\r\n        return this._state = \"device_state\";\r\n    }\r\n\r\n    _becomeClient() {\r\n        this._log(\"this device is now a client of\", this.serverDevice.toString());\r\n        this._type = \"client\";\r\n        this._state = \"connected\";\r\n        return this._addDevice(this.serverDevice);\r\n    }\r\n\r\n    disconnectFromServer() {\r\n        var _ref;\r\n        return (_ref = this.serverDevice) != null ? _ref.close() : void 0;\r\n    }\r\n    /**\r\n     * Connect to a remote server. The IRC connection of the remote server will\r\n     *  replace the local connection.\r\n     * @params {{port: number, addr: string}} connectInfo\r\n     */\r\n    connectToServer(connectInfo) {\r\n        var device, deviceToClose;\r\n        if (this._connectingTo) {\r\n            deviceToClose = this._connectingTo;\r\n            this._connectingTo = void 0;\r\n            deviceToClose.close();\r\n        }\r\n        this._state = \"connecting\";\r\n        device = new RemoteDevice(connectInfo.addr, connectInfo.port);\r\n        this._connectingTo = device;\r\n        this._listenToDevice(device);\r\n        return device.connect(success => {\r\n            if (success) {\r\n                return this._onConnectedToServer(device);\r\n            } else {\r\n                return this._onFailedToConnectToServer(device);\r\n            }\r\n        });\r\n    }\r\n\r\n    _onConnectedToServer(device) {\r\n        this._log(\"connected to server\", device.toString());\r\n        return device.on(\"authentication_offer\", (device, password) => {\r\n            device.password = password;\r\n            return this.emit(\"server_found\", device);\r\n        });\r\n    }\r\n\r\n    _onFailedToConnectToServer(device) {\r\n        this._state = \"device_state\";\r\n        return this.emit(\"invalid_server\", device);\r\n    }\r\n\r\n    finalizeConnection() {\r\n        if (!this._connectingTo) {\r\n            return;\r\n        }\r\n        this._state = \"connecting\";\r\n        return this._connectingTo.send(\"authenticate\", [this._getAuthToken(this._connectingTo.password)]);\r\n    }\r\n\r\n    isServer() {\r\n        return this._type === \"server\";\r\n    }\r\n\r\n    isClient() {\r\n        return this._type === \"client\";\r\n    }\r\n\r\n    isIdle() {\r\n        return this._type === \"idle\";\r\n    }\r\n\r\n    isInitializing() {\r\n        return this._type === void 0;\r\n    }\r\n}\r\n","import {getLogger} from \"./utils\";\r\n\r\n/**\r\n * Manages the sending and receiving of events.\r\n */\r\nexport default class EventEmitter {\r\n    constructor() {\r\n        this._log = getLogger(this);\r\n        this._listeners = {};\r\n        this._anyEventListeners = [];\r\n    }\r\n    /**\r\n     * Registers a callback to be invoked upon any event emission\r\n     * @param  {function} callback\r\n     */\r\n    onAny(callback) {\r\n        return this._anyEventListeners.push(callback);\r\n    }\r\n    /**\r\n     * Registers a callback to be invoked upon a specific event emission\r\n     * @param  {string} ev\r\n     * @param  {function} callback\r\n     */\r\n    on(ev, callback) {\r\n        var base, ref;\r\n        return ((ref = (base = this._listeners)[ev]) != null ? ref : base[ev] = []).push(callback);\r\n    }\r\n    /**\r\n     * Calls listeners for the supplied event, plus all \"any\" listeners\r\n     * @param  {string} ev\r\n     * @param  {any} ...data\r\n     * @return {Array} Results of \"any\" listeners\r\n     */\r\n    emit(ev, ...data) {\r\n        var anyListenersArray = this._anyEventListeners,\r\n            listenersArray = this._listeners[ev] || [];\r\n\r\n        listenersArray.forEach(listener => listener.apply(null, data));\r\n        return anyListenersArray.map(listener => listener.apply(null, [ev, ...data]));\r\n    }\r\n    /**\r\n     * Registers a callback to be invoked only once upon a specific event emission\r\n     * @param  {string} ev\r\n     * @param  {function} callback\r\n     */\r\n    once(ev, callback) {\r\n        var f = (...args) => {\r\n            this.removeListener(ev, f);\r\n            return callback.apply(null, ...args);\r\n        };\r\n        this.on(ev, f);\r\n        return f.listener = callback;\r\n    }\r\n    /**\r\n     * Removes a specific supplied callback from a list of event listeners\r\n     * @param  {string} ev\r\n     * @param  {function} callbackToRemove\r\n     * @return {Array} listeners\r\n     */\r\n    removeListener(ev, callbackToRemove) {\r\n        if (!(this._listeners && this._listeners[ev] && (callbackToRemove != null))) {\r\n            return;\r\n        }\r\n\r\n        this._listeners[ev] = this._listeners[ev].filter(listener => listener !== callbackToRemove);\r\n\r\n        return this._listeners[ev];\r\n    }\r\n}\r\n","/*\n * @name Lazy.js\n *\n * @fileOverview\n * Lazy.js is a lazy evaluation library for JavaScript.\n *\n * This has been done before. For examples see:\n *\n * - [wu.js](http://fitzgen.github.io/wu.js/)\n * - [Linq.js](http://linqjs.codeplex.com/)\n * - [from.js](https://github.com/suckgamoni/fromjs/)\n * - [IxJS](http://rx.codeplex.com/)\n * - [sloth.js](http://rfw.name/sloth.js/)\n *\n * However, at least at present, Lazy.js is faster (on average) than any of\n * those libraries. It is also more complete, with nearly all of the\n * functionality of [Underscore](http://underscorejs.org/) and\n * [Lo-Dash](http://lodash.com/).\n *\n * Finding your way around the code\n * --------------------------------\n *\n * At the heart of Lazy.js is the {@link Sequence} object. You create an initial\n * sequence using {@link Lazy}, which can accept an array, object, or string.\n * You can then \"chain\" together methods from this sequence, creating a new\n * sequence with each call.\n *\n * Here's an example:\n *\n *     var data = getReallyBigArray();\n *\n *     var statistics = Lazy(data)\n *       .map(transform)\n *       .filter(validate)\n *       .reduce(aggregate);\n *\n * {@link Sequence} is the foundation of other, more specific sequence types.\n *\n * An {@link ArrayLikeSequence} provides indexed access to its elements.\n *\n * An {@link ObjectLikeSequence} consists of key/value pairs.\n *\n * A {@link StringLikeSequence} is like a string (duh): actually, it is an\n * {@link ArrayLikeSequence} whose elements happen to be characters.\n *\n * An {@link AsyncSequence} is special: it iterates over its elements\n * asynchronously (so calling `each` generally begins an asynchronous loop and\n * returns immediately).\n *\n * For more information\n * --------------------\n *\n * I wrote a blog post that explains a little bit more about Lazy.js, which you\n * can read [here](http://philosopherdeveloper.com/posts/introducing-lazy-js.html).\n *\n * You can also [create an issue on GitHub](https://github.com/dtao/lazy.js/issues)\n * if you have any issues with the library. I work through them eventually.\n *\n * [@dtao](https://github.com/dtao)\n */\n\n(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.Lazy = factory();\n  }\n})(this, function(context) {\n  /**\n   * Wraps an object and returns a {@link Sequence}. For `null` or `undefined`,\n   * simply returns an empty sequence (see {@link Lazy.strict} for a stricter\n   * implementation).\n   *\n   * - For **arrays**, Lazy will create a sequence comprising the elements in\n   *   the array (an {@link ArrayLikeSequence}).\n   * - For **objects**, Lazy will create a sequence of key/value pairs\n   *   (an {@link ObjectLikeSequence}).\n   * - For **strings**, Lazy will create a sequence of characters (a\n   *   {@link StringLikeSequence}).\n   *\n   * @public\n   * @param {Array|Object|string} source An array, object, or string to wrap.\n   * @returns {Sequence} The wrapped lazy object.\n   *\n   * @exampleHelpers\n   * // Utility functions to provide to all examples\n   * function increment(x) { return x + 1; }\n   * function isEven(x) { return x % 2 === 0; }\n   * function isPositive(x) { return x > 0; }\n   * function isNegative(x) { return x < 0; }\n   *\n   * @examples\n   * Lazy([1, 2, 4])       // instanceof Lazy.ArrayLikeSequence\n   * Lazy({ foo: \"bar\" })  // instanceof Lazy.ObjectLikeSequence\n   * Lazy(\"hello, world!\") // instanceof Lazy.StringLikeSequence\n   * Lazy()                // sequence: []\n   * Lazy(null)            // sequence: []\n   */\n  function Lazy(source) {\n    if (source instanceof Array) {\n      return new ArrayWrapper(source);\n\n    } else if (typeof source === \"string\") {\n      return new StringWrapper(source);\n\n    } else if (source instanceof Sequence) {\n      return source;\n    }\n\n    if (Lazy.extensions) {\n      var extensions = Lazy.extensions, length = extensions.length, result;\n      while (!result && length--) {\n        result = extensions[length](source);\n      }\n      if (result) {\n        return result;\n      }\n    }\n\n    return new ObjectWrapper(source);\n  }\n\n  Lazy.VERSION = '0.4.2';\n\n  /*** Utility methods of questionable value ***/\n\n  Lazy.noop = function noop() {};\n  Lazy.identity = function identity(x) { return x; };\n\n  /**\n   * Provides a stricter version of {@link Lazy} which throws an error when\n   * attempting to wrap `null`, `undefined`, or numeric or boolean values as a\n   * sequence.\n   *\n   * @public\n   * @returns {Function} A stricter version of the {@link Lazy} helper function.\n   *\n   * @examples\n   * var Strict = Lazy.strict();\n   *\n   * Strict()                  // throws\n   * Strict(null)              // throws\n   * Strict(true)              // throws\n   * Strict(5)                 // throws\n   * Strict([1, 2, 3])         // instanceof Lazy.ArrayLikeSequence\n   * Strict({ foo: \"bar\" })    // instanceof Lazy.ObjectLikeSequence\n   * Strict(\"hello, world!\")   // instanceof Lazy.StringLikeSequence\n   *\n   * // Let's also ensure the static functions are still there.\n   * Strict.range(3)           // sequence: [0, 1, 2]\n   * Strict.generate(Date.now) // instanceof Lazy.GeneratedSequence\n   */\n  Lazy.strict = function strict() {\n    function StrictLazy(source) {\n      if (source == null) {\n        throw new Error(\"You cannot wrap null or undefined using Lazy.\");\n      }\n\n      if (typeof source === \"number\" || typeof source === \"boolean\") {\n        throw new Error(\"You cannot wrap primitive values using Lazy.\");\n      }\n\n      return Lazy(source);\n    };\n\n    Lazy(Lazy).each(function(property, name) {\n      StrictLazy[name] = property;\n    });\n\n    return StrictLazy;\n  };\n\n  /**\n   * The `Sequence` object provides a unified API encapsulating the notion of\n   * zero or more consecutive elements in a collection, stream, etc.\n   *\n   * Lazy evaluation\n   * ---------------\n   *\n   * Generally speaking, creating a sequence should not be an expensive operation,\n   * and should not iterate over an underlying source or trigger any side effects.\n   * This means that chaining together methods that return sequences incurs only\n   * the cost of creating the `Sequence` objects themselves and not the cost of\n   * iterating an underlying data source multiple times.\n   *\n   * The following code, for example, creates 4 sequences and does nothing with\n   * `source`:\n   *\n   *     var seq = Lazy(source) // 1st sequence\n   *       .map(func)           // 2nd\n   *       .filter(pred)        // 3rd\n   *       .reverse();          // 4th\n   *\n   * Lazy's convention is to hold off on iterating or otherwise *doing* anything\n   * (aside from creating `Sequence` objects) until you call `each`:\n   *\n   *     seq.each(function(x) { console.log(x); });\n   *\n   * Defining custom sequences\n   * -------------------------\n   *\n   * Defining your own type of sequence is relatively simple:\n   *\n   * 1. Pass a *method name* and an object containing *function overrides* to\n   *    {@link Sequence.define}. If the object includes a function called `init`,\n   *    this function will be called upon initialization.\n   * 2. The object should include at least either a `getIterator` method or an\n   *    `each` method. The former supports both asynchronous and synchronous\n   *    iteration, but is slightly more cumbersome to implement. The latter\n   *    supports synchronous iteration and can be automatically implemented in\n   *    terms of the former. You can also implement both if you want, e.g. to\n   *    optimize performance. For more info, see {@link Iterator} and\n   *    {@link AsyncSequence}.\n   *\n   * As a trivial example, the following code defines a new method, `sample`,\n   * which randomly may or may not include each element from its parent.\n   *\n   *     Lazy.Sequence.define(\"sample\", {\n   *       each: function(fn) {\n   *         return this.parent.each(function(e) {\n   *           // 50/50 chance of including this element.\n   *           if (Math.random() > 0.5) {\n   *             return fn(e);\n   *           }\n   *         });\n   *       }\n   *     });\n   *\n   * (Of course, the above could also easily have been implemented using\n   * {@link #filter} instead of creating a custom sequence. But I *did* say this\n   * was a trivial example, to be fair.)\n   *\n   * Now it will be possible to create this type of sequence from any parent\n   * sequence by calling the method name you specified. In other words, you can\n   * now do this:\n   *\n   *     Lazy(arr).sample();\n   *     Lazy(arr).map(func).sample();\n   *     Lazy(arr).map(func).filter(pred).sample();\n   *\n   * Etc., etc.\n   *\n   * @public\n   * @constructor\n   */\n  function Sequence() {}\n\n  /**\n   * Create a new constructor function for a type inheriting from `Sequence`.\n   *\n   * @public\n   * @param {string|Array.<string>} methodName The name(s) of the method(s) to be\n   *     used for constructing the new sequence. The method will be attached to\n   *     the `Sequence` prototype so that it can be chained with any other\n   *     sequence methods, like {@link #map}, {@link #filter}, etc.\n   * @param {Object} overrides An object containing function overrides for this\n   *     new sequence type. **Must** include either `getIterator` or `each` (or\n   *     both). *May* include an `init` method as well. For these overrides,\n   *     `this` will be the new sequence, and `this.parent` will be the base\n   *     sequence from which the new sequence was constructed.\n   * @returns {Function} A constructor for a new type inheriting from `Sequence`.\n   *\n   * @examples\n   * // This sequence type logs every element to the specified logger as it\n   * // iterates over it.\n   * Lazy.Sequence.define(\"verbose\", {\n   *   init: function(logger) {\n   *     this.logger = logger;\n   *   },\n   *\n   *   each: function(fn) {\n   *     var logger = this.logger;\n   *     return this.parent.each(function(e, i) {\n   *       logger(e);\n   *       return fn(e, i);\n   *     });\n   *   }\n   * });\n   *\n   * Lazy([1, 2, 3]).verbose(logger).each(Lazy.noop) // calls logger 3 times\n   */\n  Sequence.define = function define(methodName, overrides) {\n    if (!overrides || (!overrides.getIterator && !overrides.each)) {\n      throw new Error(\"A custom sequence must implement *at least* getIterator or each!\");\n    }\n\n    return defineSequenceType(Sequence, methodName, overrides);\n  };\n\n  /**\n   * Gets the number of elements in the sequence. In some cases, this may\n   * require eagerly evaluating the sequence.\n   *\n   * @public\n   * @returns {number} The number of elements in the sequence.\n   *\n   * @examples\n   * Lazy([1, 2, 3]).size();                 // => 3\n   * Lazy([1, 2]).map(Lazy.identity).size(); // => 2\n   * Lazy([1, 2, 3]).reject(isEven).size();  // => 2\n   * Lazy([1, 2, 3]).take(1).size();         // => 1\n   * Lazy({ foo: 1, bar: 2 }).size();        // => 2\n   * Lazy('hello').size();                   // => 5\n   */\n  Sequence.prototype.size = function size() {\n    return this.getIndex().length();\n  };\n\n  /**\n   * Creates an {@link Iterator} object with two methods, `moveNext` -- returning\n   * true or false -- and `current` -- returning the current value.\n   *\n   * This method is used when asynchronously iterating over sequences. Any type\n   * inheriting from `Sequence` must implement this method or it can't support\n   * asynchronous iteration.\n   *\n   * Note that **this method is not intended to be used directly by application\n   * code.** Rather, it is intended as a means for implementors to potentially\n   * define custom sequence types that support either synchronous or\n   * asynchronous iteration.\n   *\n   * @public\n   * @returns {Iterator} An iterator object.\n   *\n   * @examples\n   * var iterator = Lazy([1, 2]).getIterator();\n   *\n   * iterator.moveNext(); // => true\n   * iterator.current();  // => 1\n   * iterator.moveNext(); // => true\n   * iterator.current();  // => 2\n   * iterator.moveNext(); // => false\n   */\n  Sequence.prototype.getIterator = function getIterator() {\n    return new Iterator(this);\n  };\n\n  /**\n   * Gets the root sequence underlying the current chain of sequences.\n   */\n  Sequence.prototype.root = function root() {\n    return this.parent.root();\n  };\n\n  /**\n   * Whether or not the current sequence is an asynchronous one. This is more\n   * accurate than checking `instanceof {@link AsyncSequence}` because, for\n   * example, `Lazy([1, 2, 3]).async().map(Lazy.identity)` returns a sequence\n   * that iterates asynchronously even though it's not an instance of\n   * `AsyncSequence`.\n   *\n   * @returns {boolean} Whether or not the current sequence is an asynchronous one.\n   */\n  Sequence.prototype.isAsync = function isAsync() {\n    return this.parent ? this.parent.isAsync() : false;\n  };\n\n  /**\n   * Evaluates the sequence and produces the appropriate value (an array in most\n   * cases, an object for {@link ObjectLikeSequence}s or a string for\n   * {@link StringLikeSequence}s).\n   *\n   * @returns {Array|string|Object} The value resulting from fully evaluating\n   *     the sequence.\n   */\n  Sequence.prototype.value = function value() {\n    return this.toArray();\n  };\n\n  /**\n   * Applies the current transformation chain to a given source, returning the\n   * resulting value.\n   *\n   * @examples\n   * var sequence = Lazy([])\n   *   .map(function(x) { return x * -1; })\n   *   .filter(function(x) { return x % 2 === 0; });\n   *\n   * sequence.apply([1, 2, 3, 4]); // => [-2, -4]\n   */\n  Sequence.prototype.apply = function apply(source) {\n    var root = this.root(),\n        previousSource = root.source,\n        result;\n\n    try {\n      root.source = source;\n      result = this.value();\n    } finally {\n      root.source = previousSource;\n    }\n\n    return result;\n  };\n\n  /**\n   * The Iterator object provides an API for iterating over a sequence.\n   *\n   * The purpose of the `Iterator` type is mainly to offer an agnostic way of\n   * iterating over a sequence -- either synchronous (i.e. with a `while` loop)\n   * or asynchronously (with recursive calls to either `setTimeout` or --- if\n   * available --- `setImmediate`). It is not intended to be used directly by\n   * application code.\n   *\n   * @public\n   * @constructor\n   * @param {Sequence} sequence The sequence to iterate over.\n   */\n  function Iterator(sequence) {\n    this.sequence = sequence;\n    this.index    = -1;\n  }\n\n  /**\n   * Gets the current item this iterator is pointing to.\n   *\n   * @public\n   * @returns {*} The current item.\n   */\n  Iterator.prototype.current = function current() {\n    return this.cachedIndex && this.cachedIndex.get(this.index);\n  };\n\n  /**\n   * Moves the iterator to the next item in a sequence, if possible.\n   *\n   * @public\n   * @returns {boolean} True if the iterator is able to move to a new item, or else\n   *     false.\n   */\n  Iterator.prototype.moveNext = function moveNext() {\n    var cachedIndex = this.cachedIndex;\n\n    if (!cachedIndex) {\n      cachedIndex = this.cachedIndex = this.sequence.getIndex();\n    }\n\n    if (this.index >= cachedIndex.length() - 1) {\n      return false;\n    }\n\n    ++this.index;\n    return true;\n  };\n\n  /**\n   * Creates an array snapshot of a sequence.\n   *\n   * Note that for indefinite sequences, this method may raise an exception or\n   * (worse) cause the environment to hang.\n   *\n   * @public\n   * @returns {Array} An array containing the current contents of the sequence.\n   *\n   * @examples\n   * Lazy([1, 2, 3]).toArray() // => [1, 2, 3]\n   */\n  Sequence.prototype.toArray = function toArray() {\n    return this.reduce(function(arr, element) {\n      arr.push(element);\n      return arr;\n    }, []);\n  };\n\n  /**\n   * Provides an indexed view into the sequence.\n   *\n   * For sequences that are already indexed, this will simply return the\n   * sequence. For non-indexed sequences, this will eagerly evaluate the\n   * sequence.\n   *\n   * @returns {ArrayLikeSequence} A sequence containing the current contents of\n   *     the sequence.\n   *\n   * @examples\n   * Lazy([1, 2, 3]).filter(isEven)            // instanceof Lazy.Sequence\n   * Lazy([1, 2, 3]).filter(isEven).getIndex() // instanceof Lazy.ArrayLikeSequence\n   */\n  Sequence.prototype.getIndex = function getIndex() {\n    return new ArrayWrapper(this.toArray());\n  };\n\n  /**\n   * Returns the element at the specified index. Note that, for sequences that\n   * are not {@link ArrayLikeSequence}s, this may require partially evaluating\n   * the sequence, iterating to reach the result. (In other words for such\n   * sequences this method is not O(1).)\n   *\n   * @public\n   * @param {number} i The index to access.\n   * @returns {*} The element.\n   *\n   */\n  Sequence.prototype.get = function get(i) {\n    var element;\n    this.each(function(e, index) {\n      if (index === i) {\n        element = e;\n        return false;\n      }\n    });\n    return element;\n  };\n\n  /**\n   * Provides an indexed, memoized view into the sequence. This will cache the\n   * result whenever the sequence is first iterated, so that subsequent\n   * iterations will access the same element objects.\n   *\n   * @public\n   * @returns {ArrayLikeSequence} An indexed, memoized sequence containing this\n   *     sequence's elements, cached after the first iteration.\n   *\n   * @example\n   * function createObject() { return new Object(); }\n   *\n   * var plain    = Lazy.generate(createObject, 10),\n   *     memoized = Lazy.generate(createObject, 10).memoize();\n   *\n   * plain.toArray()[0] === plain.toArray()[0];       // => false\n   * memoized.toArray()[0] === memoized.toArray()[0]; // => true\n   */\n  Sequence.prototype.memoize = function memoize() {\n    return new MemoizedSequence(this);\n  };\n\n  /**\n   * @constructor\n   */\n  function MemoizedSequence(parent) {\n    this.parent = parent;\n  }\n\n  // MemoizedSequence needs to have its prototype set up after ArrayLikeSequence\n\n  /**\n   * Creates an object from a sequence of key/value pairs.\n   *\n   * @public\n   * @returns {Object} An object with keys and values corresponding to the pairs\n   *     of elements in the sequence.\n   *\n   * @examples\n   * var details = [\n   *   [\"first\", \"Dan\"],\n   *   [\"last\", \"Tao\"],\n   *   [\"age\", 29]\n   * ];\n   *\n   * Lazy(details).toObject() // => { first: \"Dan\", last: \"Tao\", age: 29 }\n   */\n  Sequence.prototype.toObject = function toObject() {\n    return this.reduce(function(object, pair) {\n      object[pair[0]] = pair[1];\n      return object;\n    }, {});\n  };\n\n  /**\n   * Iterates over this sequence and executes a function for every element.\n   *\n   * @public\n   * @aka forEach\n   * @param {Function} fn The function to call on each element in the sequence.\n   *     Return false from the function to end the iteration.\n   * @returns {boolean} `true` if the iteration evaluated the entire sequence,\n   *     or `false` if iteration was ended early.\n   *\n   * @examples\n   * Lazy([1, 2, 3, 4]).each(fn) // calls fn 4 times\n   */\n  Sequence.prototype.each = function each(fn) {\n    var iterator = this.getIterator(),\n        i = -1;\n\n    while (iterator.moveNext()) {\n      if (fn(iterator.current(), ++i) === false) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  Sequence.prototype.forEach = function forEach(fn) {\n    return this.each(fn);\n  };\n\n  /**\n   * Creates a new sequence whose values are calculated by passing this sequence's\n   * elements through some mapping function.\n   *\n   * @public\n   * @aka collect\n   * @param {Function} mapFn The mapping function used to project this sequence's\n   *     elements onto a new sequence. This function takes up to two arguments:\n   *     the element, and the current index.\n   * @returns {Sequence} The new sequence.\n   *\n   * @examples\n   * function addIndexToValue(e, i) { return e + i; }\n   *\n   * Lazy([]).map(increment)              // sequence: []\n   * Lazy([1, 2, 3]).map(increment)       // sequence: [2, 3, 4]\n   * Lazy([1, 2, 3]).map(addIndexToValue) // sequence: [1, 3, 5]\n   *\n   * @benchmarks\n   * function increment(x) { return x + 1; }\n   *\n   * var smArr = Lazy.range(10).toArray(),\n   *     lgArr = Lazy.range(100).toArray();\n   *\n   * Lazy(smArr).map(increment).each(Lazy.noop) // lazy - 10 elements\n   * Lazy(lgArr).map(increment).each(Lazy.noop) // lazy - 100 elements\n   * _.each(_.map(smArr, increment), _.noop)    // lodash - 10 elements\n   * _.each(_.map(lgArr, increment), _.noop)    // lodash - 100 elements\n   */\n  Sequence.prototype.map = function map(mapFn) {\n    return new MappedSequence(this, createCallback(mapFn));\n  };\n\n  Sequence.prototype.collect = function collect(mapFn) {\n    return this.map(mapFn);\n  };\n\n  /**\n   * @constructor\n   */\n  function MappedSequence(parent, mapFn) {\n    this.parent = parent;\n    this.mapFn  = mapFn;\n  }\n\n  MappedSequence.prototype = new Sequence();\n\n  MappedSequence.prototype.getIterator = function getIterator() {\n    return new MappingIterator(this.parent, this.mapFn);\n  };\n\n  MappedSequence.prototype.each = function each(fn) {\n    var mapFn = this.mapFn;\n    return this.parent.each(function(e, i) {\n      return fn(mapFn(e, i), i);\n    });\n  };\n\n  /**\n   * @constructor\n   */\n  function MappingIterator(sequence, mapFn) {\n    this.iterator = sequence.getIterator();\n    this.mapFn    = mapFn;\n    this.index    = -1;\n  }\n\n  MappingIterator.prototype.current = function current() {\n    return this.mapFn(this.iterator.current(), this.index);\n  };\n\n  MappingIterator.prototype.moveNext = function moveNext() {\n    if (this.iterator.moveNext()) {\n      ++this.index;\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * Creates a new sequence whose values are calculated by accessing the specified\n   * property from each element in this sequence.\n   *\n   * @public\n   * @param {string} propertyName The name of the property to access for every\n   *     element in this sequence.\n   * @returns {Sequence} The new sequence.\n   *\n   * @examples\n   * var people = [\n   *   { first: \"Dan\", last: \"Tao\" },\n   *   { first: \"Bob\", last: \"Smith\" }\n   * ];\n   *\n   * Lazy(people).pluck(\"last\") // sequence: [\"Tao\", \"Smith\"]\n   */\n  Sequence.prototype.pluck = function pluck(property) {\n    return this.map(property);\n  };\n\n  /**\n   * Creates a new sequence whose values are calculated by invoking the specified\n   * function on each element in this sequence.\n   *\n   * @public\n   * @param {string} methodName The name of the method to invoke for every element\n   *     in this sequence.\n   * @returns {Sequence} The new sequence.\n   *\n   * @examples\n   * function Person(first, last) {\n   *   this.fullName = function fullName() {\n   *     return first + \" \" + last;\n   *   };\n   * }\n   *\n   * var people = [\n   *   new Person(\"Dan\", \"Tao\"),\n   *   new Person(\"Bob\", \"Smith\")\n   * ];\n   *\n   * Lazy(people).invoke(\"fullName\") // sequence: [\"Dan Tao\", \"Bob Smith\"]\n   */\n  Sequence.prototype.invoke = function invoke(methodName) {\n    return this.map(function(e) {\n      return e[methodName]();\n    });\n  };\n\n  /**\n   * Creates a new sequence whose values are the elements of this sequence which\n   * satisfy the specified predicate.\n   *\n   * @public\n   * @aka select\n   * @param {Function} filterFn The predicate to call on each element in this\n   *     sequence, which returns true if the element should be included.\n   * @returns {Sequence} The new sequence.\n   *\n   * @examples\n   * var numbers = [1, 2, 3, 4, 5, 6];\n   *\n   * Lazy(numbers).filter(isEven) // sequence: [2, 4, 6]\n   *\n   * @benchmarks\n   * function isEven(x) { return x % 2 === 0; }\n   *\n   * var smArr = Lazy.range(10).toArray(),\n   *     lgArr = Lazy.range(100).toArray();\n   *\n   * Lazy(smArr).filter(isEven).each(Lazy.noop) // lazy - 10 elements\n   * Lazy(lgArr).filter(isEven).each(Lazy.noop) // lazy - 100 elements\n   * _.each(_.filter(smArr, isEven), _.noop)    // lodash - 10 elements\n   * _.each(_.filter(lgArr, isEven), _.noop)    // lodash - 100 elements\n   */\n  Sequence.prototype.filter = function filter(filterFn) {\n    return new FilteredSequence(this, createCallback(filterFn));\n  };\n\n  Sequence.prototype.select = function select(filterFn) {\n    return this.filter(filterFn);\n  };\n\n  /**\n   * @constructor\n   */\n  function FilteredSequence(parent, filterFn) {\n    this.parent   = parent;\n    this.filterFn = filterFn;\n  }\n\n  FilteredSequence.prototype = new Sequence();\n\n  FilteredSequence.prototype.getIterator = function getIterator() {\n    return new FilteringIterator(this.parent, this.filterFn);\n  };\n\n  FilteredSequence.prototype.each = function each(fn) {\n    var filterFn = this.filterFn,\n        j = 0;\n\n    return this.parent.each(function(e, i) {\n      if (filterFn(e, i)) {\n        return fn(e, j++);\n      }\n    });\n  };\n\n  FilteredSequence.prototype.reverse = function reverse() {\n    return this.parent.reverse().filter(this.filterFn);\n  };\n\n  /**\n   * @constructor\n   */\n  function FilteringIterator(sequence, filterFn) {\n    this.iterator = sequence.getIterator();\n    this.filterFn = filterFn;\n    this.index    = 0;\n  }\n\n  FilteringIterator.prototype.current = function current() {\n    return this.value;\n  };\n\n  FilteringIterator.prototype.moveNext = function moveNext() {\n    var iterator = this.iterator,\n        filterFn = this.filterFn,\n        value;\n\n    while (iterator.moveNext()) {\n      value = iterator.current();\n      if (filterFn(value, this.index++)) {\n        this.value = value;\n        return true;\n      }\n    }\n\n    this.value = undefined;\n    return false;\n  };\n\n  /**\n   * Creates a new sequence whose values exclude the elements of this sequence\n   * identified by the specified predicate.\n   *\n   * @public\n   * @param {Function} rejectFn The predicate to call on each element in this\n   *     sequence, which returns true if the element should be omitted.\n   * @returns {Sequence} The new sequence.\n   *\n   * @examples\n   * Lazy([1, 2, 3, 4, 5]).reject(isEven)              // sequence: [1, 3, 5]\n   * Lazy([{ foo: 1 }, { bar: 2 }]).reject('foo')      // sequence: [{ bar: 2 }]\n   * Lazy([{ foo: 1 }, { foo: 2 }]).reject({ foo: 2 }) // sequence: [{ foo: 1 }]\n   */\n  Sequence.prototype.reject = function reject(rejectFn) {\n    rejectFn = createCallback(rejectFn);\n    return this.filter(function(e) { return !rejectFn(e); });\n  };\n\n  /**\n   * Creates a new sequence whose values have the specified type, as determined\n   * by the `typeof` operator.\n   *\n   * @public\n   * @param {string} type The type of elements to include from the underlying\n   *     sequence, i.e. where `typeof [element] === [type]`.\n   * @returns {Sequence} The new sequence, comprising elements of the specified\n   *     type.\n   *\n   * @examples\n   * Lazy([1, 2, 'foo', 'bar']).ofType('number')  // sequence: [1, 2]\n   * Lazy([1, 2, 'foo', 'bar']).ofType('string')  // sequence: ['foo', 'bar']\n   * Lazy([1, 2, 'foo', 'bar']).ofType('boolean') // sequence: []\n   */\n  Sequence.prototype.ofType = function ofType(type) {\n    return this.filter(function(e) { return typeof e === type; });\n  };\n\n  /**\n   * Creates a new sequence whose values are the elements of this sequence with\n   * property names and values matching those of the specified object.\n   *\n   * @public\n   * @param {Object} properties The properties that should be found on every\n   *     element that is to be included in this sequence.\n   * @returns {Sequence} The new sequence.\n   *\n   * @examples\n   * var people = [\n   *   { first: \"Dan\", last: \"Tao\" },\n   *   { first: \"Bob\", last: \"Smith\" }\n   * ];\n   *\n   * Lazy(people).where({ first: \"Dan\" }) // sequence: [{ first: \"Dan\", last: \"Tao\" }]\n   *\n   * @benchmarks\n   * var animals = [\"dog\", \"cat\", \"mouse\", \"horse\", \"pig\", \"snake\"];\n   *\n   * Lazy(animals).where({ length: 3 }).each(Lazy.noop) // lazy\n   * _.each(_.where(animals, { length: 3 }), _.noop)    // lodash\n   */\n  Sequence.prototype.where = function where(properties) {\n    return this.filter(properties);\n  };\n\n  /**\n   * Creates a new sequence with the same elements as this one, but to be iterated\n   * in the opposite order.\n   *\n   * Note that in some (but not all) cases, the only way to create such a sequence\n   * may require iterating the entire underlying source when `each` is called.\n   *\n   * @public\n   * @returns {Sequence} The new sequence.\n   *\n   * @examples\n   * Lazy([1, 2, 3]).reverse() // sequence: [3, 2, 1]\n   * Lazy([]).reverse()        // sequence: []\n   */\n  Sequence.prototype.reverse = function reverse() {\n    return new ReversedSequence(this);\n  };\n\n  /**\n   * @constructor\n   */\n  function ReversedSequence(parent) {\n    this.parent = parent;\n  }\n\n  ReversedSequence.prototype = new Sequence();\n\n  ReversedSequence.prototype.getIterator = function getIterator() {\n    return new ReversedIterator(this.parent);\n  };\n\n  /**\n   * @constuctor\n   */\n  function ReversedIterator(sequence) {\n    this.sequence = sequence;\n  }\n\n  ReversedIterator.prototype.current = function current() {\n    return this.getIndex().get(this.index);\n  };\n\n  ReversedIterator.prototype.moveNext = function moveNext() {\n    var index  = this.getIndex(),\n        length = index.length();\n\n    if (typeof this.index === \"undefined\") {\n      this.index = length;\n    }\n\n    return (--this.index >= 0);\n  };\n\n  ReversedIterator.prototype.getIndex = function getIndex() {\n    if (!this.cachedIndex) {\n      this.cachedIndex = this.sequence.getIndex();\n    }\n\n    return this.cachedIndex;\n  };\n\n  /**\n   * Creates a new sequence with all of the elements of this one, plus those of\n   * the given array(s).\n   *\n   * @public\n   * @param {...*} var_args One or more values (or arrays of values) to use for\n   *     additional items after this sequence.\n   * @returns {Sequence} The new sequence.\n   *\n   * @examples\n   * var left  = [1, 2, 3];\n   * var right = [4, 5, 6];\n   *\n   * Lazy(left).concat(right)         // sequence: [1, 2, 3, 4, 5, 6]\n   * Lazy(left).concat(Lazy(right))   // sequence: [1, 2, 3, 4, 5, 6]\n   * Lazy(left).concat(right, [7, 8]) // sequence: [1, 2, 3, 4, 5, 6, 7, 8]\n   */\n  Sequence.prototype.concat = function concat(var_args) {\n    return new ConcatenatedSequence(this, arraySlice.call(arguments, 0));\n  };\n\n  /**\n   * @constructor\n   */\n  function ConcatenatedSequence(parent, arrays) {\n    this.parent = parent;\n    this.arrays = arrays;\n  }\n\n  ConcatenatedSequence.prototype = new Sequence();\n\n  ConcatenatedSequence.prototype.each = function each(fn) {\n    var done = false,\n        i = 0;\n\n    this.parent.each(function(e) {\n      if (fn(e, i++) === false) {\n        done = true;\n        return false;\n      }\n    });\n\n    if (!done) {\n      Lazy(this.arrays).flatten().each(function(e) {\n        if (fn(e, i++) === false) {\n          return false;\n        }\n      });\n    }\n  };\n\n  /**\n   * Creates a new sequence comprising the first N elements from this sequence, OR\n   * (if N is `undefined`) simply returns the first element of this sequence.\n   *\n   * @public\n   * @aka head, take\n   * @param {number=} count The number of elements to take from this sequence. If\n   *     this value exceeds the length of the sequence, the resulting sequence\n   *     will be essentially the same as this one.\n   * @returns {*} The new sequence (or the first element from this sequence if\n   *     no count was given).\n   *\n   * @examples\n   * function powerOfTwo(exp) {\n   *   return Math.pow(2, exp);\n   * }\n   *\n   * Lazy.generate(powerOfTwo).first()          // => 1\n   * Lazy.generate(powerOfTwo).first(5)         // sequence: [1, 2, 4, 8, 16]\n   * Lazy.generate(powerOfTwo).skip(2).first()  // => 4\n   * Lazy.generate(powerOfTwo).skip(2).first(2) // sequence: [4, 8]\n   */\n  Sequence.prototype.first = function first(count) {\n    if (typeof count === \"undefined\") {\n      return getFirst(this);\n    }\n    return new TakeSequence(this, count);\n  };\n\n  Sequence.prototype.head =\n  Sequence.prototype.take = function (count) {\n    return this.first(count);\n  };\n\n  /**\n   * @constructor\n   */\n  function TakeSequence(parent, count) {\n    this.parent = parent;\n    this.count  = count;\n  }\n\n  TakeSequence.prototype = new Sequence();\n\n  TakeSequence.prototype.getIterator = function getIterator() {\n    return new TakeIterator(this.parent, this.count);\n  };\n\n  TakeSequence.prototype.each = function each(fn) {\n    var count = this.count,\n        i     = 0;\n\n    var result;\n    var handle = this.parent.each(function(e) {\n      if (i < count) { result = fn(e, i++); }\n      if (i >= count) { return false; }\n      return result;\n    });\n\n    if (handle instanceof AsyncHandle) {\n      return handle;\n    }\n\n    return i === count && result !== false;\n  };\n\n  /**\n   * @constructor\n   */\n  function TakeIterator(sequence, count) {\n    this.iterator = sequence.getIterator();\n    this.count    = count;\n  }\n\n  TakeIterator.prototype.current = function current() {\n    return this.iterator.current();\n  };\n\n  TakeIterator.prototype.moveNext = function moveNext() {\n    return ((--this.count >= 0) && this.iterator.moveNext());\n  };\n\n  /**\n   * Creates a new sequence comprising the elements from the head of this sequence\n   * that satisfy some predicate. Once an element is encountered that doesn't\n   * satisfy the predicate, iteration will stop.\n   *\n   * @public\n   * @param {Function} predicate\n   * @returns {Sequence} The new sequence\n   *\n   * @examples\n   * function lessThan(x) {\n   *   return function(y) {\n   *     return y < x;\n   *   };\n   * }\n   *\n   * Lazy([1, 2, 3, 4]).takeWhile(lessThan(3)) // sequence: [1, 2]\n   * Lazy([1, 2, 3, 4]).takeWhile(lessThan(0)) // sequence: []\n   */\n  Sequence.prototype.takeWhile = function takeWhile(predicate) {\n    return new TakeWhileSequence(this, predicate);\n  };\n\n  /**\n   * @constructor\n   */\n  function TakeWhileSequence(parent, predicate) {\n    this.parent    = parent;\n    this.predicate = predicate;\n  }\n\n  TakeWhileSequence.prototype = new Sequence();\n\n  TakeWhileSequence.prototype.each = function each(fn) {\n    var predicate = this.predicate,\n        finished = false,\n        j = 0;\n\n    var result = this.parent.each(function(e, i) {\n      if (!predicate(e, i)) {\n        finished = true;\n        return false;\n      }\n\n      return fn(e, j++);\n    });\n\n    if (result instanceof AsyncHandle) {\n      return result;\n    }\n\n    return finished;\n  };\n\n  /**\n   * Creates a new sequence comprising all but the last N elements of this\n   * sequence.\n   *\n   * @public\n   * @param {number=} count The number of items to omit from the end of the\n   *     sequence (defaults to 1).\n   * @returns {Sequence} The new sequence.\n   *\n   * @examples\n   * Lazy([1, 2, 3, 4]).initial()                    // sequence: [1, 2, 3]\n   * Lazy([1, 2, 3, 4]).initial(2)                   // sequence: [1, 2]\n   * Lazy([1, 2, 3]).filter(Lazy.identity).initial() // sequence: [1, 2]\n   */\n  Sequence.prototype.initial = function initial(count) {\n    return new InitialSequence(this, count);\n  };\n\n  function InitialSequence(parent, count) {\n    this.parent = parent;\n    this.count = typeof count === \"number\" ? count : 1;\n  }\n\n  InitialSequence.prototype = new Sequence();\n\n  InitialSequence.prototype.each = function each(fn) {\n    var index = this.parent.getIndex();\n    return index.take(index.length() - this.count).each(fn);\n  };\n\n  /**\n   * Creates a new sequence comprising the last N elements of this sequence, OR\n   * (if N is `undefined`) simply returns the last element of this sequence.\n   *\n   * @public\n   * @param {number=} count The number of items to take from the end of the\n   *     sequence.\n   * @returns {*} The new sequence (or the last element from this sequence\n   *     if no count was given).\n   *\n   * @examples\n   * Lazy([1, 2, 3]).last()                 // => 3\n   * Lazy([1, 2, 3]).last(2)                // sequence: [2, 3]\n   * Lazy([1, 2, 3]).filter(isEven).last(2) // sequence: [2]\n   */\n  Sequence.prototype.last = function last(count) {\n    if (typeof count === \"undefined\") {\n      return this.reverse().first();\n    }\n    return this.reverse().take(count).reverse();\n  };\n\n  /**\n   * Returns the first element in this sequence with property names and values\n   * matching those of the specified object.\n   *\n   * @public\n   * @param {Object} properties The properties that should be found on some\n   *     element in this sequence.\n   * @returns {*} The found element, or `undefined` if none exists in this\n   *     sequence.\n   *\n   * @examples\n   * var words = [\"foo\", \"bar\"];\n   *\n   * Lazy(words).findWhere({ 0: \"f\" }); // => \"foo\"\n   * Lazy(words).findWhere({ 0: \"z\" }); // => undefined\n   */\n  Sequence.prototype.findWhere = function findWhere(properties) {\n    return this.where(properties).first();\n  };\n\n  /**\n   * Creates a new sequence comprising all but the first N elements of this\n   * sequence.\n   *\n   * @public\n   * @aka skip, tail, rest\n   * @param {number=} count The number of items to omit from the beginning of the\n   *     sequence (defaults to 1).\n   * @returns {Sequence} The new sequence.\n   *\n   * @examples\n   * Lazy([1, 2, 3, 4]).rest()  // sequence: [2, 3, 4]\n   * Lazy([1, 2, 3, 4]).rest(0) // sequence: [1, 2, 3, 4]\n   * Lazy([1, 2, 3, 4]).rest(2) // sequence: [3, 4]\n   * Lazy([1, 2, 3, 4]).rest(5) // sequence: []\n   */\n  Sequence.prototype.rest = function rest(count) {\n    return new DropSequence(this, count);\n  };\n\n  Sequence.prototype.skip =\n  Sequence.prototype.tail =\n  Sequence.prototype.drop = function drop(count) {\n    return this.rest(count);\n  };\n\n  /**\n   * @constructor\n   */\n  function DropSequence(parent, count) {\n    this.parent = parent;\n    this.count  = typeof count === \"number\" ? count : 1;\n  }\n\n  DropSequence.prototype = new Sequence();\n\n  DropSequence.prototype.each = function each(fn) {\n    var count   = this.count,\n        dropped = 0,\n        i       = 0;\n\n    return this.parent.each(function(e) {\n      if (dropped++ < count) { return; }\n      return fn(e, i++);\n    });\n  };\n\n  /**\n   * Creates a new sequence comprising the elements from this sequence *after*\n   * those that satisfy some predicate. The sequence starts with the first\n   * element that does not match the predicate.\n   *\n   * @public\n   * @aka skipWhile\n   * @param {Function} predicate\n   * @returns {Sequence} The new sequence\n   */\n  Sequence.prototype.dropWhile = function dropWhile(predicate) {\n    return new DropWhileSequence(this, predicate);\n  };\n\n  Sequence.prototype.skipWhile = function skipWhile(predicate) {\n    return this.dropWhile(predicate);\n  };\n\n  /**\n   * @constructor\n   */\n  function DropWhileSequence(parent, predicate) {\n    this.parent    = parent;\n    this.predicate = predicate;\n  }\n\n  DropWhileSequence.prototype = new Sequence();\n\n  DropWhileSequence.prototype.each = function each(fn) {\n    var predicate = this.predicate,\n        done      = false;\n\n    return this.parent.each(function(e) {\n      if (!done) {\n        if (predicate(e)) {\n          return;\n        }\n\n        done = true;\n      }\n\n      return fn(e);\n    });\n  };\n\n  /**\n   * Creates a new sequence with the same elements as this one, but ordered\n   * using the specified comparison function.\n   *\n   * This has essentially the same behavior as calling\n   * [`Array#sort`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort),\n   * but obviously instead of modifying the collection it returns a new\n   * {@link Sequence} object.\n   *\n   * @public\n   * @param {Function=} sortFn The function used to compare elements in the\n   *     sequence. The function will be passed two elements and should return:\n   *     - 1 if the first is greater\n   *     - -1 if the second is greater\n   *     - 0 if the two values are the same\n   * @param {boolean} descending Whether or not the resulting sequence should be\n   *     in descending order (defaults to `false`).\n   * @returns {Sequence} The new sequence.\n   *\n   * @examples\n   * Lazy([5, 10, 1]).sort()                // sequence: [1, 5, 10]\n   * Lazy(['foo', 'bar']).sort()            // sequence: ['bar', 'foo']\n   * Lazy(['b', 'c', 'a']).sort(null, true) // sequence: ['c', 'b', 'a']\n   * Lazy([5, 10, 1]).sort(null, true)      // sequence: [10, 5, 1]\n   *\n   * // Sorting w/ custom comparison function\n   * Lazy(['a', 'ab', 'aa', 'ba', 'b', 'abc']).sort(function compare(x, y) {\n   *   if (x.length && (x.length !== y.length)) { return compare(x.length, y.length); }\n   *   if (x === y) { return 0; }\n   *   return x > y ? 1 : -1;\n   * });\n   * // => sequence: ['a', 'b', 'aa', 'ab', 'ba', 'abc']\n   */\n  Sequence.prototype.sort = function sort(sortFn, descending) {\n    sortFn || (sortFn = compare);\n    if (descending) { sortFn = reverseArguments(sortFn); }\n    return new SortedSequence(this, sortFn);\n  };\n\n  /**\n   * Creates a new sequence with the same elements as this one, but ordered by\n   * the results of the given function.\n   *\n   * You can pass:\n   *\n   * - a *string*, to sort by the named property\n   * - a function, to sort by the result of calling the function on each element\n   *\n   * @public\n   * @param {Function} sortFn The function to call on the elements in this\n   *     sequence, in order to sort them.\n   * @param {boolean} descending Whether or not the resulting sequence should be\n   *     in descending order (defaults to `false`).\n   * @returns {Sequence} The new sequence.\n   *\n   * @examples\n   * function population(country) {\n   *   return country.pop;\n   * }\n   *\n   * function area(country) {\n   *   return country.sqkm;\n   * }\n   *\n   * var countries = [\n   *   { name: \"USA\", pop: 320000000, sqkm: 9600000 },\n   *   { name: \"Brazil\", pop: 194000000, sqkm: 8500000 },\n   *   { name: \"Nigeria\", pop: 174000000, sqkm: 924000 },\n   *   { name: \"China\", pop: 1350000000, sqkm: 9700000 },\n   *   { name: \"Russia\", pop: 143000000, sqkm: 17000000 },\n   *   { name: \"Australia\", pop: 23000000, sqkm: 7700000 }\n   * ];\n   *\n   * Lazy(countries).sortBy(population).last(3).pluck('name') // sequence: [\"Brazil\", \"USA\", \"China\"]\n   * Lazy(countries).sortBy(area).last(3).pluck('name')       // sequence: [\"USA\", \"China\", \"Russia\"]\n   * Lazy(countries).sortBy(area, true).first(3).pluck('name') // sequence: [\"Russia\", \"China\", \"USA\"]\n   *\n   * @benchmarks\n   * var randoms = Lazy.generate(Math.random).take(100).toArray();\n   *\n   * Lazy(randoms).sortBy(Lazy.identity).each(Lazy.noop) // lazy\n   * _.each(_.sortBy(randoms, Lazy.identity), _.noop)    // lodash\n   */\n  Sequence.prototype.sortBy = function sortBy(sortFn, descending) {\n    sortFn = createComparator(sortFn);\n    if (descending) { sortFn = reverseArguments(sortFn); }\n    return new SortedSequence(this, sortFn);\n  };\n\n  /**\n   * @constructor\n   */\n  function SortedSequence(parent, sortFn) {\n    this.parent = parent;\n    this.sortFn = sortFn;\n  }\n\n  SortedSequence.prototype = new Sequence();\n\n  SortedSequence.prototype.each = function each(fn) {\n    var sortFn = this.sortFn,\n        result = this.parent.toArray();\n\n    result.sort(sortFn);\n\n    return forEach(result, fn);\n  };\n\n  /**\n   * @examples\n   * var items = [{ a: 4 }, { a: 3 }, { a: 5 }];\n   *\n   * Lazy(items).sortBy('a').reverse();\n   * // => sequence: [{ a: 5 }, { a: 4 }, { a: 3 }]\n   *\n   * Lazy(items).sortBy('a').reverse().reverse();\n   * // => sequence: [{ a: 3 }, { a: 4 }, { a: 5 }]\n   */\n  SortedSequence.prototype.reverse = function reverse() {\n    return new SortedSequence(this.parent, reverseArguments(this.sortFn));\n  };\n\n  /**\n   * Creates a new {@link ObjectLikeSequence} comprising the elements in this\n   * one, grouped together according to some key. The value associated with each\n   * key in the resulting object-like sequence is an array containing all of\n   * the elements in this sequence with that key.\n   *\n   * @public\n   * @param {Function|string} keyFn The function to call on the elements in this\n   *     sequence to obtain a key by which to group them, or a string representing\n   *     a parameter to read from all the elements in this sequence.\n   * @param {Function|string} valFn (Optional) The function to call on the elements\n   *     in this sequence to assign to the value for each instance to appear in the\n   *     group, or a string representing a parameter to read from all the elements\n   *     in this sequence.\n   * @returns {ObjectLikeSequence} The new sequence.\n   *\n   * @examples\n   * function oddOrEven(x) {\n   *   return x % 2 === 0 ? 'even' : 'odd';\n   * }\n   * function square(x) {\n   *   return x*x;\n   * }\n   *\n   * var numbers = [1, 2, 3, 4, 5];\n   *\n   * Lazy(numbers).groupBy(oddOrEven)                     // sequence: { odd: [1, 3, 5], even: [2, 4] }\n   * Lazy(numbers).groupBy(oddOrEven).get(\"odd\")          // => [1, 3, 5]\n   * Lazy(numbers).groupBy(oddOrEven).get(\"foo\")          // => undefined\n   * Lazy(numbers).groupBy(oddOrEven, square).get(\"even\") // => [4, 16]\n   *\n   * Lazy([\n   *   { name: 'toString' },\n   *   { name: 'toString' }\n   * ]).groupBy('name');\n   * // => sequence: {\n   *   'toString': [\n   *     { name: 'toString' },\n   *     { name: 'toString' }\n   *   ]\n   * }\n   */\n  Sequence.prototype.groupBy = function groupBy(keyFn, valFn) {\n    return new GroupedSequence(this, keyFn, valFn);\n  };\n\n  /**\n   * @constructor\n   */\n  function GroupedSequence(parent, keyFn, valFn) {\n    this.parent = parent;\n    this.keyFn  = keyFn;\n    this.valFn  = valFn;\n  }\n\n  // GroupedSequence must have its prototype set after ObjectLikeSequence has\n  // been fully initialized.\n\n  /**\n   * Creates a new {@link ObjectLikeSequence} comprising the elements in this\n   * one, indexed according to some key.\n   *\n   * @public\n   * @param {Function|string} keyFn The function to call on the elements in this\n   *     sequence to obtain a key by which to index them, or a string\n   *     representing a property to read from all the elements in this sequence.\n   * @param {Function|string} valFn (Optional) The function to call on the elements\n   *     in this sequence to assign to the value of the indexed object, or a string\n   *     representing a parameter to read from all the elements in this sequence.\n   * @returns {Sequence} The new sequence.\n   *\n   * @examples\n   * var people = [\n   *   { name: 'Bob', age: 25 },\n   *   { name: 'Fred', age: 34 }\n   * ];\n   *\n   * var bob  = people[0],\n   *     fred = people[1];\n   *\n   * Lazy(people).indexBy('name')        // sequence: { 'Bob': bob, 'Fred': fred }\n   * Lazy(people).indexBy('name', 'age') // sequence: { 'Bob': 25, 'Fred': 34 }\n   */\n  Sequence.prototype.indexBy = function(keyFn, valFn) {\n    return new IndexedSequence(this, keyFn, valFn);\n  };\n\n  /**\n   * @constructor\n   */\n  function IndexedSequence(parent, keyFn, valFn) {\n    this.parent = parent;\n    this.keyFn  = keyFn;\n    this.valFn  = valFn;\n  }\n\n  // IndexedSequence must have its prototype set after ObjectLikeSequence has\n  // been fully initialized.\n\n  /**\n   * Creates a new {@link ObjectLikeSequence} containing the unique keys of all\n   * the elements in this sequence, each paired with the number of elements\n   * in this sequence having that key.\n   *\n   * @public\n   * @param {Function|string} keyFn The function to call on the elements in this\n   *     sequence to obtain a key by which to count them, or a string representing\n   *     a parameter to read from all the elements in this sequence.\n   * @returns {Sequence} The new sequence.\n   *\n   * @examples\n   * function oddOrEven(x) {\n   *   return x % 2 === 0 ? 'even' : 'odd';\n   * }\n   *\n   * var numbers = [1, 2, 3, 4, 5];\n   *\n   * Lazy(numbers).countBy(oddOrEven)            // sequence: { odd: 3, even: 2 }\n   * Lazy(numbers).countBy(oddOrEven).get(\"odd\") // => 3\n   * Lazy(numbers).countBy(oddOrEven).get(\"foo\") // => undefined\n   */\n  Sequence.prototype.countBy = function countBy(keyFn) {\n    return new CountedSequence(this, keyFn);\n  };\n\n  /**\n   * @constructor\n   */\n  function CountedSequence(parent, keyFn) {\n    this.parent = parent;\n    this.keyFn  = keyFn;\n  }\n\n  // CountedSequence, like GroupedSequence, must have its prototype set after\n  // ObjectLikeSequence has been fully initialized.\n\n  /**\n   * Creates a new sequence with every unique element from this one appearing\n   * exactly once (i.e., with duplicates removed).\n   *\n   * @public\n   * @aka unique\n   * @param {Function} keyFn An optional function to produce the key for each\n   *     object. This key is then tested for uniqueness as  opposed to the\n   *     object reference.\n   * @returns {Sequence} The new sequence.\n   *\n   * @examples\n   * Lazy([1, 2, 2, 3, 3, 3]).uniq() // sequence: [1, 2, 3]\n   * Lazy([{ name: 'mike' },\n   * \t{ name: 'sarah' },\n   * \t{ name: 'mike' }\n   * ]).uniq('name')\n   * // sequence: [{ name: 'mike' }, { name: 'sarah' }]\n   *\n   * @benchmarks\n   * function randomOf(array) {\n   *   return function() {\n   *     return array[Math.floor(Math.random() * array.length)];\n   *   };\n   * }\n   *\n   * var mostUnique = Lazy.generate(randomOf(_.range(100)), 100).toArray(),\n   *     someUnique = Lazy.generate(randomOf(_.range(50)), 100).toArray(),\n   *     mostDupes  = Lazy.generate(randomOf(_.range(5)), 100).toArray();\n   *\n   * Lazy(mostUnique).uniq().each(Lazy.noop) // lazy - mostly unique elements\n   * Lazy(someUnique).uniq().each(Lazy.noop) // lazy - some unique elements\n   * Lazy(mostDupes).uniq().each(Lazy.noop)  // lazy - mostly duplicate elements\n   * _.each(_.uniq(mostUnique), _.noop)      // lodash - mostly unique elements\n   * _.each(_.uniq(someUnique), _.noop)      // lodash - some unique elements\n   * _.each(_.uniq(mostDupes), _.noop)       // lodash - mostly duplicate elements\n   */\n  Sequence.prototype.uniq = function uniq(keyFn) {\n    return new UniqueSequence(this, keyFn);\n  };\n\n  Sequence.prototype.unique = function unique(keyFn) {\n    return this.uniq(keyFn);\n  };\n\n  /**\n   * @constructor\n   */\n  function UniqueSequence(parent, keyFn) {\n    this.parent = parent;\n    this.keyFn  = keyFn;\n  }\n\n  UniqueSequence.prototype = new Sequence();\n\n  UniqueSequence.prototype.each = function each(fn) {\n    var cache = new Set(),\n        keyFn = this.keyFn,\n        i     = 0;\n\n    if (keyFn) {\n      keyFn = createCallback(keyFn);\n      return this.parent.each(function(e) {\n        if (cache.add(keyFn(e))) {\n          return fn(e, i++);\n        }\n      });\n\n    } else {\n      return this.parent.each(function(e) {\n        if (cache.add(e)) {\n          return fn(e, i++);\n        }\n      });\n    }\n  };\n\n  /**\n   * Creates a new sequence by combining the elements from this sequence with\n   * corresponding elements from the specified array(s).\n   *\n   * @public\n   * @param {...Array} var_args One or more arrays of elements to combine with\n   *     those of this sequence.\n   * @returns {Sequence} The new sequence.\n   *\n   * @examples\n   * Lazy([1, 2]).zip([3, 4]) // sequence: [[1, 3], [2, 4]]\n   *\n   * @benchmarks\n   * var smArrL = Lazy.range(10).toArray(),\n   *     smArrR = Lazy.range(10, 20).toArray(),\n   *     lgArrL = Lazy.range(100).toArray(),\n   *     lgArrR = Lazy.range(100, 200).toArray();\n   *\n   * Lazy(smArrL).zip(smArrR).each(Lazy.noop) // lazy - zipping 10-element arrays\n   * Lazy(lgArrL).zip(lgArrR).each(Lazy.noop) // lazy - zipping 100-element arrays\n   * _.each(_.zip(smArrL, smArrR), _.noop)    // lodash - zipping 10-element arrays\n   * _.each(_.zip(lgArrL, lgArrR), _.noop)    // lodash - zipping 100-element arrays\n   */\n  Sequence.prototype.zip = function zip(var_args) {\n    if (arguments.length === 1) {\n      return new SimpleZippedSequence(this, (/** @type {Array} */ var_args));\n    } else {\n      return new ZippedSequence(this, arraySlice.call(arguments, 0));\n    }\n  };\n\n  /**\n   * @constructor\n   */\n  function ZippedSequence(parent, arrays) {\n    this.parent = parent;\n    this.arrays = arrays;\n  }\n\n  ZippedSequence.prototype = new Sequence();\n\n  ZippedSequence.prototype.each = function each(fn) {\n    var arrays = this.arrays,\n        i = 0;\n    this.parent.each(function(e) {\n      var group = [e];\n      for (var j = 0; j < arrays.length; ++j) {\n        if (arrays[j].length > i) {\n          group.push(arrays[j][i]);\n        }\n      }\n      return fn(group, i++);\n    });\n  };\n\n  /**\n   * Creates a new sequence with the same elements as this one, in a randomized\n   * order.\n   *\n   * @public\n   * @returns {Sequence} The new sequence.\n   *\n   * @examples\n   * Lazy([1, 2, 3, 4, 5]).shuffle().value() // =~ [1, 2, 3, 4, 5]\n   */\n  Sequence.prototype.shuffle = function shuffle() {\n    return new ShuffledSequence(this);\n  };\n\n  /**\n   * @constructor\n   */\n  function ShuffledSequence(parent) {\n    this.parent = parent;\n  }\n\n  ShuffledSequence.prototype = new Sequence();\n\n  ShuffledSequence.prototype.each = function each(fn) {\n    var shuffled = this.parent.toArray(),\n        floor = Math.floor,\n        random = Math.random,\n        j = 0;\n\n    for (var i = shuffled.length - 1; i > 0; --i) {\n      swap(shuffled, i, floor(random() * (i + 1)));\n      if (fn(shuffled[i], j++) === false) {\n        return;\n      }\n    }\n    fn(shuffled[0], j);\n  };\n\n  /**\n   * Creates a new sequence with every element from this sequence, and with arrays\n   * exploded so that a sequence of arrays (of arrays) becomes a flat sequence of\n   * values.\n   *\n   * @public\n   * @returns {Sequence} The new sequence.\n   *\n   * @examples\n   * Lazy([1, [2, 3], [4, [5]]]).flatten() // sequence: [1, 2, 3, 4, 5]\n   * Lazy([1, Lazy([2, 3])]).flatten()     // sequence: [1, 2, 3]\n   */\n  Sequence.prototype.flatten = function flatten() {\n    return new FlattenedSequence(this);\n  };\n\n  /**\n   * @constructor\n   */\n  function FlattenedSequence(parent) {\n    this.parent = parent;\n  }\n\n  FlattenedSequence.prototype = new Sequence();\n\n  FlattenedSequence.prototype.each = function each(fn) {\n    var index = 0;\n\n    return this.parent.each(function recurseVisitor(e) {\n      if (e instanceof Array) {\n        return forEach(e, recurseVisitor);\n      }\n\n      if (e instanceof Sequence) {\n        return e.each(recurseVisitor);\n      }\n\n      return fn(e, index++);\n    });\n  };\n\n  /**\n   * Creates a new sequence with the same elements as this one, except for all\n   * falsy values (`false`, `0`, `\"\"`, `null`, and `undefined`).\n   *\n   * @public\n   * @returns {Sequence} The new sequence.\n   *\n   * @examples\n   * Lazy([\"foo\", null, \"bar\", undefined]).compact() // sequence: [\"foo\", \"bar\"]\n   */\n  Sequence.prototype.compact = function compact() {\n    return this.filter(function(e) { return !!e; });\n  };\n\n  /**\n   * Creates a new sequence with all the elements of this sequence that are not\n   * also among the specified arguments.\n   *\n   * @public\n   * @aka difference\n   * @param {...*} var_args The values, or array(s) of values, to be excluded from the\n   *     resulting sequence.\n   * @returns {Sequence} The new sequence.\n   *\n   * @examples\n   * Lazy([1, 2, 3, 4, 5]).without(2, 3)   // sequence: [1, 4, 5]\n   * Lazy([1, 2, 3, 4, 5]).without([4, 5]) // sequence: [1, 2, 3]\n   */\n  Sequence.prototype.without = function without(var_args) {\n    return new WithoutSequence(this, arraySlice.call(arguments, 0));\n  };\n\n  Sequence.prototype.difference = function difference(var_args) {\n    return this.without.apply(this, arguments);\n  };\n\n  /**\n   * @constructor\n   */\n  function WithoutSequence(parent, values) {\n    this.parent = parent;\n    this.values = values;\n  }\n\n  WithoutSequence.prototype = new Sequence();\n\n  WithoutSequence.prototype.each = function each(fn) {\n    var set = createSet(this.values),\n        i = 0;\n    return this.parent.each(function(e) {\n      if (!set.contains(e)) {\n        return fn(e, i++);\n      }\n    });\n  };\n\n  /**\n   * Creates a new sequence with all the unique elements either in this sequence\n   * or among the specified arguments.\n   *\n   * @public\n   * @param {...*} var_args The values, or array(s) of values, to be additionally\n   *     included in the resulting sequence.\n   * @returns {Sequence} The new sequence.\n   *\n   * @examples\n   * Lazy([\"foo\", \"bar\"]).union([])             // sequence: [\"foo\", \"bar\"]\n   * Lazy([\"foo\", \"bar\"]).union([\"bar\", \"baz\"]) // sequence: [\"foo\", \"bar\", \"baz\"]\n   */\n  Sequence.prototype.union = function union(var_args) {\n    return this.concat(var_args).uniq();\n  };\n\n  /**\n   * Creates a new sequence with all the elements of this sequence that also\n   * appear among the specified arguments.\n   *\n   * @public\n   * @param {...*} var_args The values, or array(s) of values, in which elements\n   *     from this sequence must also be included to end up in the resulting sequence.\n   * @returns {Sequence} The new sequence.\n   *\n   * @examples\n   * Lazy([\"foo\", \"bar\"]).intersection([])             // sequence: []\n   * Lazy([\"foo\", \"bar\"]).intersection([\"bar\", \"baz\"]) // sequence: [\"bar\"]\n   */\n  Sequence.prototype.intersection = function intersection(var_args) {\n    if (arguments.length === 1 && arguments[0] instanceof Array) {\n      return new SimpleIntersectionSequence(this, (/** @type {Array} */ var_args));\n    } else {\n      return new IntersectionSequence(this, arraySlice.call(arguments, 0));\n    }\n  };\n\n  /**\n   * @constructor\n   */\n  function IntersectionSequence(parent, arrays) {\n    this.parent = parent;\n    this.arrays = arrays;\n  }\n\n  IntersectionSequence.prototype = new Sequence();\n\n  IntersectionSequence.prototype.each = function each(fn) {\n    var sets = Lazy(this.arrays).map(function(values) {\n      return new UniqueMemoizer(Lazy(values).getIterator());\n    });\n\n    var setIterator = new UniqueMemoizer(sets.getIterator()),\n        i = 0;\n\n    return this.parent.each(function(e) {\n      var includedInAll = true;\n      setIterator.each(function(set) {\n        if (!set.contains(e)) {\n          includedInAll = false;\n          return false;\n        }\n      });\n\n      if (includedInAll) {\n        return fn(e, i++);\n      }\n    });\n  };\n\n  /**\n   * @constructor\n   */\n  function UniqueMemoizer(iterator) {\n    this.iterator     = iterator;\n    this.set          = new Set();\n    this.memo         = [];\n    this.currentValue = undefined;\n  }\n\n  UniqueMemoizer.prototype.current = function current() {\n    return this.currentValue;\n  };\n\n  UniqueMemoizer.prototype.moveNext = function moveNext() {\n    var iterator = this.iterator,\n        set = this.set,\n        memo = this.memo,\n        current;\n\n    while (iterator.moveNext()) {\n      current = iterator.current();\n      if (set.add(current)) {\n        memo.push(current);\n        this.currentValue = current;\n        return true;\n      }\n    }\n    return false;\n  };\n\n  UniqueMemoizer.prototype.each = function each(fn) {\n    var memo = this.memo,\n        length = memo.length,\n        i = -1;\n\n    while (++i < length) {\n      if (fn(memo[i], i) === false) {\n        return false;\n      }\n    }\n\n    while (this.moveNext()) {\n      if (fn(this.currentValue, i++) === false) {\n        break;\n      }\n    }\n  };\n\n  UniqueMemoizer.prototype.contains = function contains(e) {\n    if (this.set.contains(e)) {\n      return true;\n    }\n\n    while (this.moveNext()) {\n      if (this.currentValue === e) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  /**\n   * Checks whether every element in this sequence satisfies a given predicate.\n   *\n   * @public\n   * @aka all\n   * @param {Function} predicate A function to call on (potentially) every element\n   *     in this sequence.\n   * @returns {boolean} True if `predicate` returns true for every element in the\n   *     sequence (or the sequence is empty). False if `predicate` returns false\n   *     for at least one element.\n   *\n   * @examples\n   * var numbers = [1, 2, 3, 4, 5];\n   *\n   * var objects = [{ foo: true }, { foo: false, bar: true }];\n   *\n   * Lazy(numbers).every(isEven)     // => false\n   * Lazy(numbers).every(isPositive) // => true\n   * Lazy(objects).all('foo')        // => false\n   * Lazy(objects).all('bar')        // => false\n   */\n  Sequence.prototype.every = function every(predicate) {\n    predicate = createCallback(predicate);\n\n    return this.each(function(e, i) {\n      return !!predicate(e, i);\n    });\n  };\n\n  Sequence.prototype.all = function all(predicate) {\n    return this.every(predicate);\n  };\n\n  /**\n   * Checks whether at least one element in this sequence satisfies a given\n   * predicate (or, if no predicate is specified, whether the sequence contains at\n   * least one element).\n   *\n   * @public\n   * @aka any\n   * @param {Function=} predicate A function to call on (potentially) every element\n   *     in this sequence.\n   * @returns {boolean} True if `predicate` returns true for at least one element\n   *     in the sequence. False if `predicate` returns false for every element (or\n   *     the sequence is empty).\n   *\n   * @examples\n   * var numbers = [1, 2, 3, 4, 5];\n   *\n   * Lazy(numbers).some()           // => true\n   * Lazy(numbers).some(isEven)     // => true\n   * Lazy(numbers).some(isNegative) // => false\n   * Lazy([]).some()                // => false\n   */\n  Sequence.prototype.some = function some(predicate) {\n    predicate = createCallback(predicate, true);\n\n    var success = false;\n    this.each(function(e) {\n      if (predicate(e)) {\n        success = true;\n        return false;\n      }\n    });\n    return success;\n  };\n\n  Sequence.prototype.any = function any(predicate) {\n    return this.some(predicate);\n  };\n\n  /**\n   * Checks whether NO elements in this sequence satisfy the given predicate\n   * (the opposite of {@link Sequence#all}, basically).\n   *\n   * @public\n   * @param {Function=} predicate A function to call on (potentially) every element\n   *     in this sequence.\n   * @returns {boolean} True if `predicate` does not return true for any element\n   *     in the sequence. False if `predicate` returns true for at least one\n   *     element.\n   *\n   * @examples\n   * var numbers = [1, 2, 3, 4, 5];\n   *\n   * Lazy(numbers).none()           // => false\n   * Lazy(numbers).none(isEven)     // => false\n   * Lazy(numbers).none(isNegative) // => true\n   * Lazy([]).none(isEven)          // => true\n   * Lazy([]).none(isNegative)      // => true\n   * Lazy([]).none()                // => true\n   */\n  Sequence.prototype.none = function none(predicate) {\n    return !this.any(predicate);\n  };\n\n  /**\n   * Checks whether the sequence has no elements.\n   *\n   * @public\n   * @returns {boolean} True if the sequence is empty, false if it contains at\n   *     least one element.\n   *\n   * @examples\n   * Lazy([]).isEmpty()        // => true\n   * Lazy([1, 2, 3]).isEmpty() // => false\n   */\n  Sequence.prototype.isEmpty = function isEmpty() {\n    return !this.any();\n  };\n\n  /**\n   * Performs (at worst) a linear search from the head of this sequence,\n   * returning the first index at which the specified value is found.\n   *\n   * @public\n   * @param {*} value The element to search for in the sequence.\n   * @returns {number} The index within this sequence where the given value is\n   *     located, or -1 if the sequence doesn't contain the value.\n   *\n   * @examples\n   * function reciprocal(x) { return 1 / x; }\n   *\n   * Lazy([\"foo\", \"bar\", \"baz\"]).indexOf(\"bar\")   // => 1\n   * Lazy([1, 2, 3]).indexOf(4)                   // => -1\n   * Lazy([1, 2, 3]).map(reciprocal).indexOf(0.5) // => 1\n   */\n  Sequence.prototype.indexOf = function indexOf(value) {\n    var foundIndex = -1;\n    this.each(function(e, i) {\n      if (e === value) {\n        foundIndex = i;\n        return false;\n      }\n    });\n    return foundIndex;\n  };\n\n  /**\n   * Performs (at worst) a linear search from the tail of this sequence,\n   * returning the last index at which the specified value is found.\n   *\n   * @public\n   * @param {*} value The element to search for in the sequence.\n   * @returns {number} The last index within this sequence where the given value\n   *     is located, or -1 if the sequence doesn't contain the value.\n   *\n   * @examples\n   * Lazy([\"a\", \"b\", \"c\", \"b\", \"a\"]).lastIndexOf(\"b\")    // => 3\n   * Lazy([1, 2, 3]).lastIndexOf(0)                      // => -1\n   * Lazy([2, 2, 1, 2, 4]).filter(isEven).lastIndexOf(2) // 2\n   */\n  Sequence.prototype.lastIndexOf = function lastIndexOf(value) {\n    var reversed = this.getIndex().reverse(),\n        index    = reversed.indexOf(value);\n    if (index !== -1) {\n      index = reversed.length() - index - 1;\n    }\n    return index;\n  };\n\n  /**\n   * Performs a binary search of this sequence, returning the lowest index where\n   * the given value is either found, or where it belongs (if it is not already\n   * in the sequence).\n   *\n   * This method assumes the sequence is in sorted order and will fail otherwise.\n   *\n   * @public\n   * @param {*} value The element to search for in the sequence.\n   * @returns {number} An index within this sequence where the given value is\n   *     located, or where it belongs in sorted order.\n   *\n   * @examples\n   * Lazy([1, 3, 6, 9]).sortedIndex(3)                    // => 1\n   * Lazy([1, 3, 6, 9]).sortedIndex(7)                    // => 3\n   * Lazy([5, 10, 15, 20]).filter(isEven).sortedIndex(10) // => 0\n   * Lazy([5, 10, 15, 20]).filter(isEven).sortedIndex(12) // => 1\n   */\n  Sequence.prototype.sortedIndex = function sortedIndex(value) {\n    var indexed = this.getIndex(),\n        lower   = 0,\n        upper   = indexed.length(),\n        i;\n\n    while (lower < upper) {\n      i = (lower + upper) >>> 1;\n      if (compare(indexed.get(i), value) === -1) {\n        lower = i + 1;\n      } else {\n        upper = i;\n      }\n    }\n    return lower;\n  };\n\n  /**\n   * Checks whether the given value is in this sequence.\n   *\n   * @public\n   * @param {*} value The element to search for in the sequence.\n   * @returns {boolean} True if the sequence contains the value, false if not.\n   *\n   * @examples\n   * var numbers = [5, 10, 15, 20];\n   *\n   * Lazy(numbers).contains(15) // => true\n   * Lazy(numbers).contains(13) // => false\n   */\n  Sequence.prototype.contains = function contains(value) {\n    return this.indexOf(value) !== -1;\n  };\n\n  /**\n   * Aggregates a sequence into a single value according to some accumulator\n   * function.\n   *\n   * For an asynchronous sequence, instead of immediately returning a result\n   * (which it can't, obviously), this method returns an {@link AsyncHandle}\n   * whose `onComplete` method can be called to supply a callback to handle the\n   * final result once iteration has completed.\n   *\n   * @public\n   * @aka inject, foldl\n   * @param {Function} aggregator The function through which to pass every element\n   *     in the sequence. For every element, the function will be passed the total\n   *     aggregated result thus far and the element itself, and should return a\n   *     new aggregated result.\n   * @param {*=} memo The starting value to use for the aggregated result\n   *     (defaults to the first element in the sequence).\n   * @returns {*} The result of the aggregation, or, for asynchronous sequences,\n   *     an {@link AsyncHandle} whose `onComplete` method accepts a callback to\n   *     handle the final result.\n   *\n   * @examples\n   * function multiply(x, y) { return x * y; }\n   *\n   * var numbers = [1, 2, 3, 4];\n   *\n   * Lazy(numbers).reduce(multiply)    // => 24\n   * Lazy(numbers).reduce(multiply, 5) // => 120\n   */\n  Sequence.prototype.reduce = function reduce(aggregator, memo) {\n    if (arguments.length < 2) {\n      return this.tail().reduce(aggregator, this.head());\n    }\n\n    var eachResult = this.each(function(e, i) {\n      memo = aggregator(memo, e, i);\n    });\n\n    // TODO: Think of a way more efficient solution to this problem.\n    if (eachResult instanceof AsyncHandle) {\n      return eachResult.then(function() { return memo; });\n    }\n\n    return memo;\n  };\n\n  Sequence.prototype.inject =\n  Sequence.prototype.foldl = function foldl(aggregator, memo) {\n    return this.reduce(aggregator, memo);\n  };\n\n  /**\n   * Aggregates a sequence, from the tail, into a single value according to some\n   * accumulator function.\n   *\n   * @public\n   * @aka foldr\n   * @param {Function} aggregator The function through which to pass every element\n   *     in the sequence. For every element, the function will be passed the total\n   *     aggregated result thus far and the element itself, and should return a\n   *     new aggregated result.\n   * @param {*} memo The starting value to use for the aggregated result.\n   * @returns {*} The result of the aggregation.\n   *\n   * @examples\n   * function append(s1, s2) {\n   *   return s1 + s2;\n   * }\n   *\n   * function isVowel(str) {\n   *   return \"aeiou\".indexOf(str) !== -1;\n   * }\n   *\n   * Lazy(\"abcde\").reduceRight(append)                 // => \"edcba\"\n   * Lazy(\"abcde\").filter(isVowel).reduceRight(append) // => \"ea\"\n   */\n  Sequence.prototype.reduceRight = function reduceRight(aggregator, memo) {\n    if (arguments.length < 2) {\n      return this.initial(1).reduceRight(aggregator, this.last());\n    }\n\n    // This bothers me... but frankly, calling reverse().reduce() is potentially\n    // going to eagerly evaluate the sequence anyway; so it's really not an issue.\n    var indexed = this.getIndex(),\n        i = indexed.length() - 1;\n    return indexed.reverse().reduce(function(m, e) {\n      return aggregator(m, e, i--);\n    }, memo);\n  };\n\n  Sequence.prototype.foldr = function foldr(aggregator, memo) {\n    return this.reduceRight(aggregator, memo);\n  };\n\n  /**\n   * Groups this sequence into consecutive (overlapping) segments of a specified\n   * length. If the underlying sequence has fewer elements than the specified\n   * length, then this sequence will be empty.\n   *\n   * @public\n   * @param {number} length The length of each consecutive segment.\n   * @returns {Sequence} The resulting sequence of consecutive segments.\n   *\n   * @examples\n   * Lazy([]).consecutive(2)        // => sequence: []\n   * Lazy([1]).consecutive(2)       // => sequence: []\n   * Lazy([1, 2]).consecutive(2)    // => sequence: [[1, 2]]\n   * Lazy([1, 2, 3]).consecutive(2) // => sequence: [[1, 2], [2, 3]]\n   * Lazy([1, 2, 3]).consecutive(0) // => sequence: [[]]\n   * Lazy([1, 2, 3]).consecutive(1) // => sequence: [[1], [2], [3]]\n   */\n  Sequence.prototype.consecutive = function consecutive(count) {\n    var queue    = new Queue(count);\n    var segments = this.map(function(element) {\n      if (queue.add(element).count === count) {\n        return queue.toArray();\n      }\n    });\n    return segments.compact();\n  };\n\n  /**\n   * Breaks this sequence into chunks (arrays) of a specified length.\n   *\n   * @public\n   * @param {number} size The size of each chunk.\n   * @returns {Sequence} The resulting sequence of chunks.\n   *\n   * @examples\n   * Lazy([]).chunk(2)        // sequence: []\n   * Lazy([1, 2, 3]).chunk(2) // sequence: [[1, 2], [3]]\n   * Lazy([1, 2, 3]).chunk(1) // sequence: [[1], [2], [3]]\n   * Lazy([1, 2, 3]).chunk(4) // sequence: [[1, 2, 3]]\n   * Lazy([1, 2, 3]).chunk(0) // throws\n   */\n  Sequence.prototype.chunk = function chunk(size) {\n    if (size < 1) {\n      throw new Error(\"You must specify a positive chunk size.\");\n    }\n\n    return new ChunkedSequence(this, size);\n  };\n\n  /**\n   * @constructor\n   */\n  function ChunkedSequence(parent, size) {\n    this.parent    = parent;\n    this.chunkSize = size;\n  }\n\n  ChunkedSequence.prototype = new Sequence();\n\n  ChunkedSequence.prototype.getIterator = function getIterator() {\n    return new ChunkedIterator(this.parent, this.chunkSize);\n  };\n\n  /**\n   * @constructor\n   */\n  function ChunkedIterator(sequence, size) {\n    this.iterator = sequence.getIterator();\n    this.size     = size;\n  }\n\n  ChunkedIterator.prototype.current = function current() {\n    return this.currentChunk;\n  };\n\n  ChunkedIterator.prototype.moveNext = function moveNext() {\n    var iterator  = this.iterator,\n        chunkSize = this.size,\n        chunk     = [];\n\n    while (chunk.length < chunkSize && iterator.moveNext()) {\n      chunk.push(iterator.current());\n    }\n\n    if (chunk.length === 0) {\n      return false;\n    }\n\n    this.currentChunk = chunk;\n    return true;\n  };\n\n  /**\n   * Passes each element in the sequence to the specified callback during\n   * iteration. This is like {@link Sequence#each}, except that it can be\n   * inserted anywhere in the middle of a chain of methods to \"intercept\" the\n   * values in the sequence at that point.\n   *\n   * @public\n   * @param {Function} callback A function to call on every element in the\n   *     sequence during iteration. The return value of this function does not\n   *     matter.\n   * @returns {Sequence} A sequence comprising the same elements as this one.\n   *\n   * @examples\n   * Lazy([1, 2, 3]).tap(fn).each(Lazy.noop); // calls fn 3 times\n   */\n  Sequence.prototype.tap = function tap(callback) {\n    return new TappedSequence(this, callback);\n  };\n\n  /**\n   * @constructor\n   */\n  function TappedSequence(parent, callback) {\n    this.parent = parent;\n    this.callback = callback;\n  }\n\n  TappedSequence.prototype = new Sequence();\n\n  TappedSequence.prototype.each = function each(fn) {\n    var callback = this.callback;\n    return this.parent.each(function(e, i) {\n      callback(e, i);\n      return fn(e, i);\n    });\n  };\n\n  /**\n   * Seaches for the first element in the sequence satisfying a given predicate.\n   *\n   * @public\n   * @aka detect\n   * @param {Function} predicate A function to call on (potentially) every element\n   *     in the sequence.\n   * @returns {*} The first element in the sequence for which `predicate` returns\n   *     `true`, or `undefined` if no such element is found.\n   *\n   * @examples\n   * function divisibleBy3(x) {\n   *   return x % 3 === 0;\n   * }\n   *\n   * var numbers = [5, 6, 7, 8, 9, 10];\n   *\n   * Lazy(numbers).find(divisibleBy3) // => 6\n   * Lazy(numbers).find(isNegative)   // => undefined\n   */\n  Sequence.prototype.find = function find(predicate) {\n    return this.filter(predicate).first();\n  };\n\n  Sequence.prototype.detect = function detect(predicate) {\n    return this.find(predicate);\n  };\n\n  /**\n   * Gets the minimum value in the sequence.\n   *\n   * @public\n   * @param {Function=} valueFn The function by which the value for comparison is\n   *     calculated for each element in the sequence.\n   * @returns {*} The element with the lowest value in the sequence, or\n   *     `Infinity` if the sequence is empty.\n   *\n   * @examples\n   * function negate(x) { return x * -1; }\n   *\n   * Lazy([]).min()                       // => Infinity\n   * Lazy([6, 18, 2, 49, 34]).min()       // => 2\n   * Lazy([6, 18, 2, 49, 34]).min(negate) // => 49\n   */\n  Sequence.prototype.min = function min(valueFn) {\n    if (typeof valueFn !== \"undefined\") {\n      return this.minBy(valueFn);\n    }\n\n    return this.reduce(function(x, y) { return y < x ? y : x; }, Infinity);\n  };\n\n  Sequence.prototype.minBy = function minBy(valueFn) {\n    valueFn = createCallback(valueFn);\n    return this.reduce(function(x, y) { return valueFn(y) < valueFn(x) ? y : x; });\n  };\n\n  /**\n   * Gets the maximum value in the sequence.\n   *\n   * @public\n   * @param {Function=} valueFn The function by which the value for comparison is\n   *     calculated for each element in the sequence.\n   * @returns {*} The element with the highest value in the sequence, or\n   *     `-Infinity` if the sequence is empty.\n   *\n   * @examples\n   * function reverseDigits(x) {\n   *   return Number(String(x).split('').reverse().join(''));\n   * }\n   *\n   * Lazy([]).max()                              // => -Infinity\n   * Lazy([6, 18, 2, 48, 29]).max()              // => 48\n   * Lazy([6, 18, 2, 48, 29]).max(reverseDigits) // => 29\n   */\n  Sequence.prototype.max = function max(valueFn) {\n    if (typeof valueFn !== \"undefined\") {\n      return this.maxBy(valueFn);\n    }\n\n    return this.reduce(function(x, y) { return y > x ? y : x; }, -Infinity);\n  };\n\n  Sequence.prototype.maxBy = function maxBy(valueFn) {\n    valueFn = createCallback(valueFn);\n    return this.reduce(function(x, y) { return valueFn(y) > valueFn(x) ? y : x; });\n  };\n\n  /**\n   * Gets the sum of the values in the sequence.\n   *\n   * @public\n   * @param {Function=} valueFn The function used to select the values that will\n   *     be summed up.\n   * @returns {*} The sum.\n   *\n   * @examples\n   * Lazy([]).sum()                     // => 0\n   * Lazy([1, 2, 3, 4]).sum()           // => 10\n   * Lazy([1.2, 3.4]).sum(Math.floor)   // => 4\n   * Lazy(['foo', 'bar']).sum('length') // => 6\n   */\n  Sequence.prototype.sum = function sum(valueFn) {\n    if (typeof valueFn !== \"undefined\") {\n      return this.sumBy(valueFn);\n    }\n\n    return this.reduce(function(x, y) { return x + y; }, 0);\n  };\n\n  Sequence.prototype.sumBy = function sumBy(valueFn) {\n    valueFn = createCallback(valueFn);\n    return this.reduce(function(x, y) { return x + valueFn(y); }, 0);\n  };\n\n  /**\n   * Creates a string from joining together all of the elements in this sequence,\n   * separated by the given delimiter.\n   *\n   * @public\n   * @aka toString\n   * @param {string=} delimiter The separator to insert between every element from\n   *     this sequence in the resulting string (defaults to `\",\"`).\n   * @returns {string} The delimited string.\n   *\n   * @examples\n   * Lazy([6, 29, 1984]).join(\"/\")  // => \"6/29/1984\"\n   * Lazy([\"a\", \"b\", \"c\"]).join()   // => \"a,b,c\"\n   * Lazy([\"a\", \"b\", \"c\"]).join(\"\") // => \"abc\"\n   * Lazy([1, 2, 3]).join()         // => \"1,2,3\"\n   * Lazy([1, 2, 3]).join(\"\")       // => \"123\"\n   * Lazy([\"\", \"\", \"\"]).join(\",\")   // => \",,\"\n   */\n  Sequence.prototype.join = function join(delimiter) {\n    delimiter = typeof delimiter === \"string\" ? delimiter : \",\";\n\n    return this.reduce(function(str, e, i) {\n      if (i > 0) {\n        str += delimiter;\n      }\n      return str + e;\n    }, \"\");\n  };\n\n  Sequence.prototype.toString = function toString(delimiter) {\n    return this.join(delimiter);\n  };\n\n  /**\n   * Creates a sequence, with the same elements as this one, that will be iterated\n   * over asynchronously when calling `each`.\n   *\n   * @public\n   * @param {number=} interval The approximate period, in milliseconds, that\n   *     should elapse between each element in the resulting sequence. Omitting\n   *     this argument will result in the fastest possible asynchronous iteration.\n   * @returns {AsyncSequence} The new asynchronous sequence.\n   *\n   * @examples\n   * Lazy([1, 2, 3]).async(100).each(fn) // calls fn 3 times asynchronously\n   */\n  Sequence.prototype.async = function async(interval) {\n    return new AsyncSequence(this, interval);\n  };\n\n  /**\n   * @constructor\n   */\n  function SimpleIntersectionSequence(parent, array) {\n    this.parent = parent;\n    this.array  = array;\n    this.each   = getEachForIntersection(array);\n  }\n\n  SimpleIntersectionSequence.prototype = new Sequence();\n\n  SimpleIntersectionSequence.prototype.eachMemoizerCache = function eachMemoizerCache(fn) {\n    var iterator = new UniqueMemoizer(Lazy(this.array).getIterator()),\n        i = 0;\n\n    return this.parent.each(function(e) {\n      if (iterator.contains(e)) {\n        return fn(e, i++);\n      }\n    });\n  };\n\n  SimpleIntersectionSequence.prototype.eachArrayCache = function eachArrayCache(fn) {\n    var array = this.array,\n        find  = arrayContains,\n        i = 0;\n\n    return this.parent.each(function(e) {\n      if (find(array, e)) {\n        return fn(e, i++);\n      }\n    });\n  };\n\n  function getEachForIntersection(source) {\n    if (source.length < 40) {\n      return SimpleIntersectionSequence.prototype.eachArrayCache;\n    } else {\n      return SimpleIntersectionSequence.prototype.eachMemoizerCache;\n    }\n  }\n\n  /**\n   * An optimized version of {@link ZippedSequence}, when zipping a sequence with\n   * only one array.\n   *\n   * @param {Sequence} parent The underlying sequence.\n   * @param {Array} array The array with which to zip the sequence.\n   * @constructor\n   */\n  function SimpleZippedSequence(parent, array) {\n    this.parent = parent;\n    this.array  = array;\n  }\n\n  SimpleZippedSequence.prototype = new Sequence();\n\n  SimpleZippedSequence.prototype.each = function each(fn) {\n    var array = this.array;\n    return this.parent.each(function(e, i) {\n      return fn([e, array[i]], i);\n    });\n  };\n\n  /**\n   * An `ArrayLikeSequence` is a {@link Sequence} that provides random access to\n   * its elements. This extends the API for iterating with the additional methods\n   * {@link #get} and {@link #length}, allowing a sequence to act as a \"view\" into\n   * a collection or other indexed data source.\n   *\n   * The initial sequence created by wrapping an array with `Lazy(array)` is an\n   * `ArrayLikeSequence`.\n   *\n   * All methods of `ArrayLikeSequence` that conceptually should return\n   * something like a array (with indexed access) return another\n   * `ArrayLikeSequence`, for example:\n   *\n   * - {@link Sequence#map}\n   * - {@link ArrayLikeSequence#slice}\n   * - {@link Sequence#take} and {@link Sequence#drop}\n   * - {@link Sequence#reverse}\n   *\n   * The above is not an exhaustive list. There are also certain other cases\n   * where it might be possible to return an `ArrayLikeSequence` (e.g., calling\n   * {@link Sequence#concat} with a single array argument), but this is not\n   * guaranteed by the API.\n   *\n   * Note that in many cases, it is not possible to provide indexed access\n   * without first performing at least a partial iteration of the underlying\n   * sequence. In these cases an `ArrayLikeSequence` will not be returned:\n   *\n   * - {@link Sequence#filter}\n   * - {@link Sequence#uniq}\n   * - {@link Sequence#union}\n   * - {@link Sequence#intersect}\n   *\n   * etc. The above methods only return ordinary {@link Sequence} objects.\n   *\n   * Defining custom array-like sequences\n   * ------------------------------------\n   *\n   * Creating a custom `ArrayLikeSequence` is essentially the same as creating a\n   * custom {@link Sequence}. You just have a couple more methods you need to\n   * implement: `get` and (optionally) `length`.\n   *\n   * Here's an example. Let's define a sequence type called `OffsetSequence` that\n   * offsets each of its parent's elements by a set distance, and circles back to\n   * the beginning after reaching the end. **Remember**: the initialization\n   * function you pass to {@link #define} should always accept a `parent` as its\n   * first parameter.\n   *\n   *     ArrayLikeSequence.define(\"offset\", {\n   *       init: function(parent, offset) {\n   *         this.offset = offset;\n   *       },\n   *\n   *       get: function(i) {\n   *         return this.parent.get((i + this.offset) % this.parent.length());\n   *       }\n   *     });\n   *\n   * It's worth noting a couple of things here.\n   *\n   * First, Lazy's default implementation of `length` simply returns the parent's\n   * length. In this case, since an `OffsetSequence` will always have the same\n   * number of elements as its parent, that implementation is fine; so we don't\n   * need to override it.\n   *\n   * Second, the default implementation of `each` uses `get` and `length` to\n   * essentially create a `for` loop, which is fine here. If you want to implement\n   * `each` your own way, you can do that; but in most cases (as here), you can\n   * probably just stick with the default.\n   *\n   * So we're already done, after only implementing `get`! Pretty easy, huh?\n   *\n   * Now the `offset` method will be chainable from any `ArrayLikeSequence`. So\n   * for example:\n   *\n   *     Lazy([1, 2, 3]).map(mapFn).offset(3);\n   *\n   * ...will work, but:\n   *\n   *     Lazy([1, 2, 3]).filter(mapFn).offset(3);\n   *\n   * ...will not (because `filter` does not return an `ArrayLikeSequence`).\n   *\n   * (Also, as with the example provided for defining custom {@link Sequence}\n   * types, this example really could have been implemented using a function\n   * already available as part of Lazy.js: in this case, {@link Sequence#map}.)\n   *\n   * @public\n   * @constructor\n   *\n   * @examples\n   * Lazy([1, 2, 3])                    // instanceof Lazy.ArrayLikeSequence\n   * Lazy([1, 2, 3]).map(Lazy.identity) // instanceof Lazy.ArrayLikeSequence\n   * Lazy([1, 2, 3]).take(2)            // instanceof Lazy.ArrayLikeSequence\n   * Lazy([1, 2, 3]).drop(2)            // instanceof Lazy.ArrayLikeSequence\n   * Lazy([1, 2, 3]).reverse()          // instanceof Lazy.ArrayLikeSequence\n   * Lazy([1, 2, 3]).slice(1, 2)        // instanceof Lazy.ArrayLikeSequence\n   */\n  function ArrayLikeSequence() {}\n\n  ArrayLikeSequence.prototype = new Sequence();\n\n  /**\n   * Create a new constructor function for a type inheriting from\n   * `ArrayLikeSequence`.\n   *\n   * @public\n   * @param {string|Array.<string>} methodName The name(s) of the method(s) to be\n   *     used for constructing the new sequence. The method will be attached to\n   *     the `ArrayLikeSequence` prototype so that it can be chained with any other\n   *     methods that return array-like sequences.\n   * @param {Object} overrides An object containing function overrides for this\n   *     new sequence type. **Must** include `get`. *May* include `init`,\n   *     `length`, `getIterator`, and `each`. For each function, `this` will be\n   *     the new sequence and `this.parent` will be the source sequence.\n   * @returns {Function} A constructor for a new type inheriting from\n   *     `ArrayLikeSequence`.\n   *\n   * @examples\n   * Lazy.ArrayLikeSequence.define(\"offset\", {\n   *   init: function(offset) {\n   *     this.offset = offset;\n   *   },\n   *\n   *   get: function(i) {\n   *     return this.parent.get((i + this.offset) % this.parent.length());\n   *   }\n   * });\n   *\n   * Lazy([1, 2, 3]).offset(1) // sequence: [2, 3, 1]\n   */\n  ArrayLikeSequence.define = function define(methodName, overrides) {\n    if (!overrides || typeof overrides.get !== 'function') {\n      throw new Error(\"A custom array-like sequence must implement *at least* get!\");\n    }\n\n    return defineSequenceType(ArrayLikeSequence, methodName, overrides);\n  };\n\n  /**\n   * Returns the element at the specified index.\n   *\n   * @public\n   * @param {number} i The index to access.\n   * @returns {*} The element.\n   *\n   * @examples\n   * function increment(x) { return x + 1; }\n   *\n   * Lazy([1, 2, 3]).get(1)                // => 2\n   * Lazy([1, 2, 3]).get(-1)               // => undefined\n   * Lazy([1, 2, 3]).map(increment).get(1) // => 3\n   */\n  ArrayLikeSequence.prototype.get = function get(i) {\n    return this.parent.get(i);\n  };\n\n  /**\n   * Returns the length of the sequence.\n   *\n   * @public\n   * @returns {number} The length.\n   *\n   * @examples\n   * function increment(x) { return x + 1; }\n   *\n   * Lazy([]).length()                       // => 0\n   * Lazy([1, 2, 3]).length()                // => 3\n   * Lazy([1, 2, 3]).map(increment).length() // => 3\n   */\n  ArrayLikeSequence.prototype.length = function length() {\n    return this.parent.length();\n  };\n\n  /**\n   * Returns the current sequence (since it is already indexed).\n   */\n  ArrayLikeSequence.prototype.getIndex = function getIndex() {\n    return this;\n  };\n\n  /**\n   * An optimized version of {@link Sequence#getIterator}.\n   */\n  ArrayLikeSequence.prototype.getIterator = function getIterator() {\n    return new IndexedIterator(this);\n  };\n\n  /**\n   * An optimized version of {@link Iterator} meant to work with already-indexed\n   * sequences.\n   *\n   * @param {ArrayLikeSequence} sequence The sequence to iterate over.\n   * @constructor\n   */\n  function IndexedIterator(sequence) {\n    this.sequence = sequence;\n    this.index    = -1;\n  }\n\n  IndexedIterator.prototype.current = function current() {\n    return this.sequence.get(this.index);\n  };\n\n  IndexedIterator.prototype.moveNext = function moveNext() {\n    if (this.index >= this.sequence.length() - 1) {\n      return false;\n    }\n\n    ++this.index;\n    return true;\n  };\n\n  /**\n   * An optimized version of {@link Sequence#each}.\n   */\n  ArrayLikeSequence.prototype.each = function each(fn) {\n    var length = this.length(),\n        i = -1;\n\n    while (++i < length) {\n      if (fn(this.get(i), i) === false) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  /**\n   * Returns a new sequence with the same elements as this one, minus the last\n   * element.\n   *\n   * @public\n   * @returns {ArrayLikeSequence} The new array-like sequence.\n   *\n   * @examples\n   * Lazy([1, 2, 3]).pop() // sequence: [1, 2]\n   * Lazy([]).pop()        // sequence: []\n   */\n  ArrayLikeSequence.prototype.pop = function pop() {\n    return this.initial();\n  };\n\n  /**\n   * Returns a new sequence with the same elements as this one, minus the first\n   * element.\n   *\n   * @public\n   * @returns {ArrayLikeSequence} The new array-like sequence.\n   *\n   * @examples\n   * Lazy([1, 2, 3]).shift() // sequence: [2, 3]\n   * Lazy([]).shift()        // sequence: []\n   */\n  ArrayLikeSequence.prototype.shift = function shift() {\n    return this.drop();\n  };\n\n  /**\n   * Returns a new sequence comprising the portion of this sequence starting\n   * from the specified starting index and continuing until the specified ending\n   * index or to the end of the sequence.\n   *\n   * @public\n   * @param {number} begin The index at which the new sequence should start.\n   * @param {number=} end The index at which the new sequence should end.\n   * @returns {ArrayLikeSequence} The new array-like sequence.\n   *\n   * @examples\n   * Lazy([1, 2, 3, 4, 5]).slice(0)     // sequence: [1, 2, 3, 4, 5]\n   * Lazy([1, 2, 3, 4, 5]).slice(2)     // sequence: [3, 4, 5]\n   * Lazy([1, 2, 3, 4, 5]).slice(2, 4)  // sequence: [3, 4]\n   * Lazy([1, 2, 3, 4, 5]).slice(-1)    // sequence: [5]\n   * Lazy([1, 2, 3, 4, 5]).slice(1, -1) // sequence: [2, 3, 4]\n   * Lazy([1, 2, 3, 4, 5]).slice(0, 10) // sequence: [1, 2, 3, 4, 5]\n   */\n  ArrayLikeSequence.prototype.slice = function slice(begin, end) {\n    var length = this.length();\n\n    if (begin < 0) {\n      begin = length + begin;\n    }\n\n    var result = this.drop(begin);\n\n    if (typeof end === \"number\") {\n      if (end < 0) {\n        end = length + end;\n      }\n      result = result.take(end - begin);\n    }\n\n    return result;\n  };\n\n  /**\n   * An optimized version of {@link Sequence#map}, which creates an\n   * {@link ArrayLikeSequence} so that the result still provides random access.\n   *\n   * @public\n   *\n   * @examples\n   * Lazy([1, 2, 3]).map(Lazy.identity) // instanceof Lazy.ArrayLikeSequence\n   */\n  ArrayLikeSequence.prototype.map = function map(mapFn) {\n    return new IndexedMappedSequence(this, createCallback(mapFn));\n  };\n\n  /**\n   * @constructor\n   */\n  function IndexedMappedSequence(parent, mapFn) {\n    this.parent = parent;\n    this.mapFn  = mapFn;\n  }\n\n  IndexedMappedSequence.prototype = new ArrayLikeSequence();\n\n  IndexedMappedSequence.prototype.get = function get(i) {\n    if (i < 0 || i >= this.parent.length()) {\n      return undefined;\n    }\n\n    return this.mapFn(this.parent.get(i), i);\n  };\n\n  /**\n   * An optimized version of {@link Sequence#filter}.\n   */\n  ArrayLikeSequence.prototype.filter = function filter(filterFn) {\n    return new IndexedFilteredSequence(this, createCallback(filterFn));\n  };\n\n  /**\n   * @constructor\n   */\n  function IndexedFilteredSequence(parent, filterFn) {\n    this.parent   = parent;\n    this.filterFn = filterFn;\n  }\n\n  IndexedFilteredSequence.prototype = new FilteredSequence();\n\n  IndexedFilteredSequence.prototype.each = function each(fn) {\n    var parent = this.parent,\n        filterFn = this.filterFn,\n        length = this.parent.length(),\n        i = -1,\n        j = 0,\n        e;\n\n    while (++i < length) {\n      e = parent.get(i);\n      if (filterFn(e, i) && fn(e, j++) === false) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  /**\n   * An optimized version of {@link Sequence#reverse}, which creates an\n   * {@link ArrayLikeSequence} so that the result still provides random access.\n   *\n   * @public\n   *\n   * @examples\n   * Lazy([1, 2, 3]).reverse() // instanceof Lazy.ArrayLikeSequence\n   */\n  ArrayLikeSequence.prototype.reverse = function reverse() {\n    return new IndexedReversedSequence(this);\n  };\n\n  /**\n   * @constructor\n   */\n  function IndexedReversedSequence(parent) {\n    this.parent = parent;\n  }\n\n  IndexedReversedSequence.prototype = new ArrayLikeSequence();\n\n  IndexedReversedSequence.prototype.get = function get(i) {\n    return this.parent.get(this.length() - i - 1);\n  };\n\n  /**\n   * An optimized version of {@link Sequence#first}, which creates an\n   * {@link ArrayLikeSequence} so that the result still provides random access.\n   *\n   * @public\n   *\n   * @examples\n   * Lazy([1, 2, 3]).first(2) // instanceof Lazy.ArrayLikeSequence\n   */\n  ArrayLikeSequence.prototype.first = function first(count) {\n    if (typeof count === \"undefined\") {\n      return this.get(0);\n    }\n\n    return new IndexedTakeSequence(this, count);\n  };\n\n  /**\n   * @constructor\n   */\n  function IndexedTakeSequence(parent, count) {\n    this.parent = parent;\n    this.count  = count;\n  }\n\n  IndexedTakeSequence.prototype = new ArrayLikeSequence();\n\n  IndexedTakeSequence.prototype.length = function length() {\n    var parentLength = this.parent.length();\n    return this.count <= parentLength ? this.count : parentLength;\n  };\n\n  /**\n   * An optimized version of {@link Sequence#rest}, which creates an\n   * {@link ArrayLikeSequence} so that the result still provides random access.\n   *\n   * @public\n   *\n   * @examples\n   * Lazy([1, 2, 3]).rest() // instanceof Lazy.ArrayLikeSequence\n   */\n  ArrayLikeSequence.prototype.rest = function rest(count) {\n    return new IndexedDropSequence(this, count);\n  };\n\n  /**\n   * @constructor\n   */\n  function IndexedDropSequence(parent, count) {\n    this.parent = parent;\n    this.count  = typeof count === \"number\" ? count : 1;\n  }\n\n  IndexedDropSequence.prototype = new ArrayLikeSequence();\n\n  IndexedDropSequence.prototype.get = function get(i) {\n    return this.parent.get(this.count + i);\n  };\n\n  IndexedDropSequence.prototype.length = function length() {\n    var parentLength = this.parent.length();\n    return this.count <= parentLength ? parentLength - this.count : 0;\n  };\n\n  /**\n   * An optimized version of {@link Sequence#concat} that returns another\n   * {@link ArrayLikeSequence} *if* the argument is an array.\n   *\n   * @public\n   * @param {...*} var_args\n   *\n   * @examples\n   * Lazy([1, 2]).concat([3, 4]) // instanceof Lazy.ArrayLikeSequence\n   * Lazy([1, 2]).concat([3, 4]) // sequence: [1, 2, 3, 4]\n   */\n  ArrayLikeSequence.prototype.concat = function concat(var_args) {\n    if (arguments.length === 1 && arguments[0] instanceof Array) {\n      return new IndexedConcatenatedSequence(this, (/** @type {Array} */ var_args));\n    } else {\n      return Sequence.prototype.concat.apply(this, arguments);\n    }\n  };\n\n  /**\n   * @constructor\n   */\n  function IndexedConcatenatedSequence(parent, other) {\n    this.parent = parent;\n    this.other  = other;\n  }\n\n  IndexedConcatenatedSequence.prototype = new ArrayLikeSequence();\n\n  IndexedConcatenatedSequence.prototype.get = function get(i) {\n    var parentLength = this.parent.length();\n    if (i < parentLength) {\n      return this.parent.get(i);\n    } else {\n      return this.other[i - parentLength];\n    }\n  };\n\n  IndexedConcatenatedSequence.prototype.length = function length() {\n    return this.parent.length() + this.other.length;\n  };\n\n  /**\n   * An optimized version of {@link Sequence#uniq}.\n   */\n  ArrayLikeSequence.prototype.uniq = function uniq(keyFn) {\n    return new IndexedUniqueSequence(this, createCallback(keyFn));\n  };\n\n  /**\n   * @param {ArrayLikeSequence} parent\n   * @constructor\n   */\n  function IndexedUniqueSequence(parent, keyFn) {\n    this.parent = parent;\n    this.each   = getEachForParent(parent);\n    this.keyFn  = keyFn;\n  }\n\n  IndexedUniqueSequence.prototype = new Sequence();\n\n  IndexedUniqueSequence.prototype.eachArrayCache = function eachArrayCache(fn) {\n    // Basically the same implementation as w/ the set, but using an array because\n    // it's cheaper for smaller sequences.\n    var parent = this.parent,\n        keyFn  = this.keyFn,\n        length = parent.length(),\n        cache  = [],\n        find   = arrayContains,\n        key, value,\n        i = -1,\n        j = 0;\n\n    while (++i < length) {\n      value = parent.get(i);\n      key = keyFn(value);\n      if (!find(cache, key)) {\n        cache.push(key);\n        if (fn(value, j++) === false) {\n          return false;\n        }\n      }\n    }\n  };\n\n  IndexedUniqueSequence.prototype.eachSetCache = UniqueSequence.prototype.each;\n\n  function getEachForParent(parent) {\n    if (parent.length() < 100) {\n      return IndexedUniqueSequence.prototype.eachArrayCache;\n    } else {\n      return UniqueSequence.prototype.each;\n    }\n  }\n\n  // Now that we've fully initialized the ArrayLikeSequence prototype, we can\n  // set the prototype for MemoizedSequence.\n\n  MemoizedSequence.prototype = new ArrayLikeSequence();\n\n  MemoizedSequence.prototype.cache = function cache() {\n    return this.cachedResult || (this.cachedResult = this.parent.toArray());\n  };\n\n  MemoizedSequence.prototype.get = function get(i) {\n    return this.cache()[i];\n  };\n\n  MemoizedSequence.prototype.length = function length() {\n    return this.cache().length;\n  };\n\n  MemoizedSequence.prototype.slice = function slice(begin, end) {\n    return this.cache().slice(begin, end);\n  };\n\n  MemoizedSequence.prototype.toArray = function toArray() {\n    return this.cache().slice(0);\n  };\n\n  /**\n   * ArrayWrapper is the most basic {@link Sequence}. It directly wraps an array\n   * and implements the same methods as {@link ArrayLikeSequence}, but more\n   * efficiently.\n   *\n   * @constructor\n   */\n  function ArrayWrapper(source) {\n    this.source = source;\n  }\n\n  ArrayWrapper.prototype = new ArrayLikeSequence();\n\n  ArrayWrapper.prototype.root = function root() {\n    return this;\n  };\n\n  ArrayWrapper.prototype.isAsync = function isAsync() {\n    return false;\n  };\n\n  /**\n   * Returns the element at the specified index in the source array.\n   *\n   * @param {number} i The index to access.\n   * @returns {*} The element.\n   */\n  ArrayWrapper.prototype.get = function get(i) {\n    return this.source[i];\n  };\n\n  /**\n   * Returns the length of the source array.\n   *\n   * @returns {number} The length.\n   */\n  ArrayWrapper.prototype.length = function length() {\n    return this.source.length;\n  };\n\n  /**\n   * An optimized version of {@link Sequence#each}.\n   */\n  ArrayWrapper.prototype.each = function each(fn) {\n    return forEach(this.source, fn);\n  };\n\n  /**\n   * An optimized version of {@link Sequence#map}.\n   */\n  ArrayWrapper.prototype.map = function map(mapFn) {\n    return new MappedArrayWrapper(this, createCallback(mapFn));\n  };\n\n  /**\n   * An optimized version of {@link Sequence#filter}.\n   */\n  ArrayWrapper.prototype.filter = function filter(filterFn) {\n    return new FilteredArrayWrapper(this, createCallback(filterFn));\n  };\n\n  /**\n   * An optimized version of {@link Sequence#uniq}.\n   */\n  ArrayWrapper.prototype.uniq = function uniq(keyFn) {\n    return new UniqueArrayWrapper(this, keyFn);\n  };\n\n  /**\n   * An optimized version of {@link ArrayLikeSequence#concat}.\n   *\n   * @param {...*} var_args\n   */\n  ArrayWrapper.prototype.concat = function concat(var_args) {\n    if (arguments.length === 1 && arguments[0] instanceof Array) {\n      return new ConcatArrayWrapper(this, (/** @type {Array} */ var_args));\n    } else {\n      return ArrayLikeSequence.prototype.concat.apply(this, arguments);\n    }\n  };\n\n  /**\n   * An optimized version of {@link Sequence#toArray}.\n   */\n  ArrayWrapper.prototype.toArray = function toArray() {\n    return this.source.slice(0);\n  };\n\n  /**\n   * @constructor\n   */\n  function MappedArrayWrapper(parent, mapFn) {\n    this.parent = parent;\n    this.mapFn  = mapFn;\n  }\n\n  MappedArrayWrapper.prototype = new ArrayLikeSequence();\n\n  MappedArrayWrapper.prototype.get = function get(i) {\n    var source = this.parent.source;\n\n    if (i < 0 || i >= source.length) {\n      return undefined;\n    }\n\n    return this.mapFn(source[i]);\n  };\n\n  MappedArrayWrapper.prototype.length = function length() {\n    return this.parent.source.length;\n  };\n\n  MappedArrayWrapper.prototype.each = function each(fn) {\n    var source = this.parent.source,\n        length = source.length,\n        mapFn  = this.mapFn,\n        i = -1;\n\n    while (++i < length) {\n      if (fn(mapFn(source[i], i), i) === false) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  /**\n   * @constructor\n   */\n  function FilteredArrayWrapper(parent, filterFn) {\n    this.parent   = parent;\n    this.filterFn = filterFn;\n  }\n\n  FilteredArrayWrapper.prototype = new FilteredSequence();\n\n  FilteredArrayWrapper.prototype.each = function each(fn) {\n    var source = this.parent.source,\n        filterFn = this.filterFn,\n        length = source.length,\n        i = -1,\n        j = 0,\n        e;\n\n    while (++i < length) {\n      e = source[i];\n      if (filterFn(e, i) && fn(e, j++) === false) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  /**\n   * @constructor\n   */\n  function UniqueArrayWrapper(parent, keyFn) {\n    this.parent = parent;\n    this.each   = getEachForSource(parent.source);\n    this.keyFn  = keyFn;\n  }\n\n  UniqueArrayWrapper.prototype = new Sequence();\n\n  UniqueArrayWrapper.prototype.eachNoCache = function eachNoCache(fn) {\n    var source = this.parent.source,\n        keyFn  = this.keyFn,\n        length = source.length,\n        find   = arrayContainsBefore,\n        value,\n\n        // Yes, this is hideous.\n        // Trying to get performance first, will refactor next!\n        i = -1,\n        k = 0;\n\n    while (++i < length) {\n      value = source[i];\n      if (!find(source, value, i, keyFn) && fn(value, k++) === false) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  UniqueArrayWrapper.prototype.eachArrayCache = function eachArrayCache(fn) {\n    // Basically the same implementation as w/ the set, but using an array because\n    // it's cheaper for smaller sequences.\n    var source = this.parent.source,\n        keyFn  = this.keyFn,\n        length = source.length,\n        cache  = [],\n        find   = arrayContains,\n        key, value,\n        i = -1,\n        j = 0;\n\n    if (keyFn) {\n      keyFn = createCallback(keyFn);\n      while (++i < length) {\n        value = source[i];\n        key = keyFn(value);\n        if (!find(cache, key)) {\n          cache.push(key);\n          if (fn(value, j++) === false) {\n            return false;\n          }\n        }\n      }\n\n    } else {\n      while (++i < length) {\n        value = source[i];\n        if (!find(cache, value)) {\n          cache.push(value);\n          if (fn(value, j++) === false) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  UniqueArrayWrapper.prototype.eachSetCache = UniqueSequence.prototype.each;\n\n  /**\n   * My latest findings here...\n   *\n   * So I hadn't really given the set-based approach enough credit. The main issue\n   * was that my Set implementation was totally not optimized at all. After pretty\n   * heavily optimizing it (just take a look; it's a monstrosity now!), it now\n   * becomes the fastest option for much smaller values of N.\n   */\n  function getEachForSource(source) {\n    if (source.length < 40) {\n      return UniqueArrayWrapper.prototype.eachNoCache;\n    } else if (source.length < 100) {\n      return UniqueArrayWrapper.prototype.eachArrayCache;\n    } else {\n      return UniqueArrayWrapper.prototype.eachSetCache;\n    }\n  }\n\n  /**\n   * @constructor\n   */\n  function ConcatArrayWrapper(parent, other) {\n    this.parent = parent;\n    this.other  = other;\n  }\n\n  ConcatArrayWrapper.prototype = new ArrayLikeSequence();\n\n  ConcatArrayWrapper.prototype.get = function get(i) {\n    var source = this.parent.source,\n        sourceLength = source.length;\n\n    if (i < sourceLength) {\n      return source[i];\n    } else {\n      return this.other[i - sourceLength];\n    }\n  };\n\n  ConcatArrayWrapper.prototype.length = function length() {\n    return this.parent.source.length + this.other.length;\n  };\n\n  ConcatArrayWrapper.prototype.each = function each(fn) {\n    var source = this.parent.source,\n        sourceLength = source.length,\n        other = this.other,\n        otherLength = other.length,\n        i = 0,\n        j = -1;\n\n    while (++j < sourceLength) {\n      if (fn(source[j], i++) === false) {\n        return false;\n      }\n    }\n\n    j = -1;\n    while (++j < otherLength) {\n      if (fn(other[j], i++) === false) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  /**\n   * An `ObjectLikeSequence` object represents a sequence of key/value pairs.\n   *\n   * The initial sequence you get by wrapping an object with `Lazy(object)` is\n   * an `ObjectLikeSequence`.\n   *\n   * All methods of `ObjectLikeSequence` that conceptually should return\n   * something like an object return another `ObjectLikeSequence`.\n   *\n   * @public\n   * @constructor\n   *\n   * @examples\n   * var obj = { foo: 'bar' };\n   *\n   * Lazy(obj).assign({ bar: 'baz' })   // instanceof Lazy.ObjectLikeSequence\n   * Lazy(obj).defaults({ bar: 'baz' }) // instanceof Lazy.ObjectLikeSequence\n   * Lazy(obj).invert()                 // instanceof Lazy.ObjectLikeSequence\n   */\n  function ObjectLikeSequence() {}\n\n  ObjectLikeSequence.prototype = new Sequence();\n\n  /**\n   * Create a new constructor function for a type inheriting from\n   * `ObjectLikeSequence`.\n   *\n   * @public\n   * @param {string|Array.<string>} methodName The name(s) of the method(s) to be\n   *     used for constructing the new sequence. The method will be attached to\n   *     the `ObjectLikeSequence` prototype so that it can be chained with any other\n   *     methods that return object-like sequences.\n   * @param {Object} overrides An object containing function overrides for this\n   *     new sequence type. **Must** include `each`. *May* include `init` and\n   *     `get` (for looking up an element by key).\n   * @returns {Function} A constructor for a new type inheriting from\n   *     `ObjectLikeSequence`.\n   *\n   * @examples\n   * function downcaseKey(value, key) {\n   *   return [key.toLowerCase(), value];\n   * }\n   *\n   * Lazy.ObjectLikeSequence.define(\"caseInsensitive\", {\n   *   init: function() {\n   *     var downcased = this.parent\n   *       .map(downcaseKey)\n   *       .toObject();\n   *     this.downcased = Lazy(downcased);\n   *   },\n   *\n   *   get: function(key) {\n   *     return this.downcased.get(key.toLowerCase());\n   *   },\n   *\n   *   each: function(fn) {\n   *     return this.downcased.each(fn);\n   *   }\n   * });\n   *\n   * Lazy({ Foo: 'bar' }).caseInsensitive()            // sequence: { foo: 'bar' }\n   * Lazy({ FOO: 'bar' }).caseInsensitive().get('foo') // => 'bar'\n   * Lazy({ FOO: 'bar' }).caseInsensitive().get('FOO') // => 'bar'\n   */\n  ObjectLikeSequence.define = function define(methodName, overrides) {\n    if (!overrides || typeof overrides.each !== 'function') {\n      throw new Error(\"A custom object-like sequence must implement *at least* each!\");\n    }\n\n    return defineSequenceType(ObjectLikeSequence, methodName, overrides);\n  };\n\n  ObjectLikeSequence.prototype.value = function value() {\n    return this.toObject();\n  };\n\n  /**\n   * Gets the element at the specified key in this sequence.\n   *\n   * @public\n   * @param {string} key The key.\n   * @returns {*} The element.\n   *\n   * @examples\n   * Lazy({ foo: \"bar\" }).get(\"foo\")                          // => \"bar\"\n   * Lazy({ foo: \"bar\" }).extend({ foo: \"baz\" }).get(\"foo\")   // => \"baz\"\n   * Lazy({ foo: \"bar\" }).defaults({ bar: \"baz\" }).get(\"bar\") // => \"baz\"\n   * Lazy({ foo: \"bar\" }).invert().get(\"bar\")                 // => \"foo\"\n   * Lazy({ foo: 1, bar: 2 }).pick([\"foo\"]).get(\"foo\")        // => 1\n   * Lazy({ foo: 1, bar: 2 }).pick([\"foo\"]).get(\"bar\")        // => undefined\n   * Lazy({ foo: 1, bar: 2 }).omit([\"foo\"]).get(\"bar\")        // => 2\n   * Lazy({ foo: 1, bar: 2 }).omit([\"foo\"]).get(\"foo\")        // => undefined\n   */\n  ObjectLikeSequence.prototype.get = function get(key) {\n    var pair = this.pairs().find(function(pair) {\n      return pair[0] === key;\n    });\n\n    return pair ? pair[1] : undefined;\n  };\n\n  /**\n   * Returns a {@link Sequence} whose elements are the keys of this object-like\n   * sequence.\n   *\n   * @public\n   * @returns {Sequence} The sequence based on this sequence's keys.\n   *\n   * @examples\n   * Lazy({ hello: \"hola\", goodbye: \"hasta luego\" }).keys() // sequence: [\"hello\", \"goodbye\"]\n   */\n  ObjectLikeSequence.prototype.keys = function keys() {\n    return this.map(function(v, k) { return k; });\n  };\n\n  /**\n   * Returns a {@link Sequence} whose elements are the values of this object-like\n   * sequence.\n   *\n   * @public\n   * @returns {Sequence} The sequence based on this sequence's values.\n   *\n   * @examples\n   * Lazy({ hello: \"hola\", goodbye: \"hasta luego\" }).values() // sequence: [\"hola\", \"hasta luego\"]\n   */\n  ObjectLikeSequence.prototype.values = function values() {\n    return this.map(function(v, k) { return v; });\n  };\n\n  /**\n   * Throws an exception. Asynchronous iteration over object-like sequences is\n   * not supported.\n   *\n   * @public\n   * @examples\n   * Lazy({ foo: 'bar' }).async() // throws\n   */\n  ObjectLikeSequence.prototype.async = function async() {\n    throw new Error('An ObjectLikeSequence does not support asynchronous iteration.');\n  };\n\n  ObjectLikeSequence.prototype.filter = function filter(filterFn) {\n    return new FilteredObjectLikeSequence(this, createCallback(filterFn));\n  };\n\n  function FilteredObjectLikeSequence(parent, filterFn) {\n    this.parent = parent;\n    this.filterFn = filterFn;\n  }\n\n  FilteredObjectLikeSequence.prototype = new ObjectLikeSequence();\n\n  FilteredObjectLikeSequence.prototype.each = function each(fn) {\n    var filterFn = this.filterFn;\n\n    return this.parent.each(function(v, k) {\n      if (filterFn(v, k)) {\n        return fn(v, k);\n      }\n    });\n  };\n\n  /**\n   * Returns this same sequence. (Reversing an object-like sequence doesn't make\n   * any sense.)\n   */\n  ObjectLikeSequence.prototype.reverse = function reverse() {\n    return this;\n  };\n\n  /**\n   * Returns an {@link ObjectLikeSequence} whose elements are the combination of\n   * this sequence and another object. In the case of a key appearing in both this\n   * sequence and the given object, the other object's value will override the\n   * one in this sequence.\n   *\n   * @public\n   * @aka extend\n   * @param {Object} other The other object to assign to this sequence.\n   * @returns {ObjectLikeSequence} A new sequence comprising elements from this\n   *     sequence plus the contents of `other`.\n   *\n   * @examples\n   * Lazy({ \"uno\": 1, \"dos\": 2 }).assign({ \"tres\": 3 })     // sequence: { uno: 1, dos: 2, tres: 3 }\n   * Lazy({ foo: \"bar\" }).assign({ foo: \"baz\" });           // sequence: { foo: \"baz\" }\n   * Lazy({ foo: 'foo' }).assign({ foo: false }).get('foo') // false\n   */\n  ObjectLikeSequence.prototype.assign = function assign(other) {\n    return new AssignSequence(this, other);\n  };\n\n  ObjectLikeSequence.prototype.extend = function extend(other) {\n    return this.assign(other);\n  };\n\n  /**\n   * @constructor\n   */\n  function AssignSequence(parent, other) {\n    this.parent = parent;\n    this.other  = other;\n  }\n\n  AssignSequence.prototype = new ObjectLikeSequence();\n\n  AssignSequence.prototype.get = function get(key) {\n    return key in this.other ? this.other[key] : this.parent.get(key);\n  };\n\n  AssignSequence.prototype.each = function each(fn) {\n    var merged = new Set(),\n        done   = false;\n\n    Lazy(this.other).each(function(value, key) {\n      if (fn(value, key) === false) {\n        done = true;\n        return false;\n      }\n\n      merged.add(key);\n    });\n\n    if (!done) {\n      return this.parent.each(function(value, key) {\n        if (!merged.contains(key) && fn(value, key) === false) {\n          return false;\n        }\n      });\n    }\n  };\n\n  /**\n   * Returns an {@link ObjectLikeSequence} whose elements are the combination of\n   * this sequence and a 'default' object. In the case of a key appearing in both\n   * this sequence and the given object, this sequence's value will override the\n   * default object's.\n   *\n   * @public\n   * @param {Object} defaults The 'default' object to use for missing keys in this\n   *     sequence.\n   * @returns {ObjectLikeSequence} A new sequence comprising elements from this\n   *     sequence supplemented by the contents of `defaults`.\n   *\n   * @examples\n   * Lazy({ name: \"Dan\" }).defaults({ name: \"User\", password: \"passw0rd\" }) // sequence: { name: \"Dan\", password: \"passw0rd\" }\n   * Lazy({ foo: false }).defaults({ foo: 'foo' }).get('foo') // false\n   */\n  ObjectLikeSequence.prototype.defaults = function defaults(defaults) {\n    return new DefaultsSequence(this, defaults);\n  };\n\n  /**\n   * @constructor\n   */\n  function DefaultsSequence(parent, defaults) {\n    this.parent   = parent;\n    this.defaults = defaults;\n  }\n\n  DefaultsSequence.prototype = new ObjectLikeSequence();\n\n  DefaultsSequence.prototype.get = function get(key) {\n    var parentValue = this.parent.get(key);\n    return parentValue !== undefined ? parentValue : this.defaults[key];\n  };\n\n  DefaultsSequence.prototype.each = function each(fn) {\n    var merged = new Set(),\n        done   = false;\n\n    this.parent.each(function(value, key) {\n      if (fn(value, key) === false) {\n        done = true;\n        return false;\n      }\n\n      if (typeof value !== \"undefined\") {\n        merged.add(key);\n      }\n    });\n\n    if (!done) {\n      Lazy(this.defaults).each(function(value, key) {\n        if (!merged.contains(key) && fn(value, key) === false) {\n          return false;\n        }\n      });\n    }\n  };\n\n  /**\n   * Returns an {@link ObjectLikeSequence} whose values are this sequence's keys,\n   * and whose keys are this sequence's values.\n   *\n   * @public\n   * @returns {ObjectLikeSequence} A new sequence comprising the inverted keys and\n   *     values from this sequence.\n   *\n   * @examples\n   * Lazy({ first: \"Dan\", last: \"Tao\" }).invert() // sequence: { Dan: \"first\", Tao: \"last\" }\n   */\n  ObjectLikeSequence.prototype.invert = function invert() {\n    return new InvertedSequence(this);\n  };\n\n  /**\n   * @constructor\n   */\n  function InvertedSequence(parent) {\n    this.parent = parent;\n  }\n\n  InvertedSequence.prototype = new ObjectLikeSequence();\n\n  InvertedSequence.prototype.each = function each(fn) {\n    this.parent.each(function(value, key) {\n      return fn(key, value);\n    });\n  };\n\n  /**\n   * Produces an {@link ObjectLikeSequence} consisting of all the recursively\n   * merged values from this and the given object(s) or sequence(s).\n   *\n   * Note that by default this method only merges \"vanilla\" objects (bags of\n   * key/value pairs), not arrays or any other custom object types. To customize\n   * how merging works, you can provide the mergeFn argument, e.g. to handling\n   * merging arrays, strings, or other types of objects.\n   *\n   * @public\n   * @param {...Object|ObjectLikeSequence} others The other object(s) or\n   *     sequence(s) whose values will be merged into this one.\n   * @param {Function=} mergeFn An optional function used to customize merging\n   *     behavior. The function should take two values as parameters and return\n   *     whatever the \"merged\" form of those values is. If the function returns\n   *     undefined then the new value will simply replace the old one in the\n   *     final result.\n   * @returns {ObjectLikeSequence} The new sequence consisting of merged values.\n   *\n   * @examples\n   * // These examples are completely stolen from Lo-Dash's documentation:\n   * // lodash.com/docs#merge\n   *\n   * var names = {\n   *   'characters': [\n   *     { 'name': 'barney' },\n   *     { 'name': 'fred' }\n   *   ]\n   * };\n   *\n   * var ages = {\n   *   'characters': [\n   *     { 'age': 36 },\n   *     { 'age': 40 }\n   *   ]\n   * };\n   *\n   * var food = {\n   *   'fruits': ['apple'],\n   *   'vegetables': ['beet']\n   * };\n   *\n   * var otherFood = {\n   *   'fruits': ['banana'],\n   *   'vegetables': ['carrot']\n   * };\n   *\n   * function mergeArrays(a, b) {\n   *   return Array.isArray(a) ? a.concat(b) : undefined;\n   * }\n   *\n   * Lazy(names).merge(ages); // => sequence: { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }\n   * Lazy(food).merge(otherFood, mergeArrays); // => sequence: { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot'] }\n   *\n   * // ----- Now for my own tests: -----\n   *\n   * // merges objects\n   * Lazy({ foo: 1 }).merge({ foo: 2 }); // => sequence: { foo: 2 }\n   * Lazy({ foo: 1 }).merge({ bar: 2 }); // => sequence: { foo: 1, bar: 2 }\n   *\n   * // goes deep\n   * Lazy({ foo: { bar: 1 } }).merge({ foo: { bar: 2 } }); // => sequence: { foo: { bar: 2 } }\n   * Lazy({ foo: { bar: 1 } }).merge({ foo: { baz: 2 } }); // => sequence: { foo: { bar: 1, baz: 2 } }\n   * Lazy({ foo: { bar: 1 } }).merge({ foo: { baz: 2 } }); // => sequence: { foo: { bar: 1, baz: 2 } }\n   *\n   * // gives precedence to later sources\n   * Lazy({ foo: 1 }).merge({ bar: 2 }, { bar: 3 }); // => sequence: { foo: 1, bar: 3 }\n   *\n   * // undefined gets passed over\n   * Lazy({ foo: 1 }).merge({ foo: undefined }); // => sequence: { foo: 1 }\n   *\n   * // null doesn't get passed over\n   * Lazy({ foo: 1 }).merge({ foo: null }); // => sequence: { foo: null }\n   *\n   * // array contents get merged as well\n   * Lazy({ foo: [{ bar: 1 }] }).merge({ foo: [{ baz: 2 }] }); // => sequence: { foo: [{ bar: 1, baz: 2}] }\n   */\n  ObjectLikeSequence.prototype.merge = function merge(var_args) {\n    var mergeFn = arguments.length > 1 && typeof arguments[arguments.length - 1] === \"function\" ?\n      arrayPop.call(arguments) : null;\n    return new MergedSequence(this, arraySlice.call(arguments, 0), mergeFn);\n  };\n\n  /**\n   * @constructor\n   */\n  function MergedSequence(parent, others, mergeFn) {\n    this.parent  = parent;\n    this.others  = others;\n    this.mergeFn = mergeFn;\n  }\n\n  MergedSequence.prototype = new ObjectLikeSequence();\n\n  MergedSequence.prototype.each = function each(fn) {\n    var others  = this.others,\n        mergeFn = this.mergeFn || mergeObjects,\n        keys    = {};\n\n    var iteratedFullSource = this.parent.each(function(value, key) {\n      var merged = value;\n\n      forEach(others, function(other) {\n        if (key in other) {\n          merged = mergeFn(merged, other[key]);\n        }\n      });\n\n      keys[key] = true;\n\n      return fn(merged, key);\n    });\n\n    if (iteratedFullSource === false) {\n      return false;\n    }\n\n    var remaining = {};\n\n    forEach(others, function(other) {\n      for (var k in other) {\n        if (!keys[k]) {\n          remaining[k] = mergeFn(remaining[k], other[k]);\n        }\n      }\n    });\n\n    return Lazy(remaining).each(fn);\n  };\n\n  /**\n   * @private\n   * @examples\n   * mergeObjects({ foo: 1 }, { bar: 2 }); // => { foo: 1, bar: 2 }\n   * mergeObjects({ foo: { bar: 1 } }, { foo: { baz: 2 } }); // => { foo: { bar: 1, baz: 2 } }\n   * mergeObjects({ foo: { bar: 1 } }, { foo: undefined }); // => { foo: { bar: 1 } }\n   * mergeObjects({ foo: { bar: 1 } }, { foo: null }); // => { foo: null }\n   * mergeObjects({ array: [0, 1, 2] }, { array: [3, 4, 5] }).array; // instanceof Array\n   * mergeObjects({ date: new Date() }, { date: new Date() }).date; // instanceof Date\n   * mergeObjects([{ foo: 1 }], [{ bar: 2 }]); // => [{ foo: 1, bar: 2 }]\n   */\n  function mergeObjects(a, b) {\n    var merged, prop;\n\n    if (typeof b === 'undefined') {\n      return a;\n    }\n\n    // Check that we're dealing with two objects or two arrays.\n    if (isVanillaObject(a) && isVanillaObject(b)) {\n      merged = {};\n    } else if (a instanceof Array && b instanceof Array) {\n      merged = [];\n    } else {\n      // Otherwise there's no merging to do -- just replace a w/ b.\n      return b;\n    }\n\n    for (prop in a) {\n      merged[prop] = mergeObjects(a[prop], b[prop]);\n    }\n    for (prop in b) {\n      if (!merged[prop]) {\n        merged[prop] = b[prop];\n      }\n    }\n    return merged;\n  }\n\n  /**\n   * Checks whether an object is a \"vanilla\" object, i.e. {'foo': 'bar'} as\n   * opposed to an array, date, etc.\n   *\n   * @private\n   * @examples\n   * isVanillaObject({foo: 'bar'}); // => true\n   * isVanillaObject(new Date());   // => false\n   * isVanillaObject([1, 2, 3]);    // => false\n   */\n  function isVanillaObject(object) {\n    return object && object.constructor === Object;\n  }\n\n  /**\n   * Creates a {@link Sequence} consisting of the keys from this sequence whose\n   *     values are functions.\n   *\n   * @public\n   * @aka methods\n   * @returns {Sequence} The new sequence.\n   *\n   * @examples\n   * var dog = {\n   *   name: \"Fido\",\n   *   breed: \"Golden Retriever\",\n   *   bark: function() { console.log(\"Woof!\"); },\n   *   wagTail: function() { console.log(\"TODO: implement robotic dog interface\"); }\n   * };\n   *\n   * Lazy(dog).functions() // sequence: [\"bark\", \"wagTail\"]\n   */\n  ObjectLikeSequence.prototype.functions = function functions() {\n    return this\n      .filter(function(v, k) { return typeof(v) === \"function\"; })\n      .map(function(v, k) { return k; });\n  };\n\n  ObjectLikeSequence.prototype.methods = function methods() {\n    return this.functions();\n  };\n\n  /**\n   * Creates an {@link ObjectLikeSequence} consisting of the key/value pairs from\n   * this sequence whose keys are included in the given array of property names.\n   *\n   * @public\n   * @param {Array} properties An array of the properties to \"pick\" from this\n   *     sequence.\n   * @returns {ObjectLikeSequence} The new sequence.\n   *\n   * @examples\n   * var players = {\n   *   \"who\": \"first\",\n   *   \"what\": \"second\",\n   *   \"i don't know\": \"third\"\n   * };\n   *\n   * Lazy(players).pick([\"who\", \"what\"]) // sequence: { who: \"first\", what: \"second\" }\n   */\n  ObjectLikeSequence.prototype.pick = function pick(properties) {\n    return new PickSequence(this, properties);\n  };\n\n  /**\n   * @constructor\n   */\n  function PickSequence(parent, properties) {\n    this.parent     = parent;\n    this.properties = properties;\n  }\n\n  PickSequence.prototype = new ObjectLikeSequence();\n\n  PickSequence.prototype.get = function get(key) {\n    return arrayContains(this.properties, key) ? this.parent.get(key) : undefined;\n  };\n\n  PickSequence.prototype.each = function each(fn) {\n    var inArray    = arrayContains,\n        properties = this.properties;\n\n    return this.parent.each(function(value, key) {\n      if (inArray(properties, key)) {\n        return fn(value, key);\n      }\n    });\n  };\n\n  /**\n   * Creates an {@link ObjectLikeSequence} consisting of the key/value pairs from\n   * this sequence excluding those with the specified keys.\n   *\n   * @public\n   * @param {Array} properties An array of the properties to *omit* from this\n   *     sequence.\n   * @returns {ObjectLikeSequence} The new sequence.\n   *\n   * @examples\n   * var players = {\n   *   \"who\": \"first\",\n   *   \"what\": \"second\",\n   *   \"i don't know\": \"third\"\n   * };\n   *\n   * Lazy(players).omit([\"who\", \"what\"]) // sequence: { \"i don't know\": \"third\" }\n   */\n  ObjectLikeSequence.prototype.omit = function omit(properties) {\n    return new OmitSequence(this, properties);\n  };\n\n  /**\n   * @constructor\n   */\n  function OmitSequence(parent, properties) {\n    this.parent     = parent;\n    this.properties = properties;\n  }\n\n  OmitSequence.prototype = new ObjectLikeSequence();\n\n  OmitSequence.prototype.get = function get(key) {\n    return arrayContains(this.properties, key) ? undefined : this.parent.get(key);\n  };\n\n  OmitSequence.prototype.each = function each(fn) {\n    var inArray    = arrayContains,\n        properties = this.properties;\n\n    return this.parent.each(function(value, key) {\n      if (!inArray(properties, key)) {\n        return fn(value, key);\n      }\n    });\n  };\n\n  /**\n   * Maps the key/value pairs in this sequence to arrays.\n   *\n   * @public\n   * @aka toArray\n   * @returns {Sequence} An sequence of `[key, value]` pairs.\n   *\n   * @examples\n   * var colorCodes = {\n   *   red: \"#f00\",\n   *   green: \"#0f0\",\n   *   blue: \"#00f\"\n   * };\n   *\n   * Lazy(colorCodes).pairs() // sequence: [[\"red\", \"#f00\"], [\"green\", \"#0f0\"], [\"blue\", \"#00f\"]]\n   */\n  ObjectLikeSequence.prototype.pairs = function pairs() {\n    return this.map(function(v, k) { return [k, v]; });\n  };\n\n  /**\n   * Creates an array from the key/value pairs in this sequence.\n   *\n   * @public\n   * @returns {Array} An array of `[key, value]` elements.\n   *\n   * @examples\n   * var colorCodes = {\n   *   red: \"#f00\",\n   *   green: \"#0f0\",\n   *   blue: \"#00f\"\n   * };\n   *\n   * Lazy(colorCodes).toArray() // => [[\"red\", \"#f00\"], [\"green\", \"#0f0\"], [\"blue\", \"#00f\"]]\n   */\n  ObjectLikeSequence.prototype.toArray = function toArray() {\n    return this.pairs().toArray();\n  };\n\n  /**\n   * Creates an object with the key/value pairs from this sequence.\n   *\n   * @public\n   * @returns {Object} An object with the same key/value pairs as this sequence.\n   *\n   * @examples\n   * var colorCodes = {\n   *   red: \"#f00\",\n   *   green: \"#0f0\",\n   *   blue: \"#00f\"\n   * };\n   *\n   * Lazy(colorCodes).toObject() // => { red: \"#f00\", green: \"#0f0\", blue: \"#00f\" }\n   */\n  ObjectLikeSequence.prototype.toObject = function toObject() {\n    return this.reduce(function(object, value, key) {\n      object[key] = value;\n      return object;\n    }, {});\n  };\n\n  // Now that we've fully initialized the ObjectLikeSequence prototype, we can\n  // actually set the prototypes for GroupedSequence, IndexedSequence, and\n  // CountedSequence.\n\n  GroupedSequence.prototype = new ObjectLikeSequence();\n\n  GroupedSequence.prototype.each = function each(fn) {\n    var keyFn   = createCallback(this.keyFn),\n        valFn   = createCallback(this.valFn),\n        result;\n\n    result = this.parent.reduce(function(grouped,e) {\n      var key = keyFn(e),\n          val = valFn(e);\n      if (!(grouped[key] instanceof Array)) {\n        grouped[key] = [val];\n      } else {\n        grouped[key].push(val);\n      }\n      return grouped;\n    },{});\n\n    return transform(function(grouped) {\n      for (var key in grouped) {\n        if (fn(grouped[key], key) === false) {\n          return false;\n        }\n      }\n    }, result);\n  };\n\n  IndexedSequence.prototype = new ObjectLikeSequence();\n\n  IndexedSequence.prototype.each = function each(fn) {\n    var keyFn   = createCallback(this.keyFn),\n        valFn   = createCallback(this.valFn),\n        indexed = {};\n\n    return this.parent.each(function(e) {\n      var key = keyFn(e),\n          val = valFn(e);\n\n      if (!indexed[key]) {\n        indexed[key] = val;\n        return fn(val, key);\n      }\n    });\n  };\n\n  CountedSequence.prototype = new ObjectLikeSequence();\n\n  CountedSequence.prototype.each = function each(fn) {\n    var keyFn   = createCallback(this.keyFn),\n        counted = {};\n\n    this.parent.each(function(e) {\n      var key = keyFn(e);\n      if (!counted[key]) {\n        counted[key] = 1;\n      } else {\n        counted[key] += 1;\n      }\n    });\n\n    for (var key in counted) {\n      if (fn(counted[key], key) === false) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  /**\n   * Watches for all changes to a specified property (or properties) of an\n   * object and produces a sequence whose elements have the properties\n   * `{ property, value }` indicating which property changed and what it was\n   * changed to.\n   *\n   * Note that this method **only works on directly wrapped objects**; it will\n   * *not* work on any arbitrary {@link ObjectLikeSequence}.\n   *\n   * @public\n   * @param {(string|Array)=} propertyNames A property name or array of property\n   *     names to watch. If this parameter is `undefined`, all of the object's\n   *     current (enumerable) properties will be watched.\n   * @returns {Sequence} A sequence comprising `{ property, value }` objects\n   *     describing each change to the specified property/properties.\n   *\n   * @examples\n   * var obj = {},\n   *     changes = [];\n   *\n   * Lazy(obj).watch('foo').each(function(change) {\n   *   changes.push(change);\n   * });\n   *\n   * obj.foo = 1;\n   * obj.bar = 2;\n   * obj.foo = 3;\n   *\n   * obj.foo; // => 3\n   * changes; // => [{ property: 'foo', value: 1 }, { property: 'foo', value: 3 }]\n   */\n  ObjectLikeSequence.prototype.watch = function watch(propertyNames) {\n    throw new Error('You can only call #watch on a directly wrapped object.');\n  };\n\n  /**\n   * @constructor\n   */\n  function ObjectWrapper(source) {\n    this.source = source;\n  }\n\n  ObjectWrapper.prototype = new ObjectLikeSequence();\n\n  ObjectWrapper.prototype.root = function root() {\n    return this;\n  };\n\n  ObjectWrapper.prototype.isAsync = function isAsync() {\n    return false;\n  };\n\n  ObjectWrapper.prototype.get = function get(key) {\n    return this.source[key];\n  };\n\n  ObjectWrapper.prototype.each = function each(fn) {\n    var source = this.source,\n        key;\n\n    for (key in source) {\n      if (fn(source[key], key) === false) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  /**\n   * A `StringLikeSequence` represents a sequence of characters.\n   *\n   * The initial sequence you get by wrapping a string with `Lazy(string)` is a\n   * `StringLikeSequence`.\n   *\n   * All methods of `StringLikeSequence` that conceptually should return\n   * something like a string return another `StringLikeSequence`.\n   *\n   * @public\n   * @constructor\n   *\n   * @examples\n   * function upcase(str) { return str.toUpperCase(); }\n   *\n   * Lazy('foo')               // instanceof Lazy.StringLikeSequence\n   * Lazy('foo').toUpperCase() // instanceof Lazy.StringLikeSequence\n   * Lazy('foo').reverse()     // instanceof Lazy.StringLikeSequence\n   * Lazy('foo').take(2)       // instanceof Lazy.StringLikeSequence\n   * Lazy('foo').drop(1)       // instanceof Lazy.StringLikeSequence\n   * Lazy('foo').substring(1)  // instanceof Lazy.StringLikeSequence\n   *\n   * // Note that `map` does not create a `StringLikeSequence` because there's\n   * // no guarantee the mapping function will return characters. In the event\n   * // you do want to map a string onto a string-like sequence, use\n   * // `mapString`:\n   * Lazy('foo').map(Lazy.identity)       // instanceof Lazy.ArrayLikeSequence\n   * Lazy('foo').mapString(Lazy.identity) // instanceof Lazy.StringLikeSequence\n   */\n  function StringLikeSequence() {}\n\n  StringLikeSequence.prototype = new ArrayLikeSequence();\n\n  /**\n   * Create a new constructor function for a type inheriting from\n   * `StringLikeSequence`.\n   *\n   * @public\n   * @param {string|Array.<string>} methodName The name(s) of the method(s) to be\n   *     used for constructing the new sequence. The method will be attached to\n   *     the `StringLikeSequence` prototype so that it can be chained with any other\n   *     methods that return string-like sequences.\n   * @param {Object} overrides An object containing function overrides for this\n   *     new sequence type. Has the same requirements as\n   *     {@link ArrayLikeSequence.define}.\n   * @returns {Function} A constructor for a new type inheriting from\n   *     `StringLikeSequence`.\n   *\n   * @examples\n   * Lazy.StringLikeSequence.define(\"zomg\", {\n   *   length: function() {\n   *     return this.parent.length() + \"!!ZOMG!!!1\".length;\n   *   },\n   *\n   *   get: function(i) {\n   *     if (i < this.parent.length()) {\n   *       return this.parent.get(i);\n   *     }\n   *     return \"!!ZOMG!!!1\".charAt(i - this.parent.length());\n   *   }\n   * });\n   *\n   * Lazy('foo').zomg() // sequence: \"foo!!ZOMG!!!1\"\n   */\n  StringLikeSequence.define = function define(methodName, overrides) {\n    if (!overrides || typeof overrides.get !== 'function') {\n      throw new Error(\"A custom string-like sequence must implement *at least* get!\");\n    }\n\n    return defineSequenceType(StringLikeSequence, methodName, overrides);\n  };\n\n  StringLikeSequence.prototype.value = function value() {\n    return this.toString();\n  };\n\n  /**\n   * Returns an {@link IndexedIterator} that will step over each character in this\n   * sequence one by one.\n   *\n   * @returns {IndexedIterator} The iterator.\n   */\n  StringLikeSequence.prototype.getIterator = function getIterator() {\n    return new CharIterator(this);\n  };\n\n  /**\n   * @constructor\n   */\n  function CharIterator(source) {\n    this.source = Lazy(source);\n    this.index = -1;\n  }\n\n  CharIterator.prototype.current = function current() {\n    return this.source.charAt(this.index);\n  };\n\n  CharIterator.prototype.moveNext = function moveNext() {\n    return (++this.index < this.source.length());\n  };\n\n  /**\n   * Returns the character at the given index of this sequence, or the empty\n   * string if the specified index lies outside the bounds of the sequence.\n   *\n   * @public\n   * @param {number} i The index of this sequence.\n   * @returns {string} The character at the specified index.\n   *\n   * @examples\n   * Lazy(\"foo\").charAt(0)  // => \"f\"\n   * Lazy(\"foo\").charAt(-1) // => \"\"\n   * Lazy(\"foo\").charAt(10) // => \"\"\n   */\n  StringLikeSequence.prototype.charAt = function charAt(i) {\n    return this.get(i);\n  };\n\n  /**\n   * Returns the character code at the given index of this sequence, or `NaN` if\n   * the index lies outside the bounds of the sequence.\n   *\n   * @public\n   * @param {number} i The index of the character whose character code you want.\n   * @returns {number} The character code.\n   *\n   * @examples\n   * Lazy(\"abc\").charCodeAt(0)  // => 97\n   * Lazy(\"abc\").charCodeAt(-1) // => NaN\n   * Lazy(\"abc\").charCodeAt(10) // => NaN\n   */\n  StringLikeSequence.prototype.charCodeAt = function charCodeAt(i) {\n    var char = this.charAt(i);\n    if (!char) { return NaN; }\n\n    return char.charCodeAt(0);\n  };\n\n  /**\n   * Returns a {@link StringLikeSequence} comprising the characters from *this*\n   * sequence starting at `start` and ending at `stop` (exclusive), or---if\n   * `stop` is `undefined`, including the rest of the sequence.\n   *\n   * @public\n   * @param {number} start The index where this sequence should begin.\n   * @param {number=} stop The index (exclusive) where this sequence should end.\n   * @returns {StringLikeSequence} The new sequence.\n   *\n   * @examples\n   * Lazy(\"foo\").substring(1)      // sequence: \"oo\"\n   * Lazy(\"foo\").substring(-1)     // sequence: \"foo\"\n   * Lazy(\"hello\").substring(1, 3) // sequence: \"el\"\n   * Lazy(\"hello\").substring(1, 9) // sequence: \"ello\"\n   */\n  StringLikeSequence.prototype.substring = function substring(start, stop) {\n    return new StringSegment(this, start, stop);\n  };\n\n  /**\n   * @constructor\n   */\n  function StringSegment(parent, start, stop) {\n    this.parent = parent;\n    this.start  = Math.max(0, start);\n    this.stop   = stop;\n  }\n\n  StringSegment.prototype = new StringLikeSequence();\n\n  StringSegment.prototype.get = function get(i) {\n    return this.parent.get(i + this.start);\n  };\n\n  StringSegment.prototype.length = function length() {\n    return (typeof this.stop === \"number\" ? this.stop : this.parent.length()) - this.start;\n  };\n\n  /**\n   * An optimized version of {@link Sequence#first} that returns another\n   * {@link StringLikeSequence} (or just the first character, if `count` is\n   * undefined).\n   *\n   * @public\n   * @examples\n   * Lazy('foo').first()                // => 'f'\n   * Lazy('fo').first(2)                // sequence: 'fo'\n   * Lazy('foo').first(10)              // sequence: 'foo'\n   * Lazy('foo').toUpperCase().first()  // => 'F'\n   * Lazy('foo').toUpperCase().first(2) // sequence: 'FO'\n   */\n  StringLikeSequence.prototype.first = function first(count) {\n    if (typeof count === \"undefined\") {\n      return this.charAt(0);\n    }\n\n    return this.substring(0, count);\n  };\n\n  /**\n   * An optimized version of {@link Sequence#last} that returns another\n   * {@link StringLikeSequence} (or just the last character, if `count` is\n   * undefined).\n   *\n   * @public\n   * @examples\n   * Lazy('foo').last()                // => 'o'\n   * Lazy('foo').last(2)               // sequence: 'oo'\n   * Lazy('foo').last(10)              // sequence: 'foo'\n   * Lazy('foo').toUpperCase().last()  // => 'O'\n   * Lazy('foo').toUpperCase().last(2) // sequence: 'OO'\n   */\n  StringLikeSequence.prototype.last = function last(count) {\n    if (typeof count === \"undefined\") {\n      return this.charAt(this.length() - 1);\n    }\n\n    return this.substring(this.length() - count);\n  };\n\n  StringLikeSequence.prototype.drop = function drop(count) {\n    return this.substring(count);\n  };\n\n  /**\n   * Finds the index of the first occurrence of the given substring within this\n   * sequence, starting from the specified index (or the beginning of the\n   * sequence).\n   *\n   * @public\n   * @param {string} substring The substring to search for.\n   * @param {number=} startIndex The index from which to start the search.\n   * @returns {number} The first index where the given substring is found, or\n   *     -1 if it isn't in the sequence.\n   *\n   * @examples\n   * Lazy('canal').indexOf('a')    // => 1\n   * Lazy('canal').indexOf('a', 2) // => 3\n   * Lazy('canal').indexOf('ana')  // => 1\n   * Lazy('canal').indexOf('andy') // => -1\n   * Lazy('canal').indexOf('x')    // => -1\n   */\n  StringLikeSequence.prototype.indexOf = function indexOf(substring, startIndex) {\n    return this.toString().indexOf(substring, startIndex);\n  };\n\n  /**\n   * Finds the index of the last occurrence of the given substring within this\n   * sequence, starting from the specified index (or the end of the sequence)\n   * and working backwards.\n   *\n   * @public\n   * @param {string} substring The substring to search for.\n   * @param {number=} startIndex The index from which to start the search.\n   * @returns {number} The last index where the given substring is found, or\n   *     -1 if it isn't in the sequence.\n   *\n   * @examples\n   * Lazy('canal').lastIndexOf('a')    // => 3\n   * Lazy('canal').lastIndexOf('a', 2) // => 1\n   * Lazy('canal').lastIndexOf('ana')  // => 1\n   * Lazy('canal').lastIndexOf('andy') // => -1\n   * Lazy('canal').lastIndexOf('x')    // => -1\n   */\n  StringLikeSequence.prototype.lastIndexOf = function lastIndexOf(substring, startIndex) {\n    return this.toString().lastIndexOf(substring, startIndex);\n  };\n\n  /**\n   * Checks if this sequence contains a given substring.\n   *\n   * @public\n   * @param {string} substring The substring to check for.\n   * @returns {boolean} Whether or not this sequence contains `substring`.\n   *\n   * @examples\n   * Lazy('hello').contains('ell') // => true\n   * Lazy('hello').contains('')    // => true\n   * Lazy('hello').contains('abc') // => false\n   */\n  StringLikeSequence.prototype.contains = function contains(substring) {\n    return this.indexOf(substring) !== -1;\n  };\n\n  /**\n   * Checks if this sequence ends with a given suffix.\n   *\n   * @public\n   * @param {string} suffix The suffix to check for.\n   * @returns {boolean} Whether or not this sequence ends with `suffix`.\n   *\n   * @examples\n   * Lazy('foo').endsWith('oo')  // => true\n   * Lazy('foo').endsWith('')    // => true\n   * Lazy('foo').endsWith('abc') // => false\n   */\n  StringLikeSequence.prototype.endsWith = function endsWith(suffix) {\n    return this.substring(this.length() - suffix.length).toString() === suffix;\n  };\n\n  /**\n   * Checks if this sequence starts with a given prefix.\n   *\n   * @public\n   * @param {string} prefix The prefix to check for.\n   * @returns {boolean} Whether or not this sequence starts with `prefix`.\n   *\n   * @examples\n   * Lazy('foo').startsWith('fo')  // => true\n   * Lazy('foo').startsWith('')    // => true\n   * Lazy('foo').startsWith('abc') // => false\n   */\n  StringLikeSequence.prototype.startsWith = function startsWith(prefix) {\n    return this.substring(0, prefix.length).toString() === prefix;\n  };\n\n  /**\n   * Converts all of the characters in this string to uppercase.\n   *\n   * @public\n   * @returns {StringLikeSequence} A new sequence with the same characters as\n   *     this sequence, all uppercase.\n   *\n   * @examples\n   * function nextLetter(a) {\n   *   return String.fromCharCode(a.charCodeAt(0) + 1);\n   * }\n   *\n   * Lazy('foo').toUpperCase()                       // sequence: 'FOO'\n   * Lazy('foo').substring(1).toUpperCase()          // sequence: 'OO'\n   * Lazy('abc').mapString(nextLetter).toUpperCase() // sequence: 'BCD'\n   */\n  StringLikeSequence.prototype.toUpperCase = function toUpperCase() {\n    return this.mapString(function(char) { return char.toUpperCase(); });\n  };\n\n  /**\n   * Converts all of the characters in this string to lowercase.\n   *\n   * @public\n   * @returns {StringLikeSequence} A new sequence with the same characters as\n   *     this sequence, all lowercase.\n   *\n   * @examples\n   * function nextLetter(a) {\n   *   return String.fromCharCode(a.charCodeAt(0) + 1);\n   * }\n   *\n   * Lazy('FOO').toLowerCase()                       // sequence: 'foo'\n   * Lazy('FOO').substring(1).toLowerCase()          // sequence: 'oo'\n   * Lazy('ABC').mapString(nextLetter).toLowerCase() // sequence: 'bcd'\n   */\n  StringLikeSequence.prototype.toLowerCase = function toLowerCase() {\n    return this.mapString(function(char) { return char.toLowerCase(); });\n  };\n\n  /**\n   * Maps the characters of this sequence onto a new {@link StringLikeSequence}.\n   *\n   * @public\n   * @param {Function} mapFn The function used to map characters from this\n   *     sequence onto the new sequence.\n   * @returns {StringLikeSequence} The new sequence.\n   *\n   * @examples\n   * function upcase(char) { return char.toUpperCase(); }\n   *\n   * Lazy(\"foo\").mapString(upcase)               // sequence: \"FOO\"\n   * Lazy(\"foo\").mapString(upcase).charAt(0)     // => \"F\"\n   * Lazy(\"foo\").mapString(upcase).charCodeAt(0) // => 70\n   * Lazy(\"foo\").mapString(upcase).substring(1)  // sequence: \"OO\"\n   */\n  StringLikeSequence.prototype.mapString = function mapString(mapFn) {\n    return new MappedStringLikeSequence(this, mapFn);\n  };\n\n  /**\n   * @constructor\n   */\n  function MappedStringLikeSequence(parent, mapFn) {\n    this.parent = parent;\n    this.mapFn  = mapFn;\n  }\n\n  MappedStringLikeSequence.prototype = new StringLikeSequence();\n  MappedStringLikeSequence.prototype.get = IndexedMappedSequence.prototype.get;\n  MappedStringLikeSequence.prototype.length = IndexedMappedSequence.prototype.length;\n\n  /**\n   * Returns a copy of this sequence that reads back to front.\n   *\n   * @public\n   *\n   * @examples\n   * Lazy(\"abcdefg\").reverse() // sequence: \"gfedcba\"\n   */\n  StringLikeSequence.prototype.reverse = function reverse() {\n    return new ReversedStringLikeSequence(this);\n  };\n\n  /**\n   * @constructor\n   */\n  function ReversedStringLikeSequence(parent) {\n    this.parent = parent;\n  }\n\n  ReversedStringLikeSequence.prototype = new StringLikeSequence();\n  ReversedStringLikeSequence.prototype.get = IndexedReversedSequence.prototype.get;\n  ReversedStringLikeSequence.prototype.length = IndexedReversedSequence.prototype.length;\n\n  StringLikeSequence.prototype.toString = function toString() {\n    return this.join(\"\");\n  };\n\n  /**\n   * Creates a {@link Sequence} comprising all of the matches for the specified\n   * pattern in the underlying string.\n   *\n   * @public\n   * @param {RegExp} pattern The pattern to match.\n   * @returns {Sequence} A sequence of all the matches.\n   *\n   * @examples\n   * Lazy(\"abracadabra\").match(/a[bcd]/) // sequence: [\"ab\", \"ac\", \"ad\", \"ab\"]\n   * Lazy(\"fee fi fo fum\").match(/\\w+/)  // sequence: [\"fee\", \"fi\", \"fo\", \"fum\"]\n   * Lazy(\"hello\").match(/xyz/)          // sequence: []\n   */\n  StringLikeSequence.prototype.match = function match(pattern) {\n    return new StringMatchSequence(this, pattern);\n  };\n\n  /**\n   * @constructor\n   */\n  function StringMatchSequence(parent, pattern) {\n    this.parent = parent;\n    this.pattern = pattern;\n  }\n\n  StringMatchSequence.prototype = new Sequence();\n\n  StringMatchSequence.prototype.getIterator = function getIterator() {\n    return new StringMatchIterator(this.parent.toString(), this.pattern);\n  };\n\n  /**\n   * @constructor\n   */\n  function StringMatchIterator(source, pattern) {\n    this.source  = source;\n    this.pattern = cloneRegex(pattern);\n  }\n\n  StringMatchIterator.prototype.current = function current() {\n    return this.match[0];\n  };\n\n  StringMatchIterator.prototype.moveNext = function moveNext() {\n    return !!(this.match = this.pattern.exec(this.source));\n  };\n\n  /**\n   * Creates a {@link Sequence} comprising all of the substrings of this string\n   * separated by the given delimiter, which can be either a string or a regular\n   * expression.\n   *\n   * @public\n   * @param {string|RegExp} delimiter The delimiter to use for recognizing\n   *     substrings.\n   * @returns {Sequence} A sequence of all the substrings separated by the given\n   *     delimiter.\n   *\n   * @examples\n   * Lazy(\"foo\").split(\"\")                      // sequence: [\"f\", \"o\", \"o\"]\n   * Lazy(\"yo dawg\").split(\" \")                 // sequence: [\"yo\", \"dawg\"]\n   * Lazy(\"bah bah\\tblack  sheep\").split(/\\s+/) // sequence: [\"bah\", \"bah\", \"black\", \"sheep\"]\n   */\n  StringLikeSequence.prototype.split = function split(delimiter) {\n    return new SplitStringSequence(this, delimiter);\n  };\n\n  /**\n   * @constructor\n   */\n  function SplitStringSequence(parent, pattern) {\n    this.parent = parent;\n    this.pattern = pattern;\n  }\n\n  SplitStringSequence.prototype = new Sequence();\n\n  SplitStringSequence.prototype.getIterator = function getIterator() {\n    var source = this.parent.toString();\n\n    if (this.pattern instanceof RegExp) {\n      if (this.pattern.source === \"\" || this.pattern.source === \"(?:)\") {\n        return new CharIterator(source);\n      } else {\n        return new SplitWithRegExpIterator(source, this.pattern);\n      }\n    } else if (this.pattern === \"\") {\n      return new CharIterator(source);\n    } else {\n      return new SplitWithStringIterator(source, this.pattern);\n    }\n  };\n\n  /**\n   * @constructor\n   */\n  function SplitWithRegExpIterator(source, pattern) {\n    this.source  = source;\n    this.pattern = cloneRegex(pattern);\n  }\n\n  SplitWithRegExpIterator.prototype.current = function current() {\n    return this.source.substring(this.start, this.end);\n  };\n\n  SplitWithRegExpIterator.prototype.moveNext = function moveNext() {\n    if (!this.pattern) {\n      return false;\n    }\n\n    var match = this.pattern.exec(this.source);\n\n    if (match) {\n      this.start = this.nextStart ? this.nextStart : 0;\n      this.end = match.index;\n      this.nextStart = match.index + match[0].length;\n      return true;\n\n    } else if (this.pattern) {\n      this.start = this.nextStart;\n      this.end = undefined;\n      this.nextStart = undefined;\n      this.pattern = undefined;\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * @constructor\n   */\n  function SplitWithStringIterator(source, delimiter) {\n    this.source = source;\n    this.delimiter = delimiter;\n  }\n\n  SplitWithStringIterator.prototype.current = function current() {\n    return this.source.substring(this.leftIndex, this.rightIndex);\n  };\n\n  SplitWithStringIterator.prototype.moveNext = function moveNext() {\n    if (!this.finished) {\n      this.leftIndex = typeof this.leftIndex !== \"undefined\" ?\n        this.rightIndex + this.delimiter.length :\n        0;\n      this.rightIndex = this.source.indexOf(this.delimiter, this.leftIndex);\n    }\n\n    if (this.rightIndex === -1) {\n      this.finished = true;\n      this.rightIndex = undefined;\n      return true;\n    }\n\n    return !this.finished;\n  };\n\n  /**\n   * Wraps a string exposing {@link #match} and {@link #split} methods that return\n   * {@link Sequence} objects instead of arrays, improving on the efficiency of\n   * JavaScript's built-in `String#split` and `String.match` methods and\n   * supporting asynchronous iteration.\n   *\n   * @param {string} source The string to wrap.\n   * @constructor\n   */\n  function StringWrapper(source) {\n    this.source = source;\n  }\n\n  StringWrapper.prototype = new StringLikeSequence();\n\n  StringWrapper.prototype.root = function root() {\n    return this;\n  };\n\n  StringWrapper.prototype.isAsync = function isAsync() {\n    return false;\n  };\n\n  StringWrapper.prototype.get = function get(i) {\n    return this.source.charAt(i);\n  };\n\n  StringWrapper.prototype.length = function length() {\n    return this.source.length;\n  };\n\n  StringWrapper.prototype.toString = function toString() {\n    return this.source;\n  };\n\n  /**\n   * A `GeneratedSequence` does not wrap an in-memory collection but rather\n   * determines its elements on-the-fly during iteration according to a generator\n   * function.\n   *\n   * You create a `GeneratedSequence` by calling {@link Lazy.generate}.\n   *\n   * @public\n   * @constructor\n   * @param {function(number):*} generatorFn A function which accepts an index\n   *     and returns a value for the element at that position in the sequence.\n   * @param {number=} length The length of the sequence. If this argument is\n   *     omitted, the sequence will go on forever.\n   */\n  function GeneratedSequence(generatorFn, length) {\n    this.get = generatorFn;\n    this.fixedLength = length;\n  }\n\n  GeneratedSequence.prototype = new Sequence();\n\n  GeneratedSequence.prototype.isAsync = function isAsync() {\n    return false;\n  };\n\n  /**\n   * Returns the length of this sequence.\n   *\n   * @public\n   * @returns {number} The length, or `undefined` if this is an indefinite\n   *     sequence.\n   */\n  GeneratedSequence.prototype.length = function length() {\n    return this.fixedLength;\n  };\n\n  /**\n   * Iterates over the sequence produced by invoking this sequence's generator\n   * function up to its specified length, or, if length is `undefined`,\n   * indefinitely (in which case the sequence will go on forever--you would need\n   * to call, e.g., {@link Sequence#take} to limit iteration).\n   *\n   * @public\n   * @param {Function} fn The function to call on each output from the generator\n   *     function.\n   */\n  GeneratedSequence.prototype.each = function each(fn) {\n    var generatorFn = this.get,\n        length = this.fixedLength,\n        i = 0;\n\n    while (typeof length === \"undefined\" || i < length) {\n      if (fn(generatorFn(i), i++) === false) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  GeneratedSequence.prototype.getIterator = function getIterator() {\n    return new GeneratedIterator(this);\n  };\n\n  /**\n   * Iterates over a generated sequence. (This allows generated sequences to be\n   * iterated asynchronously.)\n   *\n   * @param {GeneratedSequence} sequence The generated sequence to iterate over.\n   * @constructor\n   */\n  function GeneratedIterator(sequence) {\n    this.sequence     = sequence;\n    this.index        = 0;\n    this.currentValue = null;\n  }\n\n  GeneratedIterator.prototype.current = function current() {\n    return this.currentValue;\n  };\n\n  GeneratedIterator.prototype.moveNext = function moveNext() {\n    var sequence = this.sequence;\n\n    if (typeof sequence.fixedLength === \"number\" && this.index >= sequence.fixedLength) {\n      return false;\n    }\n\n    this.currentValue = sequence.get(this.index++);\n    return true;\n  };\n\n  /**\n   * An `AsyncSequence` iterates over its elements asynchronously when\n   * {@link #each} is called.\n   *\n   * You get an `AsyncSequence` by calling {@link Sequence#async} on any\n   * sequence. Note that some sequence types may not support asynchronous\n   * iteration.\n   *\n   * Returning values\n   * ----------------\n   *\n   * Because of its asynchronous nature, an `AsyncSequence` cannot be used in the\n   * same way as other sequences for functions that return values directly (e.g.,\n   * `reduce`, `max`, `any`, even `toArray`).\n   *\n   * Instead, these methods return an `AsyncHandle` whose `onComplete` method\n   * accepts a callback that will be called with the final result once iteration\n   * has finished.\n   *\n   * Defining custom asynchronous sequences\n   * --------------------------------------\n   *\n   * There are plenty of ways to define an asynchronous sequence. Here's one.\n   *\n   * 1. First, implement an {@link Iterator}. This is an object whose prototype\n   *    has the methods {@link Iterator#moveNext} (which returns a `boolean`) and\n   *    {@link current} (which returns the current value).\n   * 2. Next, create a simple wrapper that inherits from `AsyncSequence`, whose\n   *    `getIterator` function returns an instance of the iterator type you just\n   *    defined.\n   *\n   * The default implementation for {@link #each} on an `AsyncSequence` is to\n   * create an iterator and then asynchronously call {@link Iterator#moveNext}\n   * (using `setImmediate`, if available, otherwise `setTimeout`) until the iterator\n   * can't move ahead any more.\n   *\n   * @public\n   * @constructor\n   * @param {Sequence} parent A {@link Sequence} to wrap, to expose asynchronous\n   *     iteration.\n   * @param {number=} interval How many milliseconds should elapse between each\n   *     element when iterating over this sequence. If this argument is omitted,\n   *     asynchronous iteration will be executed as fast as possible.\n   */\n  function AsyncSequence(parent, interval) {\n    if (parent instanceof AsyncSequence) {\n      throw new Error(\"Sequence is already asynchronous!\");\n    }\n\n    this.parent         = parent;\n    this.interval       = interval;\n    this.onNextCallback = getOnNextCallback(interval);\n    this.cancelCallback = getCancelCallback(interval);\n  }\n\n  AsyncSequence.prototype = new Sequence();\n\n  AsyncSequence.prototype.isAsync = function isAsync() {\n    return true;\n  };\n\n  /**\n   * Throws an exception. You cannot manually iterate over an asynchronous\n   * sequence.\n   *\n   * @public\n   * @example\n   * Lazy([1, 2, 3]).async().getIterator() // throws\n   */\n  AsyncSequence.prototype.getIterator = function getIterator() {\n    throw new Error('An AsyncSequence does not support synchronous iteration.');\n  };\n\n  /**\n   * An asynchronous version of {@link Sequence#each}.\n   *\n   * @public\n   * @param {Function} fn The function to invoke asynchronously on each element in\n   *     the sequence one by one.\n   * @returns {AsyncHandle} An {@link AsyncHandle} providing the ability to\n   *     cancel the asynchronous iteration (by calling `cancel()`) as well as\n   *     supply callback(s) for when an error is encountered (`onError`) or when\n   *     iteration is complete (`onComplete`).\n   */\n  AsyncSequence.prototype.each = function each(fn) {\n    var iterator = this.parent.getIterator(),\n        onNextCallback = this.onNextCallback,\n        cancelCallback = this.cancelCallback,\n        i = 0;\n\n    var handle = new AsyncHandle(function cancel() {\n      if (cancellationId) {\n        cancelCallback(cancellationId);\n      }\n    });\n\n    var cancellationId = onNextCallback(function iterate() {\n      cancellationId = null;\n\n      try {\n        if (iterator.moveNext() && fn(iterator.current(), i++) !== false) {\n          cancellationId = onNextCallback(iterate);\n\n        } else {\n          handle._resolve();\n        }\n\n      } catch (e) {\n        handle._reject(e);\n      }\n    });\n\n    return handle;\n  };\n\n  /**\n   * An `AsyncHandle` provides a [Promises/A+](http://promises-aplus.github.io/promises-spec/)\n   * compliant interface for an {@link AsyncSequence} that is currently (or was)\n   * iterating over its elements.\n   *\n   * In addition to behaving as a promise, an `AsyncHandle` provides the ability\n   * to {@link AsyncHandle#cancel} iteration (if `cancelFn` is provided)\n   * and also offers convenient {@link AsyncHandle#onComplete} and\n   * {@link AsyncHandle#onError} methods to attach listeners for when iteration\n   * is complete or an error is thrown during iteration.\n   *\n   * @public\n   * @param {Function} cancelFn A function to cancel asynchronous iteration.\n   *     This is passed in to support different cancellation mechanisms for\n   *     different forms of asynchronous sequences (e.g., timeout-based\n   *     sequences, sequences based on I/O, etc.).\n   * @constructor\n   *\n   * @example\n   * // Create a sequence of 100,000 random numbers, in chunks of 100.\n   * var sequence = Lazy.generate(Math.random)\n   *   .chunk(100)\n   *   .async()\n   *   .take(1000);\n   *\n   * // Reduce-style operations -- i.e., operations that return a *value* (as\n   * // opposed to a *sequence*) -- return an AsyncHandle for async sequences.\n   * var handle = sequence.toArray();\n   *\n   * handle.onComplete(function(array) {\n   *   // Do something w/ 1,000-element array.\n   * });\n   *\n   * // Since an AsyncHandle is a promise, you can also use it to create\n   * // subsequent promises using `then` (see the Promises/A+ spec for more\n   * // info).\n   * var flattened = handle.then(function(array) {\n   *   return Lazy(array).flatten();\n   * });\n   */\n  function AsyncHandle(cancelFn) {\n    this.resolveListeners = [];\n    this.rejectListeners = [];\n    this.state = PENDING;\n    this.cancelFn = cancelFn;\n  }\n\n  // Async handle states\n  var PENDING  = 1,\n      RESOLVED = 2,\n      REJECTED = 3;\n\n  AsyncHandle.prototype.then = function then(onFulfilled, onRejected) {\n    var promise = new AsyncHandle(this.cancelFn);\n\n    this.resolveListeners.push(function(value) {\n      try {\n        if (typeof onFulfilled !== 'function') {\n          resolve(promise, value);\n          return;\n        }\n\n        resolve(promise, onFulfilled(value));\n\n      } catch (e) {\n        promise._reject(e);\n      }\n    });\n\n    this.rejectListeners.push(function(reason) {\n      try {\n        if (typeof onRejected !== 'function') {\n          promise._reject(reason);\n          return;\n        }\n\n        resolve(promise, onRejected(reason));\n\n      } catch (e) {\n        promise._reject(e);\n      }\n    });\n\n    if (this.state === RESOLVED) {\n      this._resolve(this.value);\n    }\n\n    if (this.state === REJECTED) {\n      this._reject(this.reason);\n    }\n\n    return promise;\n  };\n\n  AsyncHandle.prototype._resolve = function _resolve(value) {\n    if (this.state === REJECTED) {\n      return;\n    }\n\n    if (this.state === PENDING) {\n      this.state = RESOLVED;\n      this.value = value;\n    }\n\n    consumeListeners(this.resolveListeners, this.value);\n  };\n\n  AsyncHandle.prototype._reject = function _reject(reason) {\n    if (this.state === RESOLVED) {\n      return;\n    }\n\n    if (this.state === PENDING) {\n      this.state = REJECTED;\n      this.reason = reason;\n    }\n\n    consumeListeners(this.rejectListeners, this.reason);\n  };\n\n  /**\n   * Cancels asynchronous iteration.\n   *\n   * @public\n   */\n  AsyncHandle.prototype.cancel = function cancel() {\n    if (this.cancelFn) {\n      this.cancelFn();\n      this.cancelFn = null;\n      this._resolve(false);\n    }\n  };\n\n  /**\n   * Updates the handle with a callback to execute when iteration is completed.\n   *\n   * @public\n   * @param {Function} callback The function to call when the asynchronous\n   *     iteration is completed.\n   * @return {AsyncHandle} A reference to the handle (for chaining).\n   */\n  AsyncHandle.prototype.onComplete = function onComplete(callback) {\n    this.resolveListeners.push(callback);\n    return this;\n  };\n\n  /**\n   * Updates the handle with a callback to execute if/when any error is\n   * encountered during asynchronous iteration.\n   *\n   * @public\n   * @param {Function} callback The function to call, with any associated error\n   *     object, when an error occurs.\n   * @return {AsyncHandle} A reference to the handle (for chaining).\n   */\n  AsyncHandle.prototype.onError = function onError(callback) {\n    this.rejectListeners.push(callback);\n    return this;\n  };\n\n  /**\n   * Promise resolution procedure:\n   * http://promises-aplus.github.io/promises-spec/#the_promise_resolution_procedure\n   */\n  function resolve(promise, x) {\n    if (promise === x) {\n      promise._reject(new TypeError('Cannot resolve a promise to itself'));\n      return;\n    }\n\n    if (x instanceof AsyncHandle) {\n      x.then(\n        function(value) { resolve(promise, value); },\n        function(reason) { promise._reject(reason); }\n      );\n      return;\n    }\n\n    var then;\n    try {\n      then = (/function|object/).test(typeof x) && x != null && x.then;\n    } catch (e) {\n      promise._reject(e);\n      return;\n    }\n\n    var thenableState = PENDING;\n    if (typeof then === 'function') {\n      try {\n        then.call(\n          x,\n          function resolvePromise(value) {\n            if (thenableState !== PENDING) {\n              return;\n            }\n            thenableState = RESOLVED;\n            resolve(promise, value);\n          },\n          function rejectPromise(reason) {\n            if (thenableState !== PENDING) {\n              return;\n            }\n            thenableState = REJECTED;\n            promise._reject(reason);\n          }\n        );\n      } catch (e) {\n        if (thenableState !== PENDING) {\n          return;\n        }\n\n        promise._reject(e);\n      }\n\n      return;\n    }\n\n    promise._resolve(x);\n  }\n\n  function consumeListeners(listeners, value, callback) {\n    callback || (callback = getOnNextCallback());\n\n    callback(function() {\n      if (listeners.length > 0) {\n        listeners.shift()(value);\n        consumeListeners(listeners, value, callback);\n      }\n    });\n  }\n\n  function getOnNextCallback(interval) {\n    if (typeof interval === \"undefined\") {\n      if (typeof setImmediate === \"function\") {\n        return setImmediate;\n      }\n    }\n\n    interval = interval || 0;\n    return function(fn) {\n      return setTimeout(fn, interval);\n    };\n  }\n\n  function getCancelCallback(interval) {\n    if (typeof interval === \"undefined\") {\n      if (typeof clearImmediate === \"function\") {\n        return clearImmediate;\n      }\n    }\n\n    return clearTimeout;\n  }\n\n  /**\n   * Transform a value, whether the value is retrieved asynchronously or directly.\n   *\n   * @private\n   * @param {Function} fn The function that transforms the value.\n   * @param {*} value The value to be transformed. This can be an {@link AsyncHandle} when the value\n   *     is retrieved asynchronously, otherwise it can be anything.\n   * @returns {*} An {@link AsyncHandle} when `value` is also an {@link AsyncHandle}, otherwise\n   *     whatever `fn` resulted in.\n   */\n  function transform(fn, value) {\n    if (value instanceof AsyncHandle) {\n      return value.then(function() { fn(value); });\n    }\n    return fn(value);\n  }\n\n  /**\n   * An async version of {@link Sequence#reverse}.\n   */\n  AsyncSequence.prototype.reverse = function reverse() {\n    return this.parent.reverse().async();\n  };\n\n  /**\n   * A version of {@link Sequence#find} which returns an {@link AsyncHandle}.\n   *\n   * @public\n   * @param {Function} predicate A function to call on (potentially) every element\n   *     in the sequence.\n   * @returns {AsyncHandle} An {@link AsyncHandle} (promise) which resolves to\n   *     the found element, once it is detected, or else `undefined`.\n   */\n  AsyncSequence.prototype.find = function find(predicate) {\n    var found;\n\n    var handle = this.each(function(e, i) {\n      if (predicate(e, i)) {\n        found = e;\n        return false;\n      }\n    });\n\n    return handle.then(function() { return found; });\n  };\n\n  /**\n   * A version of {@link Sequence#indexOf} which returns an {@link AsyncHandle}.\n   *\n   * @public\n   * @param {*} value The element to search for in the sequence.\n   * @returns {AsyncHandle} An {@link AsyncHandle} (promise) which resolves to\n   *     the found index, once it is detected, or -1.\n   */\n  AsyncSequence.prototype.indexOf = function indexOf(value) {\n    var foundIndex = -1;\n\n    var handle = this.each(function(e, i) {\n      if (e === value) {\n        foundIndex = i;\n        return false;\n      }\n    });\n\n    return handle.then(function() {\n      return foundIndex;\n    });\n  };\n\n  /**\n   * A version of {@link Sequence#contains} which returns an {@link AsyncHandle}.\n   *\n   * @public\n   * @param {*} value The element to search for in the sequence.\n   * @returns {AsyncHandle} An {@link AsyncHandle} (promise) which resolves to\n   *     either `true` or `false` to indicate whether the element was found.\n   */\n  AsyncSequence.prototype.contains = function contains(value) {\n    var found = false;\n\n    var handle = this.each(function(e) {\n      if (e === value) {\n        found = true;\n        return false;\n      }\n    });\n\n    return handle.then(function() {\n      return found;\n    });\n  };\n\n  /**\n   * Just return the same sequence for `AsyncSequence#async` (I see no harm in this).\n   */\n  AsyncSequence.prototype.async = function async() {\n    return this;\n  };\n\n  /**\n   * See {@link ObjectLikeSequence#watch} for docs.\n   */\n  ObjectWrapper.prototype.watch = function watch(propertyNames) {\n    return new WatchedPropertySequence(this.source, propertyNames);\n  };\n\n  function WatchedPropertySequence(object, propertyNames) {\n    this.listeners = [];\n\n    if (!propertyNames) {\n      propertyNames = Lazy(object).keys().toArray();\n    } else if (!(propertyNames instanceof Array)) {\n      propertyNames = [propertyNames];\n    }\n\n    var listeners = this.listeners,\n        index     = 0;\n\n    Lazy(propertyNames).each(function(propertyName) {\n      var propertyValue = object[propertyName];\n\n      Object.defineProperty(object, propertyName, {\n        get: function() {\n          return propertyValue;\n        },\n\n        set: function(value) {\n          for (var i = listeners.length - 1; i >= 0; --i) {\n            if (listeners[i]({ property: propertyName, value: value }, index) === false) {\n              listeners.splice(i, 1);\n            }\n          }\n          propertyValue = value;\n          ++index;\n        }\n      });\n    });\n  }\n\n  WatchedPropertySequence.prototype = new AsyncSequence();\n\n  WatchedPropertySequence.prototype.each = function each(fn) {\n    this.listeners.push(fn);\n  };\n\n  /**\n   * A StreamLikeSequence comprises a sequence of 'chunks' of data, which are\n   * typically multiline strings.\n   *\n   * @constructor\n   */\n  function StreamLikeSequence() {}\n\n  StreamLikeSequence.prototype = new AsyncSequence();\n\n  StreamLikeSequence.prototype.isAsync = function isAsync() {\n    return true;\n  };\n\n  StreamLikeSequence.prototype.split = function split(delimiter) {\n    return new SplitStreamSequence(this, delimiter);\n  };\n\n  /**\n   * @constructor\n   */\n  function SplitStreamSequence(parent, delimiter) {\n    this.parent    = parent;\n    this.delimiter = delimiter;\n    this.each      = this.getEachForDelimiter(delimiter);\n  }\n\n  SplitStreamSequence.prototype = new Sequence();\n\n  SplitStreamSequence.prototype.getEachForDelimiter = function getEachForDelimiter(delimiter) {\n    if (delimiter instanceof RegExp) {\n      return this.regexEach;\n    }\n\n    return this.stringEach;\n  };\n\n  SplitStreamSequence.prototype.regexEach = function each(fn) {\n    var delimiter = cloneRegex(this.delimiter),\n        buffer = '',\n        start = 0, end,\n        index = 0;\n\n    var handle = this.parent.each(function(chunk) {\n      buffer += chunk;\n\n      var match;\n      while (match = delimiter.exec(buffer)) {\n        end = match.index;\n        if (fn(buffer.substring(start, end), index++) === false) {\n          return false;\n        }\n        start = end + match[0].length;\n      }\n\n      buffer = buffer.substring(start);\n      start = 0;\n    });\n\n    handle.onComplete(function() {\n      if (buffer.length > 0) {\n        fn(buffer, index++);\n      }\n    });\n\n    return handle;\n  };\n\n  SplitStreamSequence.prototype.stringEach = function each(fn) {\n    var delimiter  = this.delimiter,\n        pieceIndex = 0,\n        buffer = '',\n        bufferIndex = 0;\n\n    var handle = this.parent.each(function(chunk) {\n      buffer += chunk;\n      var delimiterIndex;\n      while ((delimiterIndex = buffer.indexOf(delimiter)) >= 0) {\n        var piece = buffer.substr(0,delimiterIndex);\n        buffer = buffer.substr(delimiterIndex+delimiter.length);\n        if (fn(piece,pieceIndex++) === false) {\n          return false;\n        }\n      }\n      return true;\n    });\n\n    handle.onComplete(function() {\n      fn(buffer, pieceIndex++);\n    });\n\n    return handle;\n  };\n\n  StreamLikeSequence.prototype.lines = function lines() {\n    return this.split(\"\\n\");\n  };\n\n  StreamLikeSequence.prototype.match = function match(pattern) {\n    return new MatchedStreamSequence(this, pattern);\n  };\n\n  /**\n   * @constructor\n   */\n  function MatchedStreamSequence(parent, pattern) {\n    this.parent  = parent;\n    this.pattern = cloneRegex(pattern);\n  }\n\n  MatchedStreamSequence.prototype = new AsyncSequence();\n\n  MatchedStreamSequence.prototype.each = function each(fn) {\n    var pattern = this.pattern,\n        done      = false,\n        i         = 0;\n\n    return this.parent.each(function(chunk) {\n      Lazy(chunk).match(pattern).each(function(match) {\n        if (fn(match, i++) === false) {\n          done = true;\n          return false;\n        }\n      });\n\n      return !done;\n    });\n  };\n\n  /**\n   * Defines a wrapper for custom {@link StreamLikeSequence}s. This is useful\n   * if you want a way to handle a stream of events as a sequence, but you can't\n   * use Lazy's existing interface (i.e., you're wrapping an object from a\n   * library with its own custom events).\n   *\n   * This method defines a *factory*: that is, it produces a function that can\n   * be used to wrap objects and return a {@link Sequence}. Hopefully the\n   * example will make this clear.\n   *\n   * @public\n   * @param {Function} initializer An initialization function called on objects\n   *     created by this factory. `this` will be bound to the created object,\n   *     which is an instance of {@link StreamLikeSequence}. Use `emit` to\n   *     generate data for the sequence.\n   * @returns {Function} A function that creates a new {@link StreamLikeSequence},\n   *     initializes it using the specified function, and returns it.\n   *\n   * @example\n   * var factory = Lazy.createWrapper(function(eventSource) {\n   *   var sequence = this;\n   *\n   *   eventSource.handleEvent(function(data) {\n   *     sequence.emit(data);\n   *   });\n   * });\n   *\n   * var eventEmitter = {\n   *   triggerEvent: function(data) {\n   *     eventEmitter.eventHandler(data);\n   *   },\n   *   handleEvent: function(handler) {\n   *     eventEmitter.eventHandler = handler;\n   *   },\n   *   eventHandler: function() {}\n   * };\n   *\n   * var events = [];\n   *\n   * factory(eventEmitter).each(function(e) {\n   *   events.push(e);\n   * });\n   *\n   * eventEmitter.triggerEvent('foo');\n   * eventEmitter.triggerEvent('bar');\n   *\n   * events // => ['foo', 'bar']\n   */\n  Lazy.createWrapper = function createWrapper(initializer) {\n    var ctor = function() {\n      this.listeners = [];\n    };\n\n    ctor.prototype = new StreamLikeSequence();\n\n    ctor.prototype.each = function(listener) {\n      this.listeners.push(listener);\n    };\n\n    ctor.prototype.emit = function(data) {\n      var listeners = this.listeners;\n\n      for (var len = listeners.length, i = len - 1; i >= 0; --i) {\n        if (listeners[i](data) === false) {\n          listeners.splice(i, 1);\n        }\n      }\n    };\n\n    return function() {\n      var sequence = new ctor();\n      initializer.apply(sequence, arguments);\n      return sequence;\n    };\n  };\n\n  /**\n   * Creates a {@link GeneratedSequence} using the specified generator function\n   * and (optionally) length.\n   *\n   * @public\n   * @param {function(number):*} generatorFn The function used to generate the\n   *     sequence. This function accepts an index as a parameter and should return\n   *     a value for that index in the resulting sequence.\n   * @param {number=} length The length of the sequence, for sequences with a\n   *     definite length.\n   * @returns {GeneratedSequence} The generated sequence.\n   *\n   * @examples\n   * var randomNumbers = Lazy.generate(Math.random);\n   * var countingNumbers = Lazy.generate(function(i) { return i + 1; }, 5);\n   *\n   * randomNumbers          // instanceof Lazy.GeneratedSequence\n   * randomNumbers.length() // => undefined\n   * countingNumbers          // sequence: [1, 2, 3, 4, 5]\n   * countingNumbers.length() // => 5\n   */\n  Lazy.generate = function generate(generatorFn, length) {\n    return new GeneratedSequence(generatorFn, length);\n  };\n\n  /**\n   * Creates a sequence from a given starting value, up to a specified stopping\n   * value, incrementing by a given step. Invalid values for any of these\n   * arguments (e.g., a step of 0) result in an empty sequence.\n   *\n   * @public\n   * @returns {GeneratedSequence} The sequence defined by the given ranges.\n   *\n   * @examples\n   * Lazy.range(3)         // sequence: [0, 1, 2]\n   * Lazy.range(1, 4)      // sequence: [1, 2, 3]\n   * Lazy.range(2, 10, 2)  // sequence: [2, 4, 6, 8]\n   * Lazy.range(5, 1, 2)   // sequence: []\n   * Lazy.range(5, 15, -2) // sequence: []\n   * Lazy.range(3, 10, 3)  // sequence: [3, 6, 9]\n   * Lazy.range(5, 2)      // sequence: [5, 4, 3]\n   * Lazy.range(7, 2, -2)  // sequence: [7, 5, 3]\n   * Lazy.range(3, 5, 0)   // sequence: []\n   */\n  Lazy.range = function range() {\n    var start = arguments.length > 1 ? arguments[0] : 0,\n        stop  = arguments.length > 1 ? arguments[1] : arguments[0],\n        step  = arguments.length > 2 && arguments[2];\n\n    if (step === false) {\n      step = stop > start ? 1 : -1;\n    }\n\n    if (step === 0) {\n      return Lazy([]);\n    }\n\n    return Lazy.generate(function(i) { return start + (step * i); })\n      .take(Math.ceil((stop - start) / step));\n  };\n\n  /**\n   * Creates a sequence consisting of the given value repeated a specified number\n   * of times.\n   *\n   * @public\n   * @param {*} value The value to repeat.\n   * @param {number=} count The number of times the value should be repeated in\n   *     the sequence. If this argument is omitted, the value will repeat forever.\n   * @returns {GeneratedSequence} The sequence containing the repeated value.\n   *\n   * @examples\n   * Lazy.repeat(\"hi\", 3)          // sequence: [\"hi\", \"hi\", \"hi\"]\n   * Lazy.repeat(\"young\")          // instanceof Lazy.GeneratedSequence\n   * Lazy.repeat(\"young\").length() // => undefined\n   * Lazy.repeat(\"young\").take(3)  // sequence: [\"young\", \"young\", \"young\"]\n   */\n  Lazy.repeat = function repeat(value, count) {\n    return Lazy.generate(function() { return value; }, count);\n  };\n\n  Lazy.Sequence           = Sequence;\n  Lazy.ArrayLikeSequence  = ArrayLikeSequence;\n  Lazy.ObjectLikeSequence = ObjectLikeSequence;\n  Lazy.StringLikeSequence = StringLikeSequence;\n  Lazy.StreamLikeSequence = StreamLikeSequence;\n  Lazy.GeneratedSequence  = GeneratedSequence;\n  Lazy.AsyncSequence      = AsyncSequence;\n  Lazy.AsyncHandle        = AsyncHandle;\n\n  /*** Useful utility methods ***/\n\n  /**\n   * Creates a shallow copy of an array or object.\n   *\n   * @examples\n   * var array  = [1, 2, 3], clonedArray,\n   *     object = { foo: 1, bar: 2 }, clonedObject;\n   *\n   * clonedArray = Lazy.clone(array); // => [1, 2, 3]\n   * clonedArray.push(4); // clonedArray == [1, 2, 3, 4]\n   * array; // => [1, 2, 3]\n   *\n   * clonedObject = Lazy.clone(object); // => { foo: 1, bar: 2 }\n   * clonedObject.baz = 3; // clonedObject == { foo: 1, bar: 2, baz: 3 }\n   * object; // => { foo: 1, bar: 2 }\n   */\n  Lazy.clone = function clone(target) {\n    return Lazy(target).value();\n  };\n\n  /**\n   * Marks a method as deprecated, so calling it will issue a console warning.\n   */\n  Lazy.deprecate = function deprecate(message, fn) {\n    return function() {\n      console.warn(message);\n      return fn.apply(this, arguments);\n    };\n  };\n\n  var arrayPop   = Array.prototype.pop,\n      arraySlice = Array.prototype.slice;\n\n  /**\n   * Creates a callback... you know, Lo-Dash style.\n   *\n   * - for functions, just returns the function\n   * - for strings, returns a pluck-style callback\n   * - for objects, returns a where-style callback\n   *\n   * @private\n   * @param {Function|string|Object} callback A function, string, or object to\n   *     convert to a callback.\n   * @param {*} defaultReturn If the callback is undefined, a default return\n   *     value to use for the function.\n   * @returns {Function} The callback function.\n   *\n   * @examples\n   * createCallback(function() {})                  // instanceof Function\n   * createCallback('foo')                          // instanceof Function\n   * createCallback('foo')({ foo: 'bar'})           // => 'bar'\n   * createCallback({ foo: 'bar' })({ foo: 'bar' }) // => true\n   * createCallback({ foo: 'bar' })({ foo: 'baz' }) // => false\n   */\n  function createCallback(callback, defaultValue) {\n    switch (typeof callback) {\n      case \"function\":\n        return callback;\n\n      case \"string\":\n        return function(e) {\n          return e[callback];\n        };\n\n      case \"object\":\n        return function(e) {\n          return Lazy(callback).all(function(value, key) {\n            return e[key] === value;\n          });\n        };\n\n      case \"undefined\":\n        return defaultValue ?\n          function() { return defaultValue; } :\n          Lazy.identity;\n\n      default:\n        throw new Error(\"Don't know how to make a callback from a \" + typeof callback + \"!\");\n    }\n  }\n\n  /**\n   * Takes a function that returns a value for one argument and produces a\n   * function that compares two arguments.\n   *\n   * @private\n   * @param {Function|string|Object} callback A function, string, or object to\n   *     convert to a callback using `createCallback`.\n   * @returns {Function} A function that accepts two values and returns 1 if\n   *     the first is greater, -1 if the second is greater, or 0 if they are\n   *     equivalent.\n   *\n   * @examples\n   * createComparator('a')({ a: 1 }, { a: 2 });       // => -1\n   * createComparator('a')({ a: 6 }, { a: 2 });       // => 1\n   * createComparator('a')({ a: 1 }, { a: 1 });       // => 0\n   * createComparator()(3, 5);                        // => -1\n   * createComparator()(7, 5);                        // => 1\n   * createComparator()(3, 3);                        // => 0\n   */\n  function createComparator(callback, descending) {\n    if (!callback) { return compare; }\n\n    callback = createCallback(callback);\n\n    return function(x, y) {\n      return compare(callback(x), callback(y));\n    };\n  }\n\n  /**\n   * Takes a function and returns a function with the same logic but the\n   * arguments reversed. Only applies to functions w/ arity=2 as this is private\n   * and I can do what I want.\n   *\n   * @private\n   * @param {Function} fn The function to \"reverse\"\n   * @returns {Function} The \"reversed\" function\n   *\n   * @examples\n   * reverseArguments(function(x, y) { return x + y; })('a', 'b'); // => 'ba'\n   */\n  function reverseArguments(fn) {\n    return function(x, y) { return fn(y, x); };\n  }\n\n  /**\n   * Creates a Set containing the specified values.\n   *\n   * @param {...Array} values One or more array(s) of values used to populate the\n   *     set.\n   * @returns {Set} A new set containing the values passed in.\n   */\n  function createSet(values) {\n    var set = new Set();\n    Lazy(values || []).flatten().each(function(e) {\n      set.add(e);\n    });\n    return set;\n  }\n\n  /**\n   * Compares two elements for sorting purposes.\n   *\n   * @private\n   * @param {*} x The left element to compare.\n   * @param {*} y The right element to compare.\n   * @returns {number} 1 if x > y, -1 if x < y, or 0 if x and y are equal.\n   *\n   * @examples\n   * compare(1, 2)     // => -1\n   * compare(1, 1)     // => 0\n   * compare(2, 1)     // => 1\n   * compare('a', 'b') // => -1\n   */\n  function compare(x, y) {\n    if (x === y) {\n      return 0;\n    }\n\n    return x > y ? 1 : -1;\n  }\n\n  /**\n   * Iterates over every element in an array.\n   *\n   * @param {Array} array The array.\n   * @param {Function} fn The function to call on every element, which can return\n   *     false to stop the iteration early.\n   * @returns {boolean} True if every element in the entire sequence was iterated,\n   *     otherwise false.\n   */\n  function forEach(array, fn) {\n    var i = -1,\n        len = array.length;\n\n    while (++i < len) {\n      if (fn(array[i], i) === false) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function getFirst(sequence) {\n    var result;\n    sequence.each(function(e) {\n      result = e;\n      return false;\n    });\n    return result;\n  }\n\n  /**\n   * Checks if an element exists in an array.\n   *\n   * @private\n   * @param {Array} array\n   * @param {*} element\n   * @returns {boolean} Whether or not the element exists in the array.\n   *\n   * @examples\n   * arrayContains([1, 2], 2)              // => true\n   * arrayContains([1, 2], 3)              // => false\n   * arrayContains([undefined], undefined) // => true\n   * arrayContains([NaN], NaN)             // => true\n   */\n  function arrayContains(array, element) {\n    var i = -1,\n        length = array.length;\n\n    // Special handling for NaN\n    if (element !== element) {\n      while (++i < length) {\n        if (array[i] !== array[i]) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    while (++i < length) {\n      if (array[i] === element) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Checks if an element exists in an array before a given index.\n   *\n   * @private\n   * @param {Array} array\n   * @param {*} element\n   * @param {number} index\n   * @param {Function} keyFn\n   * @returns {boolean}\n   *\n   * @examples\n   * arrayContainsBefore([1, 2, 3], 3, 2) // => false\n   * arrayContainsBefore([1, 2, 3], 3, 3) // => true\n   */\n  function arrayContainsBefore(array, element, index, keyFn) {\n    var i = -1;\n\n    if (keyFn) {\n      keyFn = createCallback(keyFn);\n      while (++i < index) {\n        if (keyFn(array[i]) === keyFn(element)) {\n          return true;\n        }\n      }\n\n    } else {\n      while (++i < index) {\n        if (array[i] === element) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Swaps the elements at two specified positions of an array.\n   *\n   * @private\n   * @param {Array} array\n   * @param {number} i\n   * @param {number} j\n   *\n   * @examples\n   * var array = [1, 2, 3, 4, 5];\n   *\n   * swap(array, 2, 3) // array == [1, 2, 4, 3, 5]\n   */\n  function swap(array, i, j) {\n    var temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n  }\n\n  /**\n   * \"Clones\" a regular expression, but ensures it is always global.\n   * Will return the passed RegExp if global is already set.\n   *\n   * @private\n   * @param {RegExp|string} pattern\n   * @returns {RegExp}\n   */\n  function cloneRegex(pattern) {\n    var patternStr, lsi, flags, global;\n    if (pattern instanceof RegExp) {\n      // Just return the passed in RegExp\n      if (pattern.global)\n        return pattern;\n      patternStr = pattern.toString();\n    }\n    else {\n      patternStr = pattern;\n    }\n    lsi = patternStr.lastIndexOf(\"/\");\n    // No widespread RegExp.prototype.flags, unfortuantely;\n    // We use the string approach for both argument types!\n    flags = patternStr.substring(lsi + 1);\n    global = flags.indexOf(\"g\") >= 0 ? \"\" : \"g\";\n\n    return new RegExp(patternStr.substring(1, lsi), flags + global);\n}\n\n  /**\n   * A collection of unique elements.\n   *\n   * @private\n   * @constructor\n   *\n   * @examples\n   * var set  = new Set(),\n   *     obj1 = {},\n   *     obj2 = {},\n   *     fn1 = function fn1() {},\n   *     fn2 = function fn2() {};\n   *\n   * set.add('foo')            // => true\n   * set.add('foo')            // => false\n   * set.add(1)                // => true\n   * set.add(1)                // => false\n   * set.add('1')              // => true\n   * set.add('1')              // => false\n   * set.add(obj1)             // => true\n   * set.add(obj1)             // => false\n   * set.add(obj2)             // => true\n   * set.add(fn1)              // => true\n   * set.add(fn2)              // => true\n   * set.add(fn2)              // => false\n   * set.contains('__proto__') // => false\n   * set.add('__proto__')      // => true\n   * set.add('__proto__')      // => false\n   * set.contains('add')       // => false\n   * set.add('add')            // => true\n   * set.add('add')            // => false\n   * set.contains(undefined)   // => false\n   * set.add(undefined)        // => true\n   * set.contains(undefined)   // => true\n   * set.contains('undefined') // => false\n   * set.add('undefined')      // => true\n   * set.contains('undefined') // => true\n   * set.contains(NaN)         // => false\n   * set.add(NaN)              // => true\n   * set.contains(NaN)         // => true\n   * set.contains('NaN')       // => false\n   * set.add('NaN')            // => true\n   * set.contains('NaN')       // => true\n   * set.contains('@foo')      // => false\n   * set.add('@foo')           // => true\n   * set.contains('@foo')      // => true\n   */\n  function Set() {\n    this.table   = {};\n    this.objects = [];\n  }\n\n  /**\n   * Attempts to add a unique value to the set.\n   *\n   * @param {*} value The value to add.\n   * @returns {boolean} True if the value was added to the set (meaning an equal\n   *     value was not already present), or else false.\n   */\n  Set.prototype.add = function add(value) {\n    var table = this.table,\n        type  = typeof value,\n\n        // only applies for strings\n        firstChar,\n\n        // only applies for objects\n        objects;\n\n    switch (type) {\n      case \"number\":\n      case \"boolean\":\n      case \"undefined\":\n        if (!table[value]) {\n          table[value] = true;\n          return true;\n        }\n        return false;\n\n      case \"string\":\n        // Essentially, escape the first character if it could possibly collide\n        // with a number, boolean, or undefined (or a string that happens to start\n        // with the escape character!), OR if it could override a special property\n        // such as '__proto__' or 'constructor'.\n        switch (value.charAt(0)) {\n          case \"_\": // e.g., __proto__\n          case \"f\": // for 'false'\n          case \"t\": // for 'true'\n          case \"c\": // for 'constructor'\n          case \"u\": // for 'undefined'\n          case \"@\": // escaped\n          case \"0\":\n          case \"1\":\n          case \"2\":\n          case \"3\":\n          case \"4\":\n          case \"5\":\n          case \"6\":\n          case \"7\":\n          case \"8\":\n          case \"9\":\n          case \"N\": // for NaN\n            value = \"@\" + value;\n        }\n        if (!table[value]) {\n          table[value] = true;\n          return true;\n        }\n        return false;\n\n      default:\n        // For objects and functions, we can't really do anything other than store\n        // them in an array and do a linear search for reference equality.\n        objects = this.objects;\n        if (!arrayContains(objects, value)) {\n          objects.push(value);\n          return true;\n        }\n        return false;\n    }\n  };\n\n  /**\n   * Checks whether the set contains a value.\n   *\n   * @param {*} value The value to check for.\n   * @returns {boolean} True if the set contains the value, or else false.\n   */\n  Set.prototype.contains = function contains(value) {\n    var type = typeof value,\n\n        // only applies for strings\n        firstChar;\n\n    switch (type) {\n      case \"number\":\n      case \"boolean\":\n      case \"undefined\":\n        return !!this.table[value];\n\n      case \"string\":\n        // Essentially, escape the first character if it could possibly collide\n        // with a number, boolean, or undefined (or a string that happens to start\n        // with the escape character!), OR if it could override a special property\n        // such as '__proto__' or 'constructor'.\n        switch (value.charAt(0)) {\n          case \"_\": // e.g., __proto__\n          case \"f\": // for 'false'\n          case \"t\": // for 'true'\n          case \"c\": // for 'constructor'\n          case \"u\": // for 'undefined'\n          case \"@\": // escaped\n          case \"0\":\n          case \"1\":\n          case \"2\":\n          case \"3\":\n          case \"4\":\n          case \"5\":\n          case \"6\":\n          case \"7\":\n          case \"8\":\n          case \"9\":\n          case \"N\": // for NaN\n            value = \"@\" + value;\n        }\n        return !!this.table[value];\n\n      default:\n        // For objects and functions, we can't really do anything other than store\n        // them in an array and do a linear search for reference equality.\n        return arrayContains(this.objects, value);\n    }\n  };\n\n  /**\n   * A \"rolling\" queue, with a fixed capacity. As items are added to the head,\n   * excess items are dropped from the tail.\n   *\n   * @private\n   * @constructor\n   *\n   * @examples\n   * var queue = new Queue(3);\n   *\n   * queue.add(1).toArray()        // => [1]\n   * queue.add(2).toArray()        // => [1, 2]\n   * queue.add(3).toArray()        // => [1, 2, 3]\n   * queue.add(4).toArray()        // => [2, 3, 4]\n   * queue.add(5).add(6).toArray() // => [4, 5, 6]\n   * queue.add(7).add(8).toArray() // => [6, 7, 8]\n   *\n   * // also want to check corner cases\n   * new Queue(1).add('foo').add('bar').toArray() // => ['bar']\n   * new Queue(0).add('foo').toArray()            // => []\n   * new Queue(-1)                                // throws\n   *\n   * @benchmarks\n   * function populateQueue(count, capacity) {\n   *   var q = new Queue(capacity);\n   *   for (var i = 0; i < count; ++i) {\n   *     q.add(i);\n   *   }\n   * }\n   *\n   * function populateArray(count, capacity) {\n   *   var arr = [];\n   *   for (var i = 0; i < count; ++i) {\n   *     if (arr.length === capacity) { arr.shift(); }\n   *     arr.push(i);\n   *   }\n   * }\n   *\n   * populateQueue(100, 10); // populating a Queue\n   * populateArray(100, 10); // populating an Array\n   */\n  function Queue(capacity) {\n    this.contents = new Array(capacity);\n    this.start    = 0;\n    this.count    = 0;\n  }\n\n  /**\n   * Adds an item to the queue, and returns the queue.\n   */\n  Queue.prototype.add = function add(element) {\n    var contents = this.contents,\n        capacity = contents.length,\n        start    = this.start;\n\n    if (this.count === capacity) {\n      contents[start] = element;\n      this.start = (start + 1) % capacity;\n\n    } else {\n      contents[this.count++] = element;\n    }\n\n    return this;\n  };\n\n  /**\n   * Returns an array containing snapshot of the queue's contents.\n   */\n  Queue.prototype.toArray = function toArray() {\n    var contents = this.contents,\n        start    = this.start,\n        count    = this.count;\n\n    var snapshot = contents.slice(start, start + count);\n    if (snapshot.length < count) {\n      snapshot = snapshot.concat(contents.slice(0, count - snapshot.length));\n    }\n\n    return snapshot;\n  };\n\n  /**\n   * Shared base method for defining new sequence types.\n   */\n  function defineSequenceType(base, name, overrides) {\n    /** @constructor */\n    var ctor = function ctor() {};\n\n    // Make this type inherit from the specified base.\n    ctor.prototype = new base();\n\n    // Attach overrides to the new sequence type's prototype.\n    for (var override in overrides) {\n      ctor.prototype[override] = overrides[override];\n    }\n\n    // Define a factory method that sets the new sequence's parent to the caller\n    // and (optionally) applies any additional initialization logic.\n    // Expose this as a chainable method so that we can do:\n    // Lazy(...).map(...).filter(...).blah(...);\n    var factory = function factory() {\n      var sequence = new ctor();\n\n      // Every sequence needs a reference to its parent in order to work.\n      sequence.parent = this;\n\n      // If a custom init function was supplied, call it now.\n      if (sequence.init) {\n        sequence.init.apply(sequence, arguments);\n      }\n\n      return sequence;\n    };\n\n    var methodNames = typeof name === 'string' ? [name] : name;\n    for (var i = 0; i < methodNames.length; ++i) {\n      base.prototype[methodNames[i]] = factory;\n    }\n\n    return ctor;\n  }\n\n  return Lazy;\n});\n","import {assert, getLogger} from \"./utils\";\r\nimport iter from \"lazy.js\";\r\n\r\n/**\r\n * Generic message handling class.\r\n */\r\nexport default class MessageHandler {\r\n    constructor() {\r\n        this._handlers = this._handlers || {};\r\n        this._log = getLogger(this);\r\n        this._mergedHandlers = [];\r\n    }\r\n\r\n    listenTo(emitter) {\r\n        return iter(this._handlers)\r\n            .values()\r\n            .each(type => emitter.on(type, (...args) => this.handle(type, ...args)));\r\n    }\r\n\r\n    merge(handlerObject) {\r\n        return this._mergedHandlers.push(handlerObject);\r\n    }\r\n\r\n    registerHandlers(handlers) {\r\n        return iter(handlers)\r\n            .pairs()\r\n            .each(([type, handler]) => this.registerHandler(type, handler));\r\n    }\r\n\r\n    registerHandler(type, handler) {\r\n        return this._handlers[type] = handler;\r\n    }\r\n\r\n    handle(type, ...params) {\r\n        var handler = this._handlers[type];\r\n        this.type = type,\r\n        this.params = params;\r\n\r\n        assert(this.canHandle(type));\r\n\r\n        if (handler != null) handler.apply(this, this.params);\r\n\r\n        return iter(this._mergedHandlers)\r\n            .filter(handler => handler.canHandle(type))\r\n            .each(handler => handler.handle.apply(this, [type, ...params]));\r\n    }\r\n\r\n    canHandle(type) {\r\n        if (type in this._handlers) return true;\r\n        return this._mergedHandlers.some(handler => handler.canHandle(type));\r\n    }\r\n}\r\n","import EventEmitter from \"../utils/event_emitter\";\r\n\r\n/**\r\n * A wrapper around a webkit notification. Used to display desktop notifications.\r\n */\r\nexport default class Notification extends EventEmitter {\r\n    constructor(title, message, image) {\r\n        super();\r\n        this._title = title;\r\n        this._message = message;\r\n        this._image = image != null ? image : Notification.defaultImage;\r\n        this._createNotification();\r\n        this._addOnClickListener();\r\n        this._addOnCloseListener();\r\n    }\r\n\r\n    _createNotification() {\r\n        return this.notification = new window.Notification(this._title,\r\n            {\"body\": this._message, \"icon\": this._image});\r\n    }\r\n\r\n    _addOnClickListener() {\r\n        return this.notification.onclick = () => {\r\n            this.cancel();\r\n            return this.emit(\"clicked\");\r\n        };\r\n    }\r\n\r\n    _addOnCloseListener() {\r\n        return this.notification.onclose = () => this.emit(\"closed\");\r\n    }\r\n\r\n    /**\r\n     * Display the notification.\r\n     */\r\n    show() {\r\n        // Notifications are automatically shown.\r\n        chrome.app.window.current().drawAttention();\r\n    }\r\n\r\n    /**\r\n     * Close the notification.\r\n     */\r\n    cancel() {\r\n        if (this.notification) this.notification.close();\r\n        chrome.app.window.current().clearAttention();\r\n    }\r\n\r\n    /**\r\n     * Used as a hash function for notifications.\r\n     */\r\n    toString() {\r\n        return this._title + this._message;\r\n    }\r\n}\r\nNotification.defaultImage = \"http://sourceforge.net/p/acupofjavachat/icon\";\r\n","import MessageHandler from \"../utils/message_handler\";\r\nimport Notification from \"./notification\";\r\n\r\n/**\r\n * Special commands used to make testing easier. These commands are not\r\n *  displayed in /help.\r\n */\r\nexport default class DeveloperCommands extends MessageHandler {\r\n\r\n    /**\r\n     * Initialise the Developer Commands\r\n     * @param  {Chat} chat\r\n     */\r\n    constructor(chat) {\r\n        super(chat);\r\n        this._chat = chat;\r\n    }\r\n\r\n    _handleCommand(command, text) {\r\n        text = text || \"\";\r\n        return this._chat.userCommands(command, this.params[0], ...text.split(\" \"));\r\n    }\r\n}\r\n\r\nDeveloperCommands.prototype._handlers = {\r\n    \"test-notif\": function () {\r\n        return new Notification(\"test\", \"hi!\").show();\r\n    },\r\n    \"test-upgrade-prompt\": function() {\r\n        this._chat._promptToUpdate();\r\n    },\r\n    \"get-pw\": function () {\r\n        return this._chat.displayMessage(\r\n            \"notice\",\r\n            this.params[0].context,\r\n            `Your password is: ${this._chat.remoteConnection._password}`);\r\n    },\r\n    \"set-pw\": function (event) {\r\n        var password = event.args[0] || \"bacon\";\r\n        this._chat.storage._store(\"password\", password);\r\n        return this._chat.setPassword(password);\r\n    }\r\n};","/**\r\n * A notification used when the user's nick is mentioned.\r\n * Provides functions for determining if a nick was mentioned.\r\n */\r\nexport default class NickMentionedNotification {\r\n    /**\r\n     * Creates a notification that's used when the user's nick is mensioned.\r\n     * Provides functions for determining if a nick was mentioned.\r\n     * @param  {any} channel\r\n     * @param  {any} from\r\n     * @param  {any} message\r\n     */\r\n    constructor(channel, from, message) {\r\n        this._channel = channel;\r\n        this._from = from;\r\n        this._message = message;\r\n    }\r\n    getBody() {\r\n        return this._message;\r\n    }\r\n\r\n    getTitle() {\r\n        return `${this._from} mentioned you in ${this._channel}`;\r\n    }\r\n\r\n    /**\r\n     * When there are multiple notifications, a list of stubs is displayed from\r\n     *  each notification\r\n     */\r\n    getStub() {\r\n        return `${this._from} mentioned you`;\r\n    }\r\n    /**\r\n     * @param  {string} nick\r\n     * @param  {string} msg\r\n     */\r\n    static shouldNotify(nick, msg) {\r\n        var msgToTest;\r\n        if (nick == null) return false;\r\n        nick = this._escapeTextForRegex(nick.replace(/_+$/, \"\"));\r\n        msgToTest = this._prepMessageForRegex(msg, nick);\r\n        return /\\#nick\\#_*([!?.]*|[-:;~\\*\\u0001]?)(?!\\S)/i.test(msgToTest);\r\n    }\r\n    /**\r\n     * @param  {string} text\r\n     */\r\n    static _escapeTextForRegex(text) {\r\n        return text.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\");\r\n    }\r\n    /**\r\n     * @param  {string} msg\r\n     * @param  {string} nick\r\n     */\r\n    static _prepMessageForRegex(msg, nick) {\r\n        msg = msg.replace(/,/g, \" \");\r\n        msg = msg.replace(/\\#nick\\#/gi, \"a\");\r\n        msg = msg.replace(new RegExp(\"@\\?\" + nick, \"ig\"), \"#nick#\");\r\n        // simulate a negative lookbehind to make sure only whitespace precedes the nick\r\n        return msg.replace(/\\S\\#nick\\#/i, \"a\");\r\n    }\r\n}\r\n","import {capitalizeString} from \"../utils/utils\";\r\nimport {nicksEqual} from \"../irc/irc_util\";\r\n\r\n/**\r\n * Handles formatting and styling text to be displayed to the user.\r\n *\r\n * ###Formatting follows these ruels:\r\n * - all messages start with a capital letter\r\n * - messages from the user or to the user have the 'self' style\r\n * - messages from the user are surrounded by parentheses\r\n * - the user's nick is replaced by 'you'\r\n * - 'you is' is replaced by 'you are'\r\n * - messages not from the user end in a period\r\n */\r\nexport default class MessageFormatter {\r\n    constructor() {\r\n        this._customStyle = [];\r\n        this._nick = void 0;\r\n        this.clear();\r\n    }\r\n    /**\r\n     * Sets the user's nick name, which is used to determine if the message is from\r\n     *  or to the user. This field is not reset when clear() is called.\r\n     * @param {string} nick The user's nick name.\r\n     */\r\n    setNick(nick) {\r\n        return this._nick = nick;\r\n    }\r\n    /**\r\n     * Sets custom style to be used for all formatted messages. This field is not\r\n     *  reset when clear() is called.\r\n     * @param {string[]} customStyle The style to be set\r\n     */\r\n    setCustomStyle(customStyle) {\r\n        return this._customStyle = customStyle;\r\n    }\r\n    /**\r\n     * Clears the state of the message formatter. Used between formatting different\r\n     *  messages.\r\n     */\r\n    clear() {\r\n        this._style = [];\r\n        this._fromUs = this._toUs = false;\r\n        this._forcePrettyFormat = void 0;\r\n        return this._message = \"\";\r\n    }\r\n    /**\r\n     * Sets the message to be formatted.\r\n     * The following can be used as special literals in the message:\r\n     * - '#from' gets replaced by the the nick the message is from.\r\n     * - '#to' gets replaced by the nick the message pertains to.\r\n     * - '#content' gets replaced by content the message is about.\r\n     * @param {string} message\r\n     */\r\n    setMessage(message) {\r\n        return this._message = message;\r\n    }\r\n    /**\r\n     * Returns true if the formatter has a message to format.\r\n     * @return {boolean}\r\n     */\r\n    hasMessage() {\r\n        return !!this._message;\r\n    }\r\n    /**\r\n     * Set the context of the message.\r\n     * @param {string=} opt_from The nick the message is from.\r\n     * @param {string=} opt_to The nick the message pertains to.\r\n     * @param {string=} opt_content The context of the message.\r\n     */\r\n    setContext(opt_from, opt_to, opt_content) {\r\n        this._from = opt_from;\r\n        this._to = opt_to;\r\n        this._content = opt_content;\r\n        this._fromUs = this._isOwnNick(this._from);\r\n        return this._toUs = this._isOwnNick(this._to);\r\n    }\r\n    /**\r\n     * Set the content of the message.\r\n     * @param {string} content\r\n     */\r\n    setContent(content) {\r\n        return this._content = content;\r\n    }\r\n    /**\r\n     * Sets the content to the given string and the message to be that content.\r\n     * @param {string} content\r\n     */\r\n    setContentMessage(content) {\r\n        this.setContext(void 0, void 0, content);\r\n        this.setContent(content);\r\n        return this.setMessage(\"#content\");\r\n    }\r\n    /**\r\n     * Set whether the message is from the user or not.\r\n     * By default the message is assumed from the user if their nick matches the\r\n     * from field.\r\n     * This is useful for the /nick message, when the user's nick has just changed.\r\n     * @param {boolean} formUs True if the message is from the user\r\n     */\r\n    setFromUs(fromUs) {\r\n        return this._fromUs = fromUs;\r\n    }\r\n    /**\r\n     * Set whether the message pertains to the user or not.\r\n     * By default the message is assumed to pertain to the user if their nick\r\n     *  matches the to field.\r\n     * This is useful for the /nick message, when the user's nick has just changed.\r\n     * @param {boolean} toUs True if the message is to the user\r\n     */\r\n    setToUs(toUs) {\r\n        return this._toUs = toUs;\r\n    }\r\n    /**\r\n     * Sets whether or not pretty formatting should be used.\r\n     * Pretty formatting includes capitalization and adding a period or adding\r\n     * perentheses.\r\n     */\r\n    setPrettyFormat(usePrettyFormat) {\r\n        return this._forcePrettyFormat = usePrettyFormat;\r\n    }\r\n\r\n    _usePrettyFormat() {\r\n        var _ref1;\r\n        return (_ref1 = this._forcePrettyFormat) != null ? _ref1 : !this.hasStyle(\"no-pretty-format\");\r\n    }\r\n    /**\r\n     * Returns a message formatted based on the given context.\r\n     * @return {string} Returns the formatted message.\r\n     */\r\n    format() {\r\n        var msg;\r\n        if (!this._message) {\r\n            return \"\";\r\n        }\r\n        msg = this._incorporateContext();\r\n        if (this._usePrettyFormat()) {\r\n            msg = this._prettyFormat(msg);\r\n        }\r\n        return msg;\r\n    }\r\n    /**\r\n     * Replaces context placeholders, such as '#to', with their corresponding\r\n     *  value.\r\n     * @return {string} Returns the formatted message.\r\n     */\r\n    _incorporateContext() {\r\n        var msg;\r\n        msg = this._message;\r\n        msg = this._fixGrammer(\"#from\", msg);\r\n        msg = msg.replace(\"#from\", this._fromUs ? \"you\" : this._escapeDollarSign(this._from));\r\n        msg = msg.replace(\"#to\", this._toUs ? \"you\" : this._escapeDollarSign(this._to));\r\n        return msg.replace(\"#content\", this._escapeDollarSign(this._content));\r\n    }\r\n    /**\r\n     * Escapes dollar signs in text so that they are not interpreted when doing\r\n     * string replacements.\r\n     * @return {string} Returns the escaped string\r\n     */\r\n    _escapeDollarSign(text) {\r\n        if (text) {\r\n            return text.replace(\"$\", \"$$$$\");\r\n        } else {\r\n            return text;\r\n        }\r\n    }\r\n    /**\r\n     * Handles adding periods, perentheses and capitalization.\r\n     * @return {string} Returns the formatted message.\r\n     */\r\n    _prettyFormat(msg) {\r\n        if (!this._startsWithNick(msg)) {\r\n            msg = capitalizeString(msg);\r\n        }\r\n        if (this._fromUs) {\r\n            msg = `(${msg})`;\r\n        } else if (/[a-zA-Z0-9]$/.test(msg)) {\r\n            msg = `${msg}.`;\r\n        }\r\n        return msg;\r\n    }\r\n\r\n    _fixGrammer(you, msg) {\r\n        var youPlaceholders;\r\n        youPlaceholders = [];\r\n        if (this._fromUs) {\r\n            youPlaceholders.push(\"#from\");\r\n        }\r\n        if (this._toUs) {\r\n            youPlaceholders.push(\"#to\");\r\n        }\r\n\r\n        return youPlaceholders.reduce((msg, you) => {\r\n            return msg.replace(`${you} is`, `${you} are`)\r\n                .replace(`${you} has`, `${you} have`);\r\n        }, msg);\r\n    }\r\n    /**\r\n     * Returns true if the given message starts with the nick the message pertains\r\n     * to or the nick the message is being sent from.\r\n     */\r\n    _startsWithNick(msg) {\r\n        var startsWithFromNick, startsWithToNick;\r\n        startsWithToNick = msg.indexOf(this._to) === 0 && !this._toUs;\r\n        startsWithFromNick = msg.indexOf(this._from) === 0 && !this._fromUs;\r\n        return startsWithToNick || startsWithFromNick;\r\n    }\r\n    /**\r\n     * Clears the current style and adds the given style.\r\n     * @param {string} style\r\n     */\r\n    setStyle(style) {\r\n        return this._style = [style];\r\n    }\r\n    /**\r\n     * Adds the given style.\r\n     * @param {string[]} style\r\n     */\r\n    addStyle(style) {\r\n        if (!Array.isArray(style)) {\r\n            style = [style];\r\n        }\r\n        return this._style = this._style.concat(style);\r\n    }\r\n\r\n    hasStyle(style) {\r\n        return this._customStyle.indexOf(style) >= 0 || this._style.indexOf(style) >= 0;\r\n    }\r\n    /**\r\n     * Returns the style of the message.\r\n     * @param {string} style The combination of the added styles and custom styles.\r\n     * @return {string} A space delimited string of styles to apply to the message.\r\n     */\r\n    getStyle() {\r\n        var style = this._customStyle.concat(this._style);\r\n        if (this._fromUs || this._toUs) {\r\n            style.push(\"self\");\r\n        }\r\n        return style.join(\" \");\r\n    }\r\n\r\n    /**\r\n     * Returns true if the user's nick equals the given nick.\r\n     * @param nick The nick the check against\r\n     * @return {boolean}\r\n     */\r\n    _isOwnNick(nick) {\r\n        return nicksEqual(this._nick, nick);\r\n    }\r\n}\r\n","export default class Context {\r\n    constructor(server, channel) {\r\n        this.server = server;\r\n        this.channel = channel;\r\n    }\r\n    toString() {\r\n        if (this.channel) {\r\n            return `${this.server} ${this.channel}`;\r\n        } else {\r\n            return this.server;\r\n        }\r\n    }\r\n\r\n    fromString(str) {\r\n        return new Context(...str.split(\" \"));\r\n    }\r\n\r\n    wrap(obj) {\r\n        obj.toString = this.prototype.toString;\r\n        return obj;\r\n    }\r\n}\r\n","import Context from \"./context\";\r\n\r\n/**\r\n * Keeps a running chat log.\r\n */\r\nexport default class ChatLog {\r\n    constructor() {\r\n        this.add = this.add.bind(this);\r\n        this._entries = {};\r\n        this._whitelist = [];\r\n    }\r\n\r\n    /**\r\n     * Returns a raw representation of the chat log which can be later serialized.\r\n     */\r\n    getData() {\r\n        return this._entries;\r\n    }\r\n\r\n    /**\r\n     * Load chat history from another chat log's data.\r\n     * @param {Object.<Context, string>} serializedChatLog\r\n     */\r\n    loadData(serializedChatLog) {\r\n        return this._entries = serializedChatLog;\r\n    }\r\n\r\n    whitelist(...args) {\r\n        return this._whitelist = this._whitelist.concat(args);\r\n    }\r\n\r\n    add(context, types, content) {\r\n        var entryList, _base, _ref1;\r\n        if (!this._hasValidType(types.split(\" \"))) {\r\n            return;\r\n        }\r\n        entryList = (_ref1 = (_base = this._entries)[context]) != null ? _ref1 : _base[context] = [];\r\n        entryList.push(content);\r\n        if (entryList.length > ChatLog.MAX_ENTRIES_PER_SERVER) {\r\n            return entryList.splice(0, 25);\r\n        }\r\n    }\r\n\r\n    _hasValidType(types) {\r\n        return types.some(type => this._whitelist.indexOf(type) >= 0);\r\n    }\r\n\r\n    getContextList() {\r\n        return Object.keys(this._entries)\r\n            .map(context => Context.fromString(context));\r\n    }\r\n\r\n    get(context) {\r\n        var _ref1;\r\n        return (_ref1 = this._entries[context]) != null ? _ref1.join(\" \") : void 0;\r\n    }\r\n}\r\n\r\nChatLog.MAX_ENTRIES_PER_SERVER = 1000;","import {getReadableTime} from \"../utils/utils\";\r\nimport MessageHandler from \"../utils/message_handler\";\r\nimport NickMentionedNotification from \"./nick_mentioned_notification\";\r\nimport MessageFormatter from \"./message_formatter\";\r\nimport ChatLog from \"./chat_log\";\r\n\r\n/**\r\n * The formatter.setMessage() method accepts placeholder variables (#to, #from,\r\n *  #content). By default, the first argument replaces #from, the 2nd argument\r\n *  replaces #to and the last argument replaces #content.\r\n */\r\nconst HANDLERS = {\r\n    topic(from, topic) {\r\n        this._chat.updateStatus();\r\n        this._formatter.setContent(topic);\r\n        if (!topic) {\r\n            this._formatter.addStyle(\"notice\");\r\n            return this._formatter.setMessage(\"no topic is set\");\r\n        } else if (!from) {\r\n            this._formatter.addStyle(\"notice\");\r\n            return this._formatter.setMessage(\"the topic is: #content\");\r\n        } else {\r\n            this._formatter.addStyle(\"update\");\r\n            return this._formatter.setMessage(\"#from changed the topic to: #content\");\r\n        }\r\n    },\r\n    /**\r\n     * Display when the topic was set and who it was set by.\r\n     */\r\n    topic_info(who, secondsSinceEpoch) {\r\n        this._formatter.addStyle(\"notice\");\r\n        // The time needs converted to milliseconds since javascript doesn't have a way\r\n        // to set the clock in seconds from epoch\r\n        this._formatter.setContent(getReadableTime(parseInt(secondsSinceEpoch * 1000)));\r\n        this._formatter.setMessage(\"Topic set by #from on #content.\");\r\n        return this._formatter.setPrettyFormat(false);\r\n    },\r\n    list(channel, users, topic) {\r\n        this._formatter.addStyle(\"list\");\r\n        this._formatter.setContent(topic);\r\n        var msg = `${channel} ${users} #content`;\r\n        return this._formatter.setMessage(msg);\r\n    },\r\n    join(nick) {\r\n        this._formatter.addStyle(\"update\");\r\n        this._formatter.setMessage(\"#from joined the channel\");\r\n        return this._win.nicks.add(nick);\r\n    },\r\n    part(nick) {\r\n        this._formatter.addStyle(\"update\");\r\n        this._formatter.setMessage(\"#from left the channel\");\r\n        return this._win.nicks.remove(nick);\r\n    },\r\n    /**\r\n     * @param  {any} from\r\n     * @param  {any} to\r\n     * @param  {any} reason\r\n     */\r\n    kick(from, to) {\r\n        this._formatter.addStyle(\"update\");\r\n        this._formatter.setMessage(\"#from kicked #to from the channel: #content\");\r\n        return this._win.nicks.remove(to);\r\n    },\r\n    nick(from, to) {\r\n        if (this._isOwnNick(to)) {\r\n            this._formatter.setFromUs(true);\r\n            this._formatter.setToUs(false);\r\n        }\r\n        this._formatter.addStyle(\"update\");\r\n        this._formatter.setMessage(\"#from is now known as #to\");\r\n        if (!this._win.isServerWindow()) {\r\n            this._win.nicks.remove(from);\r\n            return this._win.nicks.add(to);\r\n        }\r\n    },\r\n    mode(from, to, mode) {\r\n        if (!to) return;\r\n        this._formatter.addStyle(\"update\");\r\n        this._formatter.setContent(this._getModeMessage(mode));\r\n        return this._formatter.setMessage(\"#from #content #to\");\r\n    },\r\n    user_mode(who, mode) {\r\n        this._formatter.addStyle(\"notice\");\r\n        this._formatter.setContext(void 0, who, mode);\r\n        return this._formatter.setMessage(\"#to has modes #content\");\r\n    },\r\n    quit(nick, reason) {\r\n        this._formatter.addStyle(\"update\");\r\n        this._formatter.setMessage(\"#from has quit: #content\");\r\n        this._formatter.setContent(reason);\r\n        return this._win.nicks.remove(nick);\r\n    },\r\n    disconnect() {\r\n        this._formatter.addStyle(\"update\");\r\n        this._formatter.setMessage(\"Disconnected\");\r\n        return this._formatter.setFromUs(true);\r\n    },\r\n    connect() {\r\n        this._formatter.addStyle(\"update\");\r\n        this._formatter.setMessage(\"Connected\");\r\n        return this._formatter.setFromUs(true);\r\n    },\r\n    privmsg(from, msg) {\r\n        this._formatter.addStyle(\"update\");\r\n        this._handleMention(from, msg);\r\n        return this._formatPrivateMessage(from, msg);\r\n    },\r\n    breakgroup(msg) {\r\n        if (msg == null) {\r\n            msg = \"\";\r\n        }\r\n        return this._formatter.setContentMessage(msg);\r\n    },\r\n    error(msg) {\r\n        return this._formatter.setContentMessage(msg);\r\n    },\r\n    system(msg) {\r\n        return this._formatter.setContentMessage(msg);\r\n    },\r\n    notice(msg) {\r\n        this._formatter.addStyle(\"notice-group\");\r\n        return this._formatter.setContentMessage(msg);\r\n    },\r\n    welcome(msg) {\r\n        this._formatter.addStyle(\"group\");\r\n        return this._formatter.setContentMessage(msg);\r\n    },\r\n    /**\r\n     * Generic messages - usually boring server stuff like MOTD.\r\n     */\r\n    other(cmd) {\r\n        this._formatter.addStyle(\"group\");\r\n        return this._formatter.setContentMessage(cmd.params[cmd.params.length - 1]);\r\n    },\r\n    nickinuse(taken, wanted) {\r\n        var msg;\r\n        this._formatter.addStyle(\"notice\");\r\n        msg = `Nickname ${taken} already in use.`;\r\n        if (wanted) {\r\n            msg += ` Trying to get nickname ${wanted}.`;\r\n        }\r\n        return this._formatter.setMessage(msg);\r\n    },\r\n    away(msg) {\r\n        this._chat.updateStatus();\r\n        this._formatter.addStyle(\"notice\");\r\n        return this._formatter.setContentMessage(msg);\r\n    },\r\n    /**\r\n     * @param  {any} from\r\n     * @param  {any} to\r\n     * @param  {any} msg\r\n     */\r\n    kill: function() {\r\n        this._formatter.addStyle(\"notice\");\r\n        /**\r\n         * TODO: We can't use 'from' or 'msg' because they are not being properly\r\n         *  parsed by irc.util.parseCommand().\r\n         */\r\n        return this._formatter.setMessage(\"Kill command used on #to\");\r\n    },\r\n    socket_error: function(errorCode) {\r\n        this._formatter.addStyle(\"error\");\r\n        this._formatter.setToUs(true);\r\n        switch (errorCode) {\r\n        case -15:\r\n            return this._formatter.setMessage(\"Disconnected: Remote host closed socket\");\r\n        default:\r\n            return this._formatter.setMessage(`Socket Error: ${errorCode}`);\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Displays messages to the user when certain IRC events occur.\r\n */\r\nexport default class IRCMessageHandler extends MessageHandler {\r\n\r\n    constructor(chat) {\r\n        super(chat);\r\n        this._chat = chat;\r\n        this._handlers = HANDLERS;\r\n        this._suspendNotifications = false;\r\n        this._formatter = new MessageFormatter;\r\n        this._chatLog = new ChatLog;\r\n        this._chatLog.whitelist(\"privmsg\");\r\n        this._ignoredMessages = {};\r\n    }\r\n\r\n    setSuspendNotifications(suspend) {\r\n        this._suspendNotifications = suspend;\r\n    }\r\n\r\n    /**\r\n     * Ignore messages of a certain type when in the specified room.\r\n     * @param {Context} context\r\n     * @param {string} type\r\n     */\r\n    ignoreMessageType(context, type) {\r\n        var ignored = this._ignoredMessages;\r\n        if (ignored[context] == null)\r\n            ignored[context] = {};\r\n\r\n        ignored[context][type.toLowerCase()] = true;\r\n        return this._chat.storage.ignoredMessagesChanged();\r\n    }\r\n\r\n    /**\r\n     * Stop ignoring messages of a certain type when in the specified room.\r\n     * @param {Context} context\r\n     * @param {string} type\r\n     */\r\n    stopIgnoringMessageType(context, type) {\r\n        type = type.toLowerCase();\r\n        if (!this._ignoredMessages[context][type]) return;\r\n        delete this._ignoredMessages[context][type];\r\n        return this._chat.storage.ignoredMessagesChanged();\r\n    }\r\n\r\n    getIgnoredMessages() {\r\n        return this._ignoredMessages;\r\n    }\r\n\r\n    setIgnoredMessages(ignoredMessages) {\r\n        return this._ignoredMessages = ignoredMessages;\r\n    }\r\n\r\n    getChatLog() {\r\n        return this._chatLog.getData();\r\n    }\r\n\r\n    logMessagesFromWindow(win) {\r\n        return win.on(\"message\", this._chatLog.add);\r\n    }\r\n\r\n    /**\r\n     * Replays the given chatlog so the user can see the conversation they\r\n     * missed.\r\n     */\r\n    replayChatLog(opt_chatLogData) {\r\n        if (opt_chatLogData) {\r\n            this._chatLog.loadData(opt_chatLogData);\r\n        }\r\n        var contextList = this._chatLog.getContextList();\r\n        for (let i = 0, len = contextList.length; i < len; i++) {\r\n            var context = contextList[i];\r\n            var win = this._chat.winList.get(context.server, context.channel);\r\n            if (!win) {\r\n                continue;\r\n            }\r\n            win.rawHTML(this._chatLog.get(context));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets which window messages will be displayed on.\r\n     * Call this method before calling handle().\r\n     */\r\n    setWindow(_win) {\r\n        var _ref1;\r\n        this._win = _win;\r\n        return this._formatter.setNick((_ref1 = this._win.conn) != null ? _ref1.irc.nick : void 0);\r\n    }\r\n\r\n    setCustomMessageStyle(customStyle) {\r\n        return this._formatter.setCustomStyle(customStyle);\r\n    }\r\n\r\n    handle(type, ...params) {\r\n        this._setDefaultValues(params);\r\n        super.handle.apply(this, [type, ...params]);\r\n        return this._sendFormattedMessage();\r\n    }\r\n\r\n    _setDefaultValues(params) {\r\n        this.source = \"\";\r\n        this._formatter.clear();\r\n        return this._formatter.setContext(...params);\r\n    }\r\n\r\n    _getModeMessage(mode) {\r\n        var post, pre;\r\n        pre = mode[0] === \"+\" ? \"gave\" : \"took\";\r\n        post = mode[0] === \"+\" ? \"to\" : \"from\";\r\n        mode = this._getMode(mode);\r\n        return `${pre} ${mode} ${post}`;\r\n    }\r\n\r\n    _getMode(mode) {\r\n        switch (mode[1]) {\r\n        case \"o\":\r\n            return \"channel operator status\";\r\n        case \"O\":\r\n            return \"local operator status\";\r\n        case \"v\":\r\n            return \"voice\";\r\n        case \"i\":\r\n            return \"invisible status\";\r\n        case \"w\":\r\n            return \"wall operator status\";\r\n        case \"a\":\r\n            return \"away status\";\r\n        default:\r\n            return mode;\r\n        }\r\n    }\r\n\r\n    _getUserAction(msg) {\r\n        return /^\\u0001ACTION (.*)\\u0001/.exec(msg);\r\n    }\r\n\r\n    _handleMention(from, msg) {\r\n        var nickMentioned, _ref1, _ref2;\r\n        nickMentioned = this._nickWasMentioned(from, msg);\r\n        if (nickMentioned) {\r\n            this._chat.recordLastUserToMention(this._win.getContext(), from);\r\n            if (!this._win.isPrivate()) {\r\n                this._formatter.addStyle(\"mention\");\r\n            }\r\n            if (this._shouldNotifyMention()) {\r\n                this._createNotification(from, msg);\r\n            }\r\n        }\r\n        if (!this._isFromWindowInFocus()) {\r\n            this._chat.channelDisplay.activity((_ref1 = this._win.conn) != null ? _ref1.name : void 0, this._win.target);\r\n            if (nickMentioned) {\r\n                return this._chat.channelDisplay.mention((_ref2 = this._win.conn) != null ? _ref2.name : void 0, this._win.target);\r\n            }\r\n        }\r\n    }\r\n\r\n    _createNotification(from, msg) {\r\n        var notification,\r\n            win = this._win;\r\n        notification = new NickMentionedNotification(win.target, from, msg);\r\n        win.notifications.add(notification);\r\n        return win.notifications.on(\"clicked\", () => {\r\n            var _base;\r\n            this._chat.switchToWindow(win);\r\n            return typeof (_base = chrome.app.window.current()).focus === \"function\" ? _base.focus() : void 0;\r\n        });\r\n    }\r\n\r\n    _nickWasMentioned(from, msg) {\r\n        var _ref1,\r\n            nick = (_ref1 = this._win.conn) != null ? _ref1.irc.nick : void 0;\r\n        if (this._isOwnNick(from)) {\r\n            return false;\r\n        }\r\n        if (this._formatter.hasStyle(\"notice\")) {\r\n            return false;\r\n        }\r\n        if (this._formatter.hasStyle(\"direct\")) {\r\n            return false;\r\n        }\r\n        if (this._win.isPrivate()) {\r\n            return true;\r\n        }\r\n        return NickMentionedNotification.shouldNotify(nick, msg);\r\n    }\r\n\r\n    _shouldNotifyMention() {\r\n        return !this._suspendNotifications && (!this._isFromWindowInFocus() || !window.document.hasFocus());\r\n    }\r\n\r\n    _isFromWindowInFocus() {\r\n        return this._win.equals(this._chat.currentWindow);\r\n    }\r\n\r\n    _formatPrivateMessage(from, msg) {\r\n        var m = this._getUserAction(msg);\r\n        this._formatter.setMessage(\"#content\");\r\n        this._formatter.setPrettyFormat(false);\r\n        if (m) {\r\n            this._formatter.setContent(`${from} ${m[1]}`);\r\n            return this._formatter.addStyle(\"action\");\r\n        } else {\r\n            if (this._formatter.hasStyle(\"notice\")) {\r\n                this.source = `- ${from} -`;\r\n            } else if (this._formatter.hasStyle(\"direct\")) {\r\n                this.source = `> ${from} <`;\r\n            } else {\r\n                this.source = from;\r\n            }\r\n            return this._formatter.setContent(msg);\r\n        }\r\n    }\r\n\r\n    _sendFormattedMessage() {\r\n        if (!this._formatter.hasMessage()\r\n                || this._shouldIgnoreMessage(this._win.getContext(), this.type)) {\r\n            return;\r\n        }\r\n        this._formatter.addStyle(this.type);\r\n        return this._win.message(this.source, this._formatter.format(), this._formatter.getStyle());\r\n    }\r\n\r\n    _shouldIgnoreMessage(context, type) {\r\n        var _ref1;\r\n        return (_ref1 = this._ignoredMessages[context]) != null ? _ref1[type] : void 0;\r\n    }\r\n\r\n    _isOwnNick(nick) {\r\n        var conn = this._win.conn;\r\n        return conn != null ? conn.irc.isOwnNick(nick) : void 0;\r\n    }\r\n}\r\n","import {version} from \"../../package.json\";\r\n\r\nexport const PROJECT_URL = \"http://flackr.github.com/circ\";\r\nexport const ISSUES_URL = \"https://github.com/flackr/circ/issues\";\r\n// Should match the version in the manifest.\r\nexport const VERSION = version;\r\n","import {VERSION} from \"../utils/globals\";\r\n/**\r\n * Handles CTCP requests such as VERSION, PING, etc.\r\n */\r\nexport default class CTCPHandler {\r\n    constructor() {\r\n        /*\r\n         * TODO: Respond with this message when an unknown query is seen.\r\n         */\r\n        this._error = `${CTCPHandler.DELIMITER}ERRMSG${CTCPHandler.DELIMITER}`;\r\n    }\r\n    isCTCPRequest(msg) {\r\n        if (!/\\u0001[\\w\\s]*\\u0001/.test(msg)) {\r\n            return false;\r\n        }\r\n        return this.getResponses(msg).length > 0;\r\n    }\r\n\r\n    getReadableName(msg) {\r\n        return this._parseMessage(msg)[0];\r\n    }\r\n\r\n    getResponses(msg) {\r\n        var parsed = this._parseMessage(msg),\r\n            type = parsed[0],\r\n            responses = this._getResponseText(type, parsed[1]);\r\n\r\n        return responses.map(response => this._createCTCPResponse(type, response));\r\n    }\r\n\r\n    /**\r\n     * Parses the type and arguments from a CTCP request.\r\n     * @param {string} msg CTCP message in the format: '\\0001TYPE ARG1 ARG2\\0001'.\r\n     *     Note: \\0001 is a single character.\r\n     * @return {string, string[]} Returns the type and the args.\r\n     */\r\n    _parseMessage(msg) {\r\n        var parsed = msg.slice(1, +(msg.length - 2) + 1 || 9e9).split(\" \"),\r\n            type = parsed[0],\r\n            args = 2 <= parsed.length ? parsed.slice(1) : [];\r\n        return [type, args];\r\n    }\r\n\r\n    /**\r\n     * @return {string[]} Returns the unformatted responses to a CTCP request.\r\n     */\r\n    _getResponseText(type, args) {\r\n        /*\r\n         * TODO support the o ther types found here:\r\n         * http://www.irchelp.org/irchelp/rfc/ctcpspec.html\r\n         */\r\n\r\n        var environment, name;\r\n        switch (type) {\r\n        case \"VERSION\":\r\n            name = \"CIRC\";\r\n            environment = \"Chrome\";\r\n            return [` ${[name, VERSION, environment].join(\" \")}`];\r\n        case \"SOURCE\":\r\n            return [\" https://github.com/flackr/circ/\"];\r\n        case \"PING\":\r\n            return [` ${args[0]}`];\r\n        case \"TIME\":\r\n            var d = new Date();\r\n            return [` ${d.toUTCString()}`];\r\n        default:\r\n            return [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return {string} Returns a correctly formatted response to a CTCP request.\r\n     */\r\n    _createCTCPResponse(type, response) {\r\n        return `${CTCPHandler.DELIMITER + type + response + CTCPHandler.DELIMITER}`;\r\n    }\r\n}\r\nCTCPHandler.DELIMITER = \"\\u0001\";\r\n","/**\r\n * A generic event often used in conjuction with emit().\r\n */\r\nexport default class Event {\r\n    constructor(type, name, ...args) {\r\n        this.type = type;\r\n        this.name = name;\r\n        this.args = args;\r\n\r\n        /**\r\n         * Info on which window the event took place in.\r\n         */\r\n        this.context = {};\r\n        /**\r\n         * Effects how the event is displayed.\r\n         */\r\n        this.style = [];\r\n        /**\r\n         * Acts as an id for the event.\r\n         */\r\n        this.hook = this.type + \" \" + this.name;\r\n    }\r\n\r\n    setContext(server, channel) {\r\n        return this.context = {\r\n            server: server,\r\n            channel: channel\r\n        };\r\n    }\r\n    /**\r\n     * Adds a custom style for the event that will effect how it's contents are\r\n     *  displayed.\r\n     * @param {Array.<string>} style\r\n     */\r\n    addStyle(style) {\r\n        if (!Array.isArray(style)) {\r\n            style = [style];\r\n        }\r\n        return this.style = this.style.concat(style);\r\n    }\r\n}\r\n\r\n/**\r\n * Creates an Event from an Event-like object. Used for deserialization.\r\n */\r\nEvent.wrap = function(obj) {\r\n    var event;\r\n    if (obj instanceof Event) {\r\n        return obj;\r\n    }\r\n    event = new Event(obj.type, obj.name, ...obj.args);\r\n    event.setContext(obj.context.server, obj.context.channel);\r\n    return event;\r\n};","/*eslint no-console: 0 */\r\nimport Chat from \"../chat/chat\";\r\nimport Event from \"../utils/event\";\r\nimport {getReadableTime} from \"../utils/utils\";\r\nimport {normaliseNick} from \"./irc_util\";\r\nimport iter from \"lazy.js\";\r\n\r\nexport default {\r\n    // RPL_WELCOME\r\n    1: function (from, nick, msg) {\r\n        if (this.irc.state === \"disconnecting\") {\r\n            this.irc.quit();\r\n            return;\r\n        }\r\n        this.irc.nick = nick;\r\n        this.irc.state = \"connected\";\r\n        this.irc.emit(\"connect\");\r\n        this.irc.emitMessage(\"welcome\", Chat.SERVER_WINDOW, msg);\r\n\r\n        return iter(this.irc.channels)\r\n            .pairs()\r\n            .map(([chanName, channel]) => channel.key ?\r\n                    this.irc.send(\"JOIN\", chanName, channel.key)\r\n                    : this.irc.send(\"JOIN\", chanName)\r\n            ).toArray();\r\n    },\r\n\r\n    // RPL_ISUPPORT\r\n    // We might get multiple, so this just adds to the support object.\r\n    5: function (...args) {\r\n        // Parameters passed in arguments, pull out the parts we want.\r\n        iter(args.slice(2, args.length - 1))\r\n            .map(arg => arg.split(/=/, 2))\r\n            .async(0)\r\n            .each(param => {\r\n                let k = param[0].toLowerCase();\r\n                if (param.length === 1) this.irc.support[k] = true;\r\n                else this.irc.support[k] = param[1];\r\n            });\r\n    },\r\n\r\n    // RPL_NAMREPLY\r\n    353: function (from, target, privacy, channel, names) {\r\n        var newNameSeq,\r\n            lcChan = channel.toLowerCase(),\r\n            partialNs = this.irc.partialNameLists,\r\n            _ref1 = partialNs[lcChan],\r\n            nameList = _ref1 != null ? _ref1 : partialNs[lcChan] = {};\r\n\r\n        newNameSeq = iter(names.split(/\\x20/))\r\n            .map(name => name.replace(/^[~&@%+]/, \"\"))\r\n            .compact();\r\n\r\n        newNameSeq\r\n            .async(0)\r\n            .each(name => {\r\n                nameList[normaliseNick(name)] = name;\r\n            });\r\n\r\n        return this.irc.emit(\"names\", channel, newNameSeq.toArray());\r\n    },\r\n\r\n    // RPL_ENDOFNAMES\r\n    366: function (from, target, channel) {\r\n        let lCChannel = channel.toLowerCase();\r\n        if (this.irc.channels[lCChannel]) {\r\n            this.irc.channels[lCChannel].names = this.irc.partialNameLists[lCChannel];\r\n        }\r\n        return delete this.irc.partialNameLists[channel.toLowerCase()];\r\n    },\r\n\r\n    NICK: function (from, newNick) {\r\n        let normNick = this.irc.util.normaliseNick(from.nick),\r\n            newNormNick = this.irc.util.normaliseNick(newNick),\r\n            commonChans = iter(this.irc.channels)\r\n                .pairs()\r\n                .filter(([, chan]) => !(normNick in chan.names));\r\n\r\n        if (this.irc.isOwnNick(from.nick)) {\r\n            this.irc.nick = newNick;\r\n            this.irc.emit(\"nick\", newNick);\r\n            this.irc.emitMessage(\"nick\", Chat.SERVER_WINDOW, from.nick, newNick);\r\n        }\r\n        // Update channel names list\r\n        commonChans.each(([, chan]) => {\r\n            delete chan.names[normNick];\r\n            chan.names[newNormNick] = newNick;\r\n        });\r\n        return commonChans\r\n            .map(([chanName]) => this.irc.emitMessage(\"nick\", chanName, from.nick, newNick));\r\n    },\r\n\r\n    JOIN: function (from, chanName) {\r\n        var chan = this.irc.channels[chanName.toLowerCase()];\r\n        if (this.irc.isOwnNick(from.nick)) {\r\n            if (chan != null) {\r\n                chan.names = [];\r\n            } else {\r\n                chan = this.irc.channels[chanName.toLowerCase()] = {\r\n                    channel: chanName,\r\n                    names: []\r\n                };\r\n            }\r\n            this.irc.emit(\"joined\", chanName);\r\n        }\r\n        if (chan) {\r\n            chan.names[this.irc.util.normaliseNick(from.nick)] = from.nick;\r\n            return this.irc.emitMessage(\"join\", chanName, from.nick);\r\n        } else {\r\n            return console.warn(`Got JOIN for channel we're not in (${chan})`);\r\n        }\r\n    },\r\n\r\n    PART: function (from, chan) {\r\n        var c = this.irc.channels[chan.toLowerCase()];\r\n        if (c) {\r\n            if (this.irc.isOwnNick(from.nick)) {\r\n                delete this.irc.channels[chan.toLowerCase()];\r\n                return this.irc.emit(\"parted\", chan);\r\n            } else {\r\n                delete c.names[this.irc.util.normaliseNick(from.nick)];\r\n                return this.irc.emitMessage(\"part\", chan, from.nick);\r\n            }\r\n        } else {\r\n            return console.warn(`Got PART for a channel we're not in: ${chan}`);\r\n        }\r\n    },\r\n\r\n    INVITE: function (from, target, channel) {\r\n        return this.irc.emitMessage(\"notice\", Chat.CURRENT_WINDOW, `${from.nick} invites you to join ${channel}`);\r\n    },\r\n\r\n    QUIT: function (from, reason) {\r\n        var normNick = this.irc.util.normaliseNick(from.nick);\r\n\r\n        return iter(this.irc.channels)\r\n            .pairs()\r\n            .filter(([, chan]) => normNick in chan.names)\r\n            .each(([chanName, chan]) => {\r\n                delete chan.names[normNick];\r\n                this.irc.emitMessage(\"quit\", chanName, from.nick, reason);\r\n            });\r\n    },\r\n\r\n    PRIVMSG: function (from, target, msg) {\r\n        if (this.ctcpHandler.isCTCPRequest(msg)) {\r\n            return this._handleCTCPRequest(from, target, msg);\r\n        } else {\r\n            return this.irc.emitMessage(\"privmsg\", target, from.nick, msg);\r\n        }\r\n    },\r\n\r\n    NOTICE: function (from, target, msg) {\r\n        if (!from.user) {\r\n            return this.irc.emitMessage(\"notice\", Chat.SERVER_WINDOW, msg);\r\n        }\r\n        var event = new Event(\"message\", \"privmsg\", from.nick, msg);\r\n        event.setContext(this.irc.server, Chat.CURRENT_WINDOW);\r\n        event.addStyle(\"notice\");\r\n        return this.irc.emitCustomMessage(event);\r\n    },\r\n\r\n    PING: function (from, payload) {\r\n        return this.irc.send(\"PONG\", payload);\r\n    },\r\n    /**\r\n     * @param  {any} from\r\n     * @param  {any} payload\r\n     */\r\n    PONG: function () { },\r\n\r\n    TOPIC: function (from, channel, topic) {\r\n        if (this.irc.channels[channel.toLowerCase()] != null) {\r\n            this.irc.channels[channel.toLowerCase()].topic = topic;\r\n            return this.irc.emitMessage(\"topic\", channel, from.nick, topic);\r\n        } else {\r\n            return console.warn(`Got TOPIC for a channel we're not in (${channel})`);\r\n        }\r\n    },\r\n\r\n    KICK: function (from, channel, to, reason) {\r\n        if (!this.irc.channels[channel.toLowerCase()]) {\r\n            console.warn(`Got KICK message from ${from} to ${to} in channel we are not in (${channel})`);\r\n            return;\r\n        }\r\n        delete this.irc.channels[channel.toLowerCase()].names[to];\r\n        this.irc.emitMessage(\"kick\", channel, from.nick, to, reason);\r\n        if (this.irc.isOwnNick(to)) {\r\n            this.irc.emit(\"parted\", channel);\r\n        }\r\n    },\r\n\r\n    MODE: function (from, chan, modeList, ...toList) {\r\n        if (toList.length < 1) return;\r\n\r\n        iter(modeList.split(/(?=[+-]\\w)/))\r\n            .map(modes => iter(modes.split(\"\")).slice(1).map(mode => modes[0] + mode))\r\n            .flatten()\r\n            .zip(toList)\r\n            .each(([mode, argument]) => this.irc.emitMessage(\"mode\", chan, from.nick, argument, mode));\r\n        return;\r\n    },\r\n\r\n    // RPL_UMODEIS\r\n    221: function (from, to, mode) {\r\n        return this.irc.emitMessage(\"user_mode\", Chat.CURRENT_WINDOW, to, mode);\r\n    },\r\n\r\n    // RPL_AWAY\r\n    301: function (from, to, nick, msg) {\r\n        return this._emitUserNotice(to, nick, `is away: ${msg}`);\r\n    },\r\n\r\n    // RPL_UNAWAY\r\n    305: function (from, to, msg) {\r\n        this.irc.away = false;\r\n        return this.irc.emitMessage(\"away\", Chat.CURRENT_WINDOW, msg);\r\n    },\r\n\r\n    // RPL_NOWAWAY\r\n    306: function (from, to, msg) {\r\n        this.irc.away = true;\r\n        return this.irc.emitMessage(\"away\", Chat.CURRENT_WINDOW, msg);\r\n    },\r\n\r\n    /**\r\n     * RPL_WHOISHELPOP (and others; overloaded).\r\n     * Not useful; drop it\r\n     * @param  {any} from\r\n     * @param  {any} to\r\n     * @param  {any} nick\r\n     * @param  {any} msg\r\n     */\r\n    310: function () {},\r\n\r\n    // RPL_WHOISUSER\r\n    311: function (from, to, nick, user, addr, _, info) {\r\n        var message = `is ${nick}!${user}@${addr} (${info})`;\r\n        return this._emitUserNotice(to, nick, message);\r\n    },\r\n\r\n    // RPL_WHOISSERVER\r\n    312: function (from, to, nick, server, desc) {\r\n        return this._emitUserNotice(to, nick, `connected via ${server} (${desc})`);\r\n    },\r\n\r\n    // RPL_WHOISOPERATOR (is an IRCOp)\r\n    313: function (from, to, nick, msg) {\r\n        // server supplies the message text\r\n        return this._emitUserNotice(to, nick, msg);\r\n    },\r\n\r\n    // RPL_WHOWASUSER\r\n    314: function (from, to, nick, user, addr, _, info) {\r\n        var message = `was ${nick}!${user}@${addr} (${info})`;\r\n        return this._emitUserNotice(to, nick, message);\r\n    },\r\n\r\n    // RPL_ENDOFWHO\r\n    315: function (from, to, nick, msg) {\r\n        // server supplies the message text\r\n        return this.irc.emitMessage(\"notice\", Chat.SERVER_WINDOW, msg);\r\n    },\r\n\r\n    // RPL_WHOISIDLE\r\n    317: function (from, to, nick, seconds, signon) {\r\n        var date = getReadableTime(parseInt(signon) * 1000),\r\n            message = `has been idle for ${seconds} seconds, and signed on at: ${date}`;\r\n        return this._emitUserNotice(to, nick, message);\r\n    },\r\n\r\n    // RPL_ENDOFWHOIS\r\n    318: function (from, to, nick, msg) {\r\n        // server supplies the message text\r\n        return this._emitUserNotice(to, nick, msg);\r\n    },\r\n\r\n    // RPL_WHOISCHANNELS\r\n    319: function (from, to, nick, channels) {\r\n        return this._emitUserNotice(to, nick, `is on channels: ${channels}`);\r\n    },\r\n\r\n    //321 LIST START\r\n    //322 LIST ENTRY\r\n    //323 END OF LIST\r\n    322: function (from, to, channel, users, topic) {\r\n        //var message = `${channel} ${users} ${topic}`;\r\n        return this.irc.emitMessage(\"list\", Chat.SERVER_WINDOW, channel, users, topic);\r\n    },\r\n\r\n\r\n    // RPL_CHANNELMODEIS\r\n    324: function (from, to, channel, mode, modeParams) {\r\n        var message = `Channel modes: ${mode} ${modeParams || \"\"}`;\r\n        return this.irc.emitMessage(\"notice\", channel, message);\r\n    },\r\n\r\n    // RPL_CHANNELCREATED\r\n    329: function (from, to, channel, secondsSinceEpoch) {\r\n        var message = `Channel created on ${getReadableTime(parseInt(secondsSinceEpoch * 1000))}`;\r\n        return this.irc.emitMessage(\"notice\", channel, message);\r\n    },\r\n\r\n    // RPL_WHOISACCOUNT (NickServ registration)\r\n    330: function (from, to, nick, loggedin, msg) {\r\n        return this._emitUserNotice(to, nick, `${msg} ${loggedin}`);\r\n    },\r\n\r\n    /**\r\n     * RPL_NOTOPIC\r\n     * @param  {any} from\r\n     * @param  {any} to\r\n     * @param  {any} channel\r\n     * @param  {any} msg\r\n     */\r\n    331: function (from, to, channel) {\r\n        return this.handle(\"TOPIC\", {}, channel);\r\n    },\r\n\r\n    // RPL_TOPIC\r\n    332: function (from, to, channel, topic) {\r\n        return this.handle(\"TOPIC\", {}, channel, topic);\r\n    },\r\n\r\n    // RPL_TOPICWHOTIME\r\n    333: function (from, to, channel, who, time) {\r\n        return this.irc.emitMessage(\"topic_info\", channel, who, time);\r\n    },\r\n\r\n    // RPL_WHOISACTUALLY (ircu, and others)\r\n    338: function (from, to, nick, realident, realip, msg) {\r\n        var message = `is actually ${realident}/${realip} (${msg})`;\r\n        return this._emitUserNotice(to, nick, message);\r\n    },\r\n\r\n    // RPL_WHOREPLY\r\n    352: function (from, to, chan, ident, addr, serv, nick, flags, data) {\r\n        var space = data.indexOf(\" \");\r\n        var m1 = `${chan}: ${nick}`;\r\n        var m2 = (flags.substring(0, 1) == \"G\" ? \" (AWAY)\" : \"\");\r\n        var m3 = ` | ${ident}@${addr} (${data.substring(space + 1)}) | via ${serv}, hops ${data.substring(0, space)}`;\r\n        return this.irc.emitMessage(\"notice\", Chat.SERVER_WINDOW, m1 + m2 + m3);\r\n    },\r\n\r\n    // RPL_ENDOFWHOWAS\r\n    369: function (from, to, nick, msg) {\r\n        // server supplies the message text\r\n        return this._emitUserNotice(to, nick, msg);\r\n    },\r\n\r\n    /**\r\n     * Overloaded by Freenode, ignorable WHOIS reply (repeat of info in 311)\r\n     * @param  {any} from\r\n     * @param  {any} to\r\n     * @param  {any} nick\r\n     * @param  {any} msg\r\n     */\r\n    378: function () {},\r\n\r\n    // ERR_NICKNAMEINUSE\r\n    433: function (from, nick, taken) {\r\n        var newNick = `${taken}_`;\r\n        if (nick === newNick) {\r\n            newNick = void 0;\r\n        }\r\n        this.irc.emitMessage(\"nickinuse\", Chat.CURRENT_WINDOW, taken, newNick);\r\n        if (newNick) {\r\n            return this.irc.send(\"NICK\", newNick);\r\n        }\r\n    },\r\n\r\n    // RPL_WHOISSECURE\r\n    671: function (from, to, nick, msg) {\r\n        // server supplies the message text\r\n        return this._emitUserNotice(to, nick, msg);\r\n    },\r\n\r\n    // The default error handler for error messages. This handler is used for\r\n    // all 4XX error messages unless a handler is explicitly specified.\r\n    //\r\n    // Messages are displayed in the following format:\r\n    // \"<arg1> <arg2> ... <argn>: <message>\r\n    //\r\n    error: function (from, to, ...args) {\r\n        var message,\r\n            msg = args[args.length - 1];\r\n        args.pop();\r\n        if (args.length > 0) {\r\n            message = `${args.join(\" \")} :${msg}`;\r\n        } else {\r\n            message = msg;\r\n        }\r\n        return this.irc.emitMessage(\"error\", Chat.CURRENT_WINDOW, message);\r\n    },\r\n\r\n    KILL: function (from, victim, killer, msg) {\r\n        return this.irc.emitMessage(\"kill\", Chat.CURRENT_WINDOW, killer.nick, victim, msg);\r\n    }\r\n};","import MessageHandler from \"../utils/message_handler\";\r\nimport CTCPHandler from \"./ctcp_handler\";\r\nimport handlers from \"./server_response_handler_map\";\r\nimport Chat from \"../chat/chat\";\r\nimport Event from \"../utils/event\";\r\n\r\n/**\r\n * Handles messages from an IRC server\r\n * Good references for numeric (raw) response codes:\r\n * https://www.alien.net.au/irc/irc2numerics.html\r\n * http://www.mirc.org/mishbox/reference/rawhelp.htm\r\n */\r\nexport default class ServerResponseHandler extends MessageHandler {\r\n    constructor(irc) {\r\n        super();\r\n        this.irc = irc;\r\n        this.ctcpHandler = new CTCPHandler;\r\n    }\r\n\r\n    canHandle(type) {\r\n        if (this._isErrorMessage(type)) {\r\n            return true;\r\n        } else {\r\n            return super.canHandle.call(this, type);\r\n        }\r\n    }\r\n    /**\r\n     * Handle a message of the given type. Error messages are handled with the\r\n     *  default error handler unless a handler is explicitly specified.\r\n     * @param  {string} type The type of message (e.g. PRIVMSG).\r\n     * @param  {any} ...params A variable number of arguments.\r\n     */\r\n    handle(type, ...params) {\r\n        if (this._isErrorMessage(type) && !(type in this._handlers)) {\r\n            type = \"error\";\r\n        }\r\n        return super.handle.apply(this, [type, ...params]);\r\n    }\r\n\r\n    _isErrorMessage(type) {\r\n        var _ref1;\r\n        return (400 <= (_ref1 = parseInt(type)) && _ref1 < 600);\r\n    }\r\n\r\n    _handleCTCPRequest(from, target, msg) {\r\n        var name = this.ctcpHandler.getReadableName(msg),\r\n            message = `Received a CTCP ${name} from ${from.nick}`;\r\n        this.irc.emitMessage(\"notice\", Chat.CURRENT_WINDOW, message);\r\n        return this.ctcpHandler.getResponses(msg)\r\n            .map(response => this.irc.doCommand(\"NOTICE\", from.nick, response, true));\r\n    }\r\n\r\n\r\n    /**\r\n     * Called by various nick-specific raw server responses (e.g., /WHOIS responses)\r\n     * @param  {any} to\r\n     * @param  {any} nick\r\n     * @param  {any} msg\r\n     */\r\n    _emitUserNotice(to, nick, msg) {\r\n        var event = new Event(\"message\", \"privmsg\", nick, msg);\r\n        event.setContext(this.irc.server, to);\r\n        event.addStyle(\"notice\");\r\n        return this.irc.emitCustomMessage(event);\r\n    }\r\n}\r\n\r\nServerResponseHandler.prototype._handlers = handlers;\r\n","import EventEmitter from \"../utils/event_emitter\";\r\n\r\n/**\r\n * Abstract TCP socket.\r\n * ####Events emitted:\r\n * - 'connect': the connection succeeded, proceed.\r\n * - 'data': data received. Argument is the data (array of longs, atm)\r\n * - 'end': the other end sent a FIN packet, and won't accept any more data.\r\n * - 'error': an error occurred. The socket is pretty much hosed now.\r\n * - 'close': emitted when the socket is fully closed.\r\n * - 'drain': emitted when the write buffer becomes empty\r\n * ####TODO:\r\n * Investigate how node deals with errors. The docs say 'close' gets sent right\r\n * after 'error', so they probably destroy the socket.)\r\n */\r\nexport default class AbstractTCPSocket extends EventEmitter {\r\n    constructor(...args) {\r\n        super(...args);\r\n    }\r\n    /**\r\n     * @param  {any} port\r\n     * @param  {any} host\r\n     */\r\n    connect() {}\r\n    /**\r\n     * @param  {any} data\r\n     */\r\n    write() {}\r\n\r\n    close() {}\r\n\r\n    setTimeout(ms, callback) {\r\n        if (ms > 0) {\r\n            this.timeout = setTimeout(() => this.emit(\"timeout\"), ms);\r\n            this.timeout_ms = ms;\r\n            if (callback) return this.once(\"timeout\", callback);\r\n        }\r\n        else if (ms === 0) {\r\n            clearTimeout(this.timeout);\r\n            if (callback) {\r\n                this.removeListener(\"timeout\", callback);\r\n            }\r\n            this.timeout = null;\r\n            return this.timeout_ms = 0;\r\n        }\r\n    }\r\n\r\n    _active() {\r\n        if (this.timeout) {\r\n            clearTimeout(this.timeout);\r\n            return this.timeout = setTimeout(() => this.emit(\"timeout\"), this.timeout_ms);\r\n        }\r\n    }\r\n}\r\n","/*eslint no-console: 0 */\r\nimport AbstractTCPSocket from \"./abstract_tcp_socket\";\r\nimport {registerSocketConnection}  from \"../utils/utils\";\r\n\r\n/**\r\n * A socket connected to an IRC server. Uses chrome.sockets.tcp.\r\n */\r\nexport default class ChromeSocket extends AbstractTCPSocket {\r\n    constructor() {\r\n        super();\r\n        this._onCreate = this._onCreate.bind(this);\r\n        this._onConnect = this._onConnect.bind(this);\r\n        this._onReceive = this._onReceive.bind(this);\r\n        this._onReceiveError = this._onReceiveError.bind(this);\r\n    }\r\n\r\n    connect(addr, port) {\r\n        this._active();\r\n        return chrome.sockets.tcp.create({}, si => {\r\n            this._onCreate(si, addr, parseInt(port));\r\n        });\r\n    }\r\n\r\n    _onCreate(si, addr, port) {\r\n        this.socketId = si.socketId;\r\n        if (this.socketId > 0) {\r\n            registerSocketConnection(si.socketId);\r\n            chrome.sockets.tcp.setPaused(this.socketId, true, () => {\r\n                chrome.sockets.tcp.connect(this.socketId, addr, port, this._onConnect);\r\n            });\r\n        } else {\r\n            return this.emit(\"error\", \"couldn't create socket\");\r\n        }\r\n    }\r\n\r\n    _onConnect(rc) {\r\n        if (rc < 0) {\r\n            let msg = `Couldn't connect to socket: ${chrome.runtime.lastError.message} (error ${-rc})`;\r\n            return this.emit(\"error\", msg);\r\n        } else {\r\n            this.emit(\"connect\");\r\n            chrome.sockets.tcp.onReceive.addListener(this._onReceive);\r\n            chrome.sockets.tcp.onReceiveError.addListener(this._onReceiveError);\r\n            chrome.sockets.tcp.setPaused(this.socketId, false);\r\n        }\r\n    }\r\n\r\n    _onReceive(info) {\r\n        if (info.socketId != this.socketId) return;\r\n        this._active();\r\n        this.emit(\"data\", info.data);\r\n    }\r\n\r\n    _onReceiveError(info) {\r\n        if (info.socketId != this.socketId) return;\r\n        this._active();\r\n        if (info.resultCode == -100) {// connection closed\r\n            this.emit(\"end\");\r\n            this.close();\r\n        }\r\n        else {\r\n            this.emit(\"error\", `read from socket: error ${-info.resultCode})`);\r\n            this.close();\r\n        }\r\n    }\r\n\r\n    write(data) {\r\n        this._active();\r\n        return chrome.sockets.tcp.send(this.socketId, data, sendInfo => {\r\n            if (sendInfo.resultCode < 0) {\r\n                let msg = chrome.runtime.lastError.message;\r\n                console.error(\"SOCKET ERROR on send: \", `${msg} (error ${-sendInfo.resultCode})`);\r\n            }\r\n            if (sendInfo.bytesSent === data.byteLength) {\r\n                return this.emit(\"drain\");\r\n            } else {\r\n                if (sendInfo.bytesSent >= 0) {\r\n                    console.error(\"Can't handle non-complete send: wrote \"\r\n                        + `${sendInfo.bytesSent} expected ${data.byteLength}`);\r\n                }\r\n                return this.emit(\"error\", `Invalid send on socket, code: ${sendInfo.bytesSent}`);\r\n            }\r\n        });\r\n    }\r\n\r\n    close() {\r\n        if (this.socketId != null) {\r\n            chrome.sockets.tcp.onReceive.removeListener(this._onReceive);\r\n            chrome.sockets.tcp.onReceiveError.removeListener(this._onReceiveError);\r\n            chrome.sockets.tcp.disconnect(this.socketId);\r\n            chrome.sockets.tcp.close(this.socketId);\r\n            registerSocketConnection(this.socketId, true);\r\n        }\r\n        return this.emit(\"close\");\r\n    }\r\n}\r\n","/*eslint no-console: 0*/\r\nimport EventEmitter from \"../utils/event_emitter\";\r\nimport ServerResponseHandler from \"./server_response_handler\";\r\nimport ChromeSocket from \"../net/chrome_socket\";\r\nimport Chat from \"../chat/chat\";\r\nimport {getLogger} from \"../utils/utils\";\r\nimport Event from \"../utils/event\";\r\nimport * as util from \"./irc_util\";\r\n\r\n/**\r\n * Represents a connection to an IRC server.\r\n */\r\nexport default class IRC extends EventEmitter {\r\n    constructor(opt_socket) {\r\n        super();\r\n        this.reconnect = this.reconnect.bind(this);\r\n        this.onTimeout = this.onTimeout.bind(this);\r\n        this.util = util;\r\n        this.preferredNick = `circ-user-${this.util.randomName(5)}`;\r\n        this.setSocket(opt_socket || new ChromeSocket);\r\n        this.data = this.util.emptySocketData();\r\n        this.exponentialBackoff = 0;\r\n        this.partialNameLists = {};\r\n        this.channels = {};\r\n        this.serverResponseHandler = new ServerResponseHandler(this);\r\n        this.state = \"disconnected\";\r\n        this.support = {};\r\n        this._log = getLogger(this);\r\n    }\r\n\r\n    setSocket(socket) {\r\n        delete this.socket;\r\n        this.socket = socket;\r\n        this.socket.on(\"connect\", () => this.onConnect());\r\n        this.socket.on(\"data\", data => this.onData(data));\r\n        this.socket.on(\"drain\", () => this.onDrain());\r\n        this.socket.on(\"error\", err => this.onError(err));\r\n        this.socket.on(\"end\", err => this.onEnd(err));\r\n        return this.socket.on(\"close\", err => this.onClose(err));\r\n    }\r\n\r\n    setPreferredNick(preferredNick) {\r\n        this.preferredNick = preferredNick;\r\n    }\r\n    /**\r\n     * Public\r\n     */\r\n    connect(server, port, password) {\r\n        const state = this.state;\r\n        this.server = server != null ? server : this.server;\r\n        this.port = port != null ? port : this.port;\r\n        this.password = password != null ? password : this.password;\r\n        if (state !== \"disconnected\" && state !== \"reconnecting\") {\r\n            return;\r\n        }\r\n        clearTimeout(this.reconnectTimeout);\r\n        this.socket.connect(this.server, this.port);\r\n        return this.state = \"connecting\";\r\n    }\r\n    /**\r\n     * Public\r\n     */\r\n    quit(reason) {\r\n        if (this.state === \"connected\" || this.state === \"disconnecting\") {\r\n            this.send(\"QUIT\", reason != null ? reason : this.quitReason);\r\n            this.state = \"disconnected\";\r\n            return this.endSocketOnDrain = true;\r\n        } else {\r\n            this.quitReason = reason;\r\n            return this.state = \"disconnecting\";\r\n        }\r\n    }\r\n    /**\r\n     * Public\r\n     */\r\n    giveup() {\r\n        if (this.state !== \"reconnecting\") return;\r\n        clearTimeout(this.reconnectTimeout);\r\n        return this.state = \"disconnected\";\r\n    }\r\n\r\n    join(channel, key) {\r\n        if (this.state === \"connected\") {\r\n            if (key) {\r\n                return this.doCommand(\"JOIN\", channel, key);\r\n            } else {\r\n                return this.doCommand(\"JOIN\", channel);\r\n            }\r\n        } else if (!this.channels[channel.toLowerCase()]) {\r\n            return this.channels[channel.toLowerCase()] = {\r\n                channel: channel,\r\n                names: [],\r\n                key: key\r\n            };\r\n        }\r\n    }\r\n\r\n    part(channel, opt_reason) {\r\n        if (this.state === \"connected\") {\r\n            return this.doCommand(\"PART\", channel, opt_reason);\r\n        } else if (this.channels[channel.toLowerCase()]) {\r\n            return delete this.channels[channel.toLowerCase()];\r\n        }\r\n    }\r\n    /**\r\n     * Public\r\n     * @param  {any} cmd\r\n     * @param  {any} ...rest\r\n     */\r\n    doCommand(...args) {\r\n        return this.sendIfConnected(...args);\r\n    }\r\n\r\n    onConnect() {\r\n        if (this.password) {\r\n            this.send(\"PASS\", this.password);\r\n        }\r\n        this.send(\"NICK\", this.preferredNick);\r\n        this.send(\"USER\", this.preferredNick.replace(/[^a-zA-Z0-9]/, \"\"), \"0\", \"*\", \"Hyuu\");\r\n        return this.socket.setTimeout(60000, this.onTimeout);\r\n    }\r\n\r\n    onTimeout() {\r\n        if (this.state === \"connected\" && this.exponentialBackoff > 0)\r\n            this.exponentialBackoff--;\r\n\r\n        this.send(\"PING\", +(new Date));\r\n        return this.socket.setTimeout(60000, this.onTimeout);\r\n    }\r\n\r\n    onError(err) {\r\n        this.emitMessage(\"socket_error\", Chat.SERVER_WINDOW, err);\r\n        return this.socket.close();\r\n    }\r\n\r\n    onClose() {\r\n        this.socket.setTimeout(0, this.onTimeout);\r\n        if (this.state === \"connected\") {\r\n            this.emit(\"disconnect\");\r\n            return this.setReconnect();\r\n        }\r\n    }\r\n\r\n    onEnd() {\r\n        console.error(\"remote peer closed connection\");\r\n        if (this.state === \"connecting\" || this.state === \"connected\") {\r\n            this.emit(\"disconnect\");\r\n            return this.setReconnect();\r\n        }\r\n    }\r\n\r\n    setReconnect() {\r\n        const backoff = 2000 * Math.pow(2, this.exponentialBackoff);\r\n        this.state = \"reconnecting\";\r\n        this.reconnectTimeout = setTimeout(this.reconnect, backoff);\r\n        if (!(this.exponentialBackoff > 4)) {\r\n            return this.exponentialBackoff++;\r\n        }\r\n    }\r\n\r\n    reconnect() {\r\n        return this.connect();\r\n    }\r\n\r\n    onData(pdata) {\r\n        this.data = this.util.concatSocketData(this.data, pdata);\r\n        var dataView = new Uint8Array(this.data);\r\n        var _results = [];\r\n        while (dataView.length > 0) {\r\n            var cr = false;\r\n            var crlf = null;\r\n            for (var i = 0; i < dataView.length; ++i) {\r\n                var d = dataView[i];\r\n                if (d === 0x0d) {\r\n                    // Even though the spec says that lines should end with CRLF some\r\n                    // servers (e.g. irssi proxy) just send LF.\r\n                    cr = true;\r\n                } else if (d === 0x0a) {\r\n                    crlf = i;\r\n                    break;\r\n                } else {\r\n                    cr = false;\r\n                }\r\n            }\r\n            if (crlf !== null) {\r\n                var line = this.data.slice(0, cr ? crlf - 1 : crlf);\r\n                this.data = this.data.slice(crlf + 1);\r\n                dataView = new Uint8Array(this.data);\r\n                _results.push(this.util.fromSocketData(line, lineStr => {\r\n                    this._log(\"<=\", `(${this.server})`, lineStr);\r\n                    return this.onServerMessage(this.util.parseCommand(lineStr));\r\n                }));\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return _results;\r\n    }\r\n\r\n    onDrain() {\r\n        if (this.endSocketOnDrain) {\r\n            this.socket.close();\r\n        }\r\n        return this.endSocketOnDrain = false;\r\n    }\r\n\r\n    send(...args) {\r\n        var msg = this.util.makeCommand(...args);\r\n        this._log(\"=>\", this.server, msg.slice(0, msg.length - 2));\r\n        return this.util.toSocketData(msg, arr => this.socket.write(arr));\r\n    }\r\n\r\n    sendIfConnected(...args) {\r\n        if (this.state === \"connected\") {\r\n            return this.send(...args);\r\n        }\r\n    }\r\n\r\n    onServerMessage(cmd) {\r\n        if (/^\\d{3}$/.test(cmd.command)) {\r\n            cmd.command = parseInt(cmd.command, 10);\r\n        }\r\n        if (this.serverResponseHandler.canHandle(cmd.command)) {\r\n            return this.handle(cmd.command, this.util.parsePrefix(cmd.prefix), ...cmd.params);\r\n        } else {\r\n            return this.emitMessage(\"other\", Chat.SERVER_WINDOW, cmd);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @param  {any[]} ...args [cmd, ...rest]\r\n     */\r\n    handle(...args) {\r\n        return this.serverResponseHandler.handle(...args);\r\n    }\r\n\r\n    emit(name, channel, ...rest) {\r\n        var event = new Event(\"server\", name, ...rest);\r\n        event.setContext(this.server, channel);\r\n        return this.emitCustomEvent(event);\r\n    }\r\n\r\n    emitMessage(name, channel, ...rest) {\r\n        var event = new Event(\"message\", name, ...rest);\r\n        event.setContext(this.server, channel);\r\n        return this.emitCustomMessage(event);\r\n    }\r\n\r\n    emitCustomMessage(event) {\r\n        return this.emitCustomEvent(event);\r\n    }\r\n\r\n    emitCustomEvent(event) {\r\n        return super.emit.call(this, event.type, event);\r\n    }\r\n\r\n    isOwnNick(nick) {\r\n        return util.nicksEqual(this.nick, nick);\r\n    }\r\n\r\n    isValidChannelPrefix(channel) {\r\n        var prefixes = this.support[\"chantypes\"] || \"#&\";\r\n        return prefixes.indexOf(channel.substr(0, 1)) != -1;\r\n    }\r\n}\r\n\r\n// Android doesn't implement ArrayBuffer.slice()\r\nwindow.ArrayBuffer.prototype.slice = window.ArrayBuffer.prototype.slice || window.ArrayBuffer.prototype.webkitSlice || function(...args) {\r\n    var src = Uint8Array.prototype.subarray.apply(new Uint8Array(this), args);\r\n    var dst = new Uint8Array(src.length);\r\n    dst.set(src);\r\n    return dst.buffer;\r\n};\r\n","import {\r\n    getFieldOrNull,\r\n    isOnline,\r\n    getReadableList\r\n} from \"../utils/utils\";\r\nimport {escape} from \"../utils/html\";\r\nimport {nicksEqual} from \"../irc/irc_util\";\r\nimport CTCPHandler from \"../irc/ctcp_handler\";\r\nimport Chat from \"./chat\";\r\nimport Event from \"../utils/event\";\r\n\r\n/**\r\n * Represents a user command, like /kick or /say.\r\n */\r\nexport default class UserCommand {\r\n    constructor(name, description) {\r\n        this.description = description;\r\n        this.name = name;\r\n        this.describe(this.description);\r\n        this._hasValidArgs = false;\r\n    }\r\n    /**\r\n     * Describe the command using the following format:\r\n     * * description - a description of what the command does; used with /help <command>\r\n     * * category - what category the command falls under. This is used with /help\r\n     * * params - what parameters the command takes, 'opt_<name>' for optional, '<name>...' for variable\r\n     *\r\n     * * validateArgs - returns a truthy variable if the given arguments are valid.\r\n     * * requires - what the command requires to run (e.g. a connections to an IRC server)\r\n     * * usage - manually set a usage message, one will be generated if not specified\r\n     * * run - the function to call when the command is run\r\n     */\r\n    describe(description) {\r\n        var _ref1;\r\n        if (this._description == null) {\r\n            this._description = description.description;\r\n        }\r\n        if (this._params == null) {\r\n            this._params = description.params;\r\n        }\r\n        if (this._requires == null) {\r\n            this._requires = description.requires;\r\n        }\r\n        if (this._validateArgs == null) {\r\n            this._validateArgs = description.validateArgs;\r\n        }\r\n        if (this._usage == null) {\r\n            this._usage = description.usage;\r\n        }\r\n        if (this.run == null) {\r\n            this.run = description.run;\r\n        }\r\n        return (_ref1 = this.category) != null ? _ref1 : this.category = description.category;\r\n    }\r\n    /**\r\n     * Try running the command. A command can fail to run if its requirements\r\n     *  aren't met (e.g. needs a connection to the internet) or the specified\r\n     *  arguments are invalid. In these cases a help message is displayed.\r\n     * @param {Context} context Which server/channel the command came from.\r\n     * @param {Object...} args Arguments for the command.\r\n     */\r\n    tryToRun(context, ...rest) {\r\n        this.setContext(context);\r\n        if (!this.canRun()) {\r\n            if (this.shouldDisplayFailedToRunMessage()) {\r\n                this.displayHelp();\r\n            }\r\n            return;\r\n        }\r\n        this.setArgs(...rest);\r\n        if (this._hasValidArgs) {\r\n            return this.run();\r\n        } else {\r\n            return this.displayHelp();\r\n        }\r\n    }\r\n\r\n    setChat(chat) {\r\n        this.chat = chat;\r\n    }\r\n\r\n    setContext(context) {\r\n        this.win = this.chat.determineWindow(context);\r\n        if (this.win !== Chat.NO_WINDOW) {\r\n            this.conn = this.win.conn;\r\n            return this.chan = this.win.target;\r\n        }\r\n    }\r\n\r\n    setArgs(...args) {\r\n        return this._hasValidArgs = this._tryToAssignArgs(args) && (!this._validateArgs || !!this._validateArgs());\r\n    }\r\n\r\n    _tryToAssignArgs(args) {\r\n        var params;\r\n        this.args = [];\r\n        this._removeTrailingWhiteSpace(args);\r\n\r\n        if (!this._params) return args.length === 0;\r\n\r\n        this._resetParams();\r\n        this._truncateVariableArgs(args);\r\n        params = this._truncateExtraOptionalParams(args.length);\r\n\r\n        if (args.length !== params.length) return false;\r\n\r\n        params.forEach((param, i) => this[this._getParamName(param)] = args[i]);\r\n\r\n        this.args = args;\r\n        return true;\r\n    }\r\n\r\n    _resetParams() {\r\n        var param, _i, _len, _ref1, _results;\r\n        _ref1 = this._params;\r\n        _results = [];\r\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\r\n            param = _ref1[_i];\r\n            _results.push(this[this._getParamName(param)] = void 0);\r\n        }\r\n        return _results;\r\n    }\r\n    /**\r\n     * Remove empty strings from end of the array\r\n     * @param  {string[]} args\r\n     */\r\n    _removeTrailingWhiteSpace(args) {\r\n        while (args[args.length - 1] === \"\") {\r\n            args.pop();\r\n        }\r\n        return args;\r\n    }\r\n\r\n    /**\r\n     * Join all arguments that fit under the variable argument param.\r\n     * Note: only the last argument is allowd to be variable.\r\n     */\r\n    _truncateVariableArgs(args) {\r\n        var _ref1;\r\n        if (args.length < this._params.length) {\r\n            return args;\r\n        }\r\n        if (this._isVariable(this._params[this._params.length - 1])) {\r\n            args[this._params.length - 1] = (_ref1 = args.slice(this._params.length - 1)) != null ? _ref1.join(\" \") : void 0;\r\n            return args.length = this._params.length;\r\n        }\r\n    }\r\n\r\n    _truncateExtraOptionalParams(numArgs) {\r\n        var i, param, params, _i, _ref1,\r\n            extraParams = this._params.length - numArgs;\r\n        if (extraParams <= 0) {\r\n            return this._params;\r\n        }\r\n        params = [];\r\n        for (i = _i = _ref1 = this._params.length - 1;\r\n            _ref1 <= 0 ? _i <= 0 : _i >= 0;\r\n            i = _ref1 <= 0 ? ++_i : --_i) {\r\n            param = this._params[i];\r\n            if (extraParams > 0 && this._isOptional(param)) {\r\n                extraParams--;\r\n            } else {\r\n                params.splice(0, 0, param);\r\n            }\r\n        }\r\n        return params;\r\n    }\r\n\r\n    /**\r\n     * When a command can't run, determine if a helpful message should be\r\n     *  displayed to the user.\r\n     */\r\n    shouldDisplayFailedToRunMessage() {\r\n        if (this.win === Chat.NO_WINDOW) {\r\n            return false;\r\n        }\r\n        return this.name !== \"say\";\r\n    }\r\n\r\n    /**\r\n     * Commands can only run if their requirements are met (e.g. connected to the\r\n     *  internet, in a channel, etc) and a run method is defined.\r\n     */\r\n    canRun(opt_context) {\r\n        if (opt_context) {\r\n            this.setContext(opt_context);\r\n        }\r\n        if (!this.run) {\r\n            return false;\r\n        }\r\n        if (!this._requires) {\r\n            return true;\r\n        }\r\n\r\n        // return false if some requirements are not met, else return true\r\n        return !this._requires.some(requirement => !this._meetsRequirement(requirement));\r\n    }\r\n\r\n    _meetsRequirement(requirement) {\r\n        switch (requirement) {\r\n        case \"online\":\r\n            return isOnline();\r\n        case \"connection\":\r\n            return !!this.conn && isOnline();\r\n        case \"channel\":\r\n            return !!this.chan;\r\n        default:\r\n            return getFieldOrNull(this, [\"conn\", \"irc\", \"state\"]) === requirement;\r\n        }\r\n    }\r\n\r\n    displayHelp(win) {\r\n        if (win == null) {\r\n            win = this.win;\r\n        }\r\n        return win.message(\"\", escape(this.getHelp()), \"notice help\");\r\n    }\r\n\r\n    getHelp() {\r\n        var usageText, _ref1,\r\n            descriptionText = this._description ? `, ${this._description}` : \"\";\r\n        if (this._usage) {\r\n            usageText = `${this._usage}`;\r\n        }\r\n        if (usageText == null) {\r\n            usageText = ((_ref1 = this._params) != null ? _ref1.length : void 0) > 0 ? this._getUsage() : \"\";\r\n        }\r\n        return `${this.name.toUpperCase()} ${usageText}${descriptionText}.`;\r\n    }\r\n\r\n    _getUsage() {\r\n        return this._params.map(param => {\r\n            let paramName = this._getParamName(param);\r\n            return this._isOptional(param)\r\n                ? `[${paramName}]`\r\n                : `<${paramName}>`;\r\n        }).join(\" \");\r\n    }\r\n\r\n    _getParamName(param) {\r\n        if (this._isOptional(param)) {\r\n            param = param.slice(4);\r\n        }\r\n        if (this._isVariable(param)) {\r\n            param = param.slice(0, +(param.length - 4) + 1 || 9e9);\r\n        }\r\n        return param;\r\n    }\r\n\r\n    _isOptional(param) {\r\n        return param.indexOf(\"opt_\") === 0;\r\n    }\r\n\r\n    _isVariable(param) {\r\n        return (param != null ? param.slice(param.length - 3) : void 0) === \"...\";\r\n    }\r\n\r\n    isOwnNick(nick) {\r\n        var _ref1;\r\n        if (nick == null) {\r\n            nick = this.nick;\r\n        }\r\n        return nicksEqual((_ref1 = this.conn) != null ? _ref1.irc.nick : void 0, nick);\r\n    }\r\n\r\n    displayDirectMessage(nick, message) {\r\n        var _ref1;\r\n        if (nick == null) {\r\n            nick = this.nick;\r\n        }\r\n        if (message == null) {\r\n            message = this.message;\r\n        }\r\n        if (((_ref1 = this.conn) != null ? _ref1.windows[nick] : void 0) != null) {\r\n            return this._displayDirectMessageInPrivateChannel(nick, message);\r\n        } else {\r\n            return this._displayDirectMessageInline(nick, message);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Used with /msg. Displays the message in a private channel.\r\n     */\r\n    _displayDirectMessageInPrivateChannel(nick, message) {\r\n        var context;\r\n        context = {\r\n            server: this.conn.name,\r\n            channel: nick\r\n        };\r\n        return this.chat.displayMessage(\"privmsg\", context, this.conn.irc.nick, message);\r\n    }\r\n\r\n    /**\r\n     * Used with /msg. Displays the private message in the current window.\r\n     * Direct messages always display inline until the user receives a response.\r\n     */\r\n    _displayDirectMessageInline(nick, message) {\r\n        return this.displayMessageWithStyle(\"privmsg\", nick, message, \"direct\");\r\n    }\r\n\r\n    displayMessage(...args) {\r\n        var type = args[0],\r\n            rest = 2 <= args.length ? args.slice(1) : [],\r\n            context = {\r\n                server: getFieldOrNull(this, [\"conn\", \"name\"]),\r\n                channel: this.chan\r\n            };\r\n        return this.chat.displayMessage(type, context, ...rest);\r\n    }\r\n\r\n    /**\r\n     * Displays a message with a custom style. This is useful for indicating that\r\n     *  a message be rendered in a special way (e.g. no pretty formatting).\r\n     */\r\n    displayMessageWithStyle(...args) {\r\n        var i, type = args[0],\r\n            rest = 3 <= args.length ? args.slice(1, i = args.length - 1) : (i = 1, []),\r\n            style = args[i++],\r\n            e = new Event(\"message\", type, ...rest);\r\n        e.setContext(getFieldOrNull(this, [\"conn\", \"name\"]), this.chan);\r\n        e.addStyle(style);\r\n        return this.chat.emit(e.type, e);\r\n    }\r\n\r\n    handleCTCPRequest(nick, type) {\r\n        var delimiter = CTCPHandler.DELIMITER,\r\n            message = delimiter + type + delimiter;\r\n        this.displayDirectMessage(nick, `CTCP ${type}`);\r\n        return this.conn.irc.doCommand(\"PRIVMSG\", nick, message);\r\n    }\r\n\r\n    /**\r\n     * Used to set the arguments for MODE shortcut commands.\r\n     * @param {string} type E.g. /op, /voice, etc.\r\n     */\r\n    setModeArgs(type) {\r\n        this.nicks = [this.nick];\r\n        this.target = this.chan;\r\n        return this.mode = type;\r\n    }\r\n\r\n    /**\r\n     * Determine if the given string is a valid mode expression.\r\n     * TODO: This can be improved. (e.g. ++ and +a++ shouldn't be valid)\r\n     * @param {string} mode E.g. +o, -o, +v, etc.\r\n     */\r\n    isValidMode(mode) {\r\n        var _ref1;\r\n        return (_ref1 = mode != null ? mode[0] : void 0) === \"+\" || _ref1 === \"-\";\r\n    }\r\n\r\n    listInstalledScripts() {\r\n        var names = this.chat.scriptHandler.getScriptNames();\r\n        if (names.isEmpty()) {\r\n            return \"No scripts are currently installed\";\r\n        } else {\r\n            return `Installed scripts: ${getReadableList(names)}`;\r\n        }\r\n    }\r\n}\r\n","/**\r\n * Parses raw commands from the user. Used with the /raw command.\r\n */\r\nclass CustomCommandParser {\r\n    parse(...args) {\r\n        var params,\r\n            channel = args[0],\r\n            rest = 2 <= args.length ? args.slice(1) : [];\r\n        if (rest[1] === \"-c\") {\r\n            params = this._mergeQuotedWords(rest.slice(2));\r\n            return [rest[0].toUpperCase(), channel, ...params];\r\n        } else {\r\n            params = this._mergeQuotedWords(rest.slice(1));\r\n            return [rest[0].toUpperCase(), ...params];\r\n        }\r\n    }\r\n\r\n    _mergeQuotedWords(words) {\r\n        var i, word, _i, _len,\r\n            start = -1;\r\n\r\n        for (i = _i = 0, _len = words.length; _i < _len; i = ++_i) {\r\n            word = words[i];\r\n            if (word[0] === \"\\\"\" && start === -1) {\r\n                start = i;\r\n            }\r\n            if (word[word.length - 1] === \"\\\"\" && start !== -1) {\r\n                words.splice(start, i - start + 1, words.slice(start, +i + 1 || 9e9).join(\" \"));\r\n                words[start] = this._trimQuotes(words[start]);\r\n                return this._mergeQuotedWords(words);\r\n            }\r\n        }\r\n        return words;\r\n    }\r\n\r\n    _trimQuotes(word) {\r\n        return word.slice(1, +(word.length - 2) + 1 || 9e9);\r\n    }\r\n}\r\n\r\nexport default new CustomCommandParser;\r\n","import iter from \"lazy.js\";\r\n\r\nexport default class Script {\r\n    constructor(sourceCode, frame) {\r\n        this.sourceCode = sourceCode;\r\n        this.frame = frame;\r\n        this.id = Script.getUniqueID();\r\n        this._messagesToHandle = [];\r\n        this._name = `script${this.id + 1}`;\r\n    }\r\n    postMessage(msg) {\r\n        return this.frame.postMessage(msg, \"*\");\r\n    }\r\n\r\n    shouldHandle(event) {\r\n        return this._messagesToHandle.indexOf(event.hook) >= 0;\r\n    }\r\n\r\n    /**\r\n     * Begin handling events of the given type and name.\r\n     * @param {string} type The event type (command, message or server)\r\n     * @param {string} name The name of the event (e.g. kick, NICK, privmsg, etc)\r\n     */\r\n    beginHandlingType(type, name) {\r\n        return this._messagesToHandle.push(`${type} ${name}`);\r\n    }\r\n\r\n    setName(_name) {\r\n        this._name = _name;\r\n    }\r\n\r\n    getName() {\r\n        return this._name;\r\n    }\r\n}\r\n\r\nScript.getScriptFromFrame = function (scripts, frame) {\r\n    return iter(scripts)\r\n        .values()\r\n        .find(script => script.frame === frame);\r\n};\r\n\r\nScript.scriptCount = 0;\r\n\r\nScript.getUniqueID = function () {\r\n    return this.scriptCount++;\r\n};\r\n","import {loadFromFileSystem} from \"../utils/utils\";\r\nimport Script from \"./script\";\r\nimport prepackagedScripts from \"./prepackaged/source_array\";\r\n\r\nclass ScriptLoader {\r\n    constructor() {\r\n        this._sendSourceCode = this._sendSourceCode.bind(this);\r\n        this._scripts = {};\r\n        addEventListener(\"message\", this._sendSourceCode);\r\n    }\r\n\r\n    _sendSourceCode(e) {\r\n        var script = Script.getScriptFromFrame(this._scripts, e.source);\r\n        if (script && e.data.type === \"onload\") {\r\n            script.postMessage({\r\n                type: \"source_code\",\r\n                sourceCode: script.sourceCode\r\n            });\r\n            return delete this._scripts[script.id];\r\n        }\r\n    }\r\n\r\n    loadPrepackagedScripts(callback) {\r\n        return prepackagedScripts.map(sourceCode => callback(this._createScript(sourceCode)));\r\n    }\r\n\r\n    loadScriptsFromStorage(scripts, callback) {\r\n        return scripts.map(script => callback(this._createScript(script.sourceCode)));\r\n    }\r\n\r\n    createScriptFromFileSystem(callback) {\r\n        /*eslint no-console: 0 */\r\n        return loadFromFileSystem(sourceCode => {\r\n            try {\r\n                return callback(this._createScript(sourceCode));\r\n            } catch (error) {\r\n                return console.error(\"failed to eval:\", error.toString());\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @param {string} sourceCode The raw JavaScript source code of the script.\r\n     * @return {Script} Returns a handle to the script.\r\n     */\r\n    _createScript(sourceCode) {\r\n        var frame = this._createIframe(),\r\n            script = new Script(sourceCode, frame);\r\n        this._scripts[script.id] = script;\r\n        return script;\r\n    }\r\n\r\n    _createIframe() {\r\n        var iframe;\r\n        iframe = document.createElement(\"iframe\");\r\n        iframe.src = \"plugenv/script_frame.html\";\r\n        iframe.style.display = \"none\";\r\n        document.body.appendChild(iframe);\r\n        return iframe.contentWindow;\r\n    }\r\n\r\n    /**\r\n     * Removes the iFrame in which the script is running from the DOM.\r\n     * @param {Script} script\r\n     */\r\n    unloadScript(script) {\r\n        document.body.removeChild(script.frame);\r\n        return delete script.frame;\r\n    }\r\n}\r\n\r\nexport default new ScriptLoader;\r\n","/*eslint no-console: [\"error\", { allow: [\"info\", \"error\"] }] */\r\nimport MessageHandler from \"../utils/message_handler\";\r\nimport UserCommand from \"./user_command\";\r\nimport userCommandList from \"./user_command_list\";\r\nimport iter from \"lazy.js\";\r\n\r\n/**\r\n * Handles user commands, including providing help messages and determining if a\r\n *  command can be run in the current context.\r\n */\r\nexport default class UserCommandHandler extends MessageHandler {\r\n    constructor(chat) {\r\n        super(chat);\r\n        this.chat = chat;\r\n        this._handlers = {};\r\n        this._init();\r\n    }\r\n\r\n    getCommands() {\r\n        return this._handlers;\r\n    }\r\n\r\n    getCommand(command) {\r\n        return this._handlers[command];\r\n    }\r\n\r\n    listenTo(emitter) {\r\n        return emitter.on(\"command\", e => {\r\n            if (this.canHandle(e.name)) {\r\n                return this.handle(e.name, e, ...e.args);\r\n            }\r\n        });\r\n    }\r\n\r\n    handle(type, context, ...rest) {\r\n        if (!this._isValidUserCommand(type)) {\r\n            // The command must be a developer command\r\n            super.handle(type, context, ...rest);\r\n            return;\r\n        }\r\n        return this._handlers[type].tryToRun(context, ...rest);\r\n    }\r\n\r\n    _isValidUserCommand(type) {\r\n        return type in this._handlers;\r\n    }\r\n\r\n    /**\r\n     * Creates all user commands. The \"this\" parameter in the run() and\r\n     *  validateArgs() functions is UserCommand.\r\n     * @this {UserCommand}\r\n     */\r\n    _init() {\r\n        // Register commands\r\n        iter(userCommandList)\r\n            .pairs()\r\n            .each(([name, spec]) => this._addCommand(name, spec));\r\n    }\r\n    /**\r\n     * @param  {string} name\r\n     * @param  {{description: string, category: string, params: string[], requires: string[]?, extends: string?, usage: string, validateArgs: Function, run: function}} spec\r\n     */\r\n    _addCommand(name, spec) {\r\n        var command = new UserCommand(name, spec),\r\n            commandToExtend = this._handlers[spec[\"extends\"]];\r\n        if (commandToExtend) {\r\n            command.describe(commandToExtend.description);\r\n        }\r\n        command.setChat(this.chat);\r\n        return this._handlers[name] = command;\r\n    }\r\n}\r\n","import {assert} from \"../utils/utils\";\r\n\r\n/**\r\n * An ordered list of windows with channels sorted by server then alphebetically\r\n * by name.\r\n */\r\nexport default class WindowList {\r\n    constructor() {\r\n        this._servers = [];\r\n        this.length = 0;\r\n    }\r\n    /**\r\n     * Get the correct window given the server and optionally the channel.\r\n     * @param  {string|number} serverName\r\n     * @param  {any} chan\r\n     * @return {Window|null} window\r\n     */\r\n    get(serverName, chan) {\r\n        if (typeof serverName === \"number\")\r\n            return this._getByNumber(serverName);\r\n\r\n        for (let i = 0, serLen = this._servers.length; i < serLen; i++) {\r\n            let server = this._servers[i];\r\n            if (serverName !== server.name) continue;\r\n            if (chan == null) return server.serverWindow;\r\n            for (let j = 0, winLen = server.windows.length; j < winLen; j++) {\r\n                let win = server.windows[j];\r\n                if (win.target === chan.toLowerCase()) return win;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    _getByNumber(num) {\r\n        var servers = this._servers;\r\n        for (let i = 0, len = servers.length; i < len; i++) {\r\n            let server = servers[i];\r\n            if (num === 0) return server.serverWindow;\r\n            else num -= 1;\r\n            if (num < server.windows.length) return server.windows[num];\r\n            else num -= server.windows.length;\r\n        }\r\n        return void 0;\r\n    }\r\n    /**\r\n     * The same as get(), but the index excludes server windows.\r\n     */\r\n    getChannelWindow(index) {\r\n        var servers = this._servers;\r\n        for (let i = 0, len = servers.length; i < len; i++) {\r\n            let server = servers[i];\r\n            if (index < server.windows.length) {\r\n                return server.windows[index];\r\n            } else {\r\n                index -= server.windows.length;\r\n            }\r\n        }\r\n        return void 0;\r\n    }\r\n    /**\r\n     * The same as get(), but the index excludes channel windows.\r\n     */\r\n    getServerWindow(index) {\r\n        var serverWindow = this._servers[index];\r\n        return serverWindow != null ? serverWindow.serverWindow : void 0;\r\n    }\r\n\r\n    add(win) {\r\n        if (win.target != null) {\r\n            this._addChannelWindow(win);\r\n        } else {\r\n            this._addServerWindow(win);\r\n        }\r\n        return this.length++;\r\n    }\r\n\r\n    _addChannelWindow(win) {\r\n        var conn = win.conn,\r\n            servers = this._servers;\r\n        assert((conn != null ? conn.name : void 0) != null);\r\n        for (let i = 0, len = servers.length; i < len; i++) {\r\n            let server = servers[i];\r\n            if (win.conn.name === server.name) {\r\n                this._addWindowToServer(server, win);\r\n                return;\r\n            }\r\n        }\r\n        throw `added channel window with no corresponding connection window: ${win}`;\r\n    }\r\n\r\n    _addWindowToServer(server, win) {\r\n        server.windows.push(win);\r\n        return server.windows.sort((win1, win2) => win1.target.localeCompare(win2.target));\r\n    }\r\n\r\n    _addServerWindow(win) {\r\n        var conn = win.conn;\r\n        assert((conn != null ? conn.name : void 0) != null);\r\n        return this._servers.push({\r\n            name: win.conn.name,\r\n            serverWindow: win,\r\n            windows: []\r\n        });\r\n    }\r\n\r\n    remove(win) {\r\n        var candidate, i, server, _i, _j, _len, _len1, _ref1, _ref2, _ref3;\r\n        _ref1 = this._servers;\r\n        for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {\r\n            server = _ref1[i];\r\n            if (server.name === ((_ref2 = win.conn) != null ? _ref2.name : void 0)) {\r\n                if (win.isServerWindow()) {\r\n                    this._servers.splice(i, 1);\r\n                    this.length -= server.windows.length + 1;\r\n                    return server.windows.concat([server.serverWindow]);\r\n                }\r\n                _ref3 = server.windows;\r\n                for (i = _j = 0, _len1 = _ref3.length; _j < _len1; i = ++_j) {\r\n                    candidate = _ref3[i];\r\n                    if (candidate.target === win.target) {\r\n                        server.windows.splice(i, 1);\r\n                        this.length--;\r\n                        return [candidate];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Given a window, returns its corresponding server window.\r\n     * @param {Window} win\r\n     * @return {Window|undefined} The server window.\r\n     */\r\n    getServerForWindow(win) {\r\n        var server, _i, _len, _ref1, _ref2;\r\n        if (win.isServerWindow()) {\r\n            return win;\r\n        }\r\n        _ref1 = this._servers;\r\n        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\r\n            server = _ref1[_i];\r\n            if (server.name === ((_ref2 = win.conn) != null ? _ref2.name : void 0)) {\r\n                return server.serverWindow;\r\n            }\r\n        }\r\n        return void 0;\r\n    }\r\n\r\n    indexOf(win) {\r\n        var candidate, count, i, server, _i, _j, _len, _len1, _ref1, _ref2, _ref3;\r\n        if (((_ref1 = win.conn) != null ? _ref1.name : void 0) == null) {\r\n            return -1;\r\n        }\r\n        count = 0;\r\n        _ref2 = this._servers;\r\n        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\r\n            server = _ref2[_i];\r\n            if (win.conn.name === server.name) {\r\n                if (win.target == null) {\r\n                    return count;\r\n                }\r\n                count++;\r\n                _ref3 = server.windows;\r\n                for (i = _j = 0, _len1 = _ref3.length; _j < _len1; i = ++_j) {\r\n                    candidate = _ref3[i];\r\n                    if (candidate.equals(win)) {\r\n                        return count + i;\r\n                    }\r\n                }\r\n                return -1;\r\n            } else {\r\n                count += server.windows.length + 1;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    /**\r\n     * Return the index of a channel relative to other channels of the same server.\r\n     */\r\n    localIndexOf(win) {\r\n        var candidate, i, server, _i, _j, _len, _len1, _ref1, _ref2, _ref3;\r\n        if (((_ref1 = win.conn) != null ? _ref1.name : void 0) == null) {\r\n            return -1;\r\n        }\r\n        _ref2 = this._servers;\r\n        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {\r\n            server = _ref2[_i];\r\n            if (win.conn.name !== server.name) {\r\n                continue;\r\n            }\r\n            _ref3 = server.windows;\r\n            for (i = _j = 0, _len1 = _ref3.length; _j < _len1; i = ++_j) {\r\n                candidate = _ref3[i];\r\n                if (candidate.equals(win)) {\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    /**\r\n     * Returns the index of a server relative to other servers.\r\n     */\r\n    serverIndexOf(win) {\r\n        var i, server, _i, _len, _ref1, _ref2;\r\n        if (((_ref1 = win.conn) != null ? _ref1.name : void 0) == null) {\r\n            return -1;\r\n        }\r\n        _ref2 = this._servers;\r\n        for (i = _i = 0, _len = _ref2.length; _i < _len; i = ++_i) {\r\n            server = _ref2[i];\r\n            if (win.conn.name === server.name) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n","/**\r\n * A UI element to inform and/or prompt the user.\r\n */\r\nexport default class Notice {\r\n    constructor() {\r\n        this.$notice = $(\"#notice\");\r\n        this.$content = $(\"#notice .content\");\r\n        this.$close = $(\"#notice button.close\");\r\n        this.$option1 = $(\"#notice button.option1\");\r\n        this.$option2 = $(\"#notice button.option2\");\r\n        this.$close.click(() => this._hide());\r\n    }\r\n    /**\r\n     * Display a message to the user.\r\n     * The prompt representation has the following format:\r\n     *  \"message_text [button_1_text] [button_2_text]\"\r\n     *\r\n     * @param {string} representation A string representation of the message.\r\n     * @param {...function} callbacks Specifies what function should be called when\r\n     *  an option is clicked.\r\n     */\r\n    prompt(...args) {\r\n        var representation = args[0],\r\n            callbacks = 2 <= args.length ? args.slice(1) : [];\r\n        this._hide();\r\n        this._callbacks = callbacks;\r\n        this._parseRepresentation(representation);\r\n        this.$option1.click(() => {\r\n            var _base;\r\n            this._hide();\r\n            return typeof (_base = this._callbacks)[0] === \"function\" ? _base[0]() : void 0;\r\n        });\r\n        this.$option2.click(() => {\r\n            var _base;\r\n            this._hide();\r\n            return typeof (_base = this._callbacks)[1] === \"function\" ? _base[1]() : void 0;\r\n        });\r\n        return this._show();\r\n    }\r\n\r\n    close() {\r\n        return this._hide();\r\n    }\r\n\r\n    _hide() {\r\n        this.$notice.addClass(\"hide\");\r\n        this.$option1.off(\"click\");\r\n        return this.$option2.off(\"click\");\r\n    }\r\n\r\n    _show() {\r\n        this.$notice.removeClass(\"hide\");\r\n    }\r\n\r\n    _parseRepresentation(representation) {\r\n        var options;\r\n        this._setMessageText(representation);\r\n        options = representation.match(/\\[.+?\\]/g);\r\n        this._setOptionText(this.$option1, options != null ? options[0] : void 0);\r\n        return this._setOptionText(this.$option2, options != null ? options[1] : void 0);\r\n    }\r\n\r\n    _setMessageText(representation) {\r\n        representation = representation.split(\"[\")[0];\r\n        return this.$content.text($.trim(representation));\r\n    }\r\n\r\n    _setOptionText(button, textWithBrackets) {\r\n        var text;\r\n        if (textWithBrackets) {\r\n            text = textWithBrackets.slice(1, +(textWithBrackets.length - 2) + 1 || 9e9);\r\n            button.removeClass(\"hidden\");\r\n            return button.text(text);\r\n        } else if (!button.hasClass(\"hidden\")) {\r\n            return button.addClass(\"hidden\");\r\n        }\r\n    }\r\n}\r\n","import EventEmitter from \"../utils/event_emitter\";\r\nimport {getLogger, removeFromArray} from \"../utils/utils\";\r\n\r\n/**\r\n * A list of elements that can be manipulated, keyed by case-insensitive strings.\r\n */\r\nexport default class HTMLList extends EventEmitter {\r\n    constructor($list, $template) {\r\n        super();\r\n        this.$list = $list;\r\n        this.$template = $template;\r\n        this.nodes = {};\r\n        this.nodeNames = [];\r\n        this._addFooterNode();\r\n        this._log = getLogger(this);\r\n    }\r\n\r\n    _addFooterNode() {\r\n        this._footerNode = this._createNode(\"footer\");\r\n        this.$list.append(this._footerNode.html);\r\n        this._footerNode.html.addClass(\"footer\");\r\n    }\r\n\r\n    // Sets the text of the footer node, e.g. '<add channel>' or '<add server>'.\r\n    setFooterNodeText(text) {\r\n        this._footerNode.content.text(text);\r\n    }\r\n\r\n    add(name) {\r\n        return this.insert(this.nodeNames.length, name);\r\n    }\r\n\r\n    insert(index, name) {\r\n        var key = name.toLowerCase();\r\n        if (key in this.nodes) {\r\n            return;\r\n        }\r\n        if (index < 0 || index > this.nodeNames.length) {\r\n            throw \"invalid index: \" + index + \"/\" + this.nodeNames.length;\r\n        }\r\n        var newNode = this._createNode(name);\r\n        this._insertHTML(index, newNode);\r\n        this.nodes[key] = newNode;\r\n        return this.nodeNames.splice(index, 0, name);\r\n    }\r\n\r\n    _insertHTML(index, newNode) {\r\n        var nextNode = this.get(index) || this._footerNode;\r\n        this._log(\"adding\", newNode, \"at\", index, \"with next node\", nextNode);\r\n        newNode.html.insertBefore(nextNode.html);\r\n    }\r\n\r\n    get(index) {\r\n        var key = this.nodeNames[index];\r\n        if (key) {\r\n            key = key.toLowerCase();\r\n            return this.nodes[key];\r\n        }\r\n        return false;\r\n    }\r\n\r\n    getPrevious(nodeName) {\r\n        var i = this.nodeNames.indexOf(nodeName);\r\n        return this.nodeNames[i - 1];\r\n    }\r\n\r\n    getNext(nodeName) {\r\n        var i = this.nodeNames.indexOf(nodeName);\r\n        return this.nodeNames[i + 1];\r\n    }\r\n\r\n    remove(name) {\r\n        var key = name.toLowerCase(),\r\n            node = this.nodes[key];\r\n\r\n        this._log(\"removing\", node);\r\n\r\n        if (node) {\r\n            node.html.remove();\r\n            delete this.nodes[key];\r\n            return removeFromArray(this.nodeNames, key);\r\n        }\r\n    }\r\n\r\n    clear() {\r\n        this.nodes = {};\r\n        this.nodeNames = [];\r\n        this.$list.find(\"li:not(.footer)\").remove();\r\n    }\r\n\r\n    addClass(name, c) {\r\n        var _ref1;\r\n        return (_ref1 = this.nodes[name]) != null ? _ref1.html.addClass(c) : void 0;\r\n    }\r\n\r\n    removeClass(name, c) {\r\n        var _ref1;\r\n        return (_ref1 = this.nodes[name]) != null ? _ref1.html.removeClass(c) : void 0;\r\n    }\r\n\r\n    hasClass(nodeName, c) {\r\n        var _ref1;\r\n        return (_ref1 = this.nodes[nodeName]) != null ? _ref1.html.hasClass(c) : void 0;\r\n    }\r\n\r\n    rename(name, text) {\r\n        var _ref1;\r\n        return (_ref1 = this.nodes[name]) != null ? _ref1.content.text(text) : void 0;\r\n    }\r\n\r\n    _createNode(name) {\r\n        var node = {\r\n            html: this._htmlify(name),\r\n            name: name\r\n        };\r\n        node.content = $(\".content-item\", node.html);\r\n        node.html.mousedown(event => {\r\n            switch (event.which) {\r\n            case 1:\r\n                if ($(event.target).hasClass(\"remove-button\")) {\r\n                    this._emitClickEvent(node, \"remove_button_clicked\");\r\n                } else {\r\n                    this._handleClick(node);\r\n                }\r\n                break;\r\n            case 2:\r\n                return this._handleMiddleClick(node);\r\n            // case 3: // not handling right-clicks\r\n            }\r\n        });\r\n        node.html.dblclick(event => {\r\n            if (event.which == 1) {\r\n                return this._handleDoubleClick(node);\r\n            }\r\n        });\r\n        return node;\r\n    }\r\n\r\n    _handleClick(node) {\r\n        this._emitClickEvent(node, \"clicked\");\r\n    }\r\n\r\n    _handleMiddleClick(node) {\r\n        this._emitClickEvent(node, \"midclicked\");\r\n    }\r\n\r\n    _handleDoubleClick(node) {\r\n        this._emitClickEvent(node, \"dblclicked\");\r\n    }\r\n\r\n    _emitClickEvent(node, eventName) {\r\n        var emitType;\r\n        if (node == this._footerNode) {\r\n            emitType = `footer_${eventName}`;\r\n        } else {\r\n            emitType = eventName;\r\n        }\r\n        this.emit(emitType, node.name);\r\n    }\r\n\r\n    _htmlify(name) {\r\n        var html = this.$template.clone();\r\n        $(\".content-item\", html).text(name);\r\n        return html;\r\n    }\r\n}\r\n","import EventEmitter from \"../utils/event_emitter\";\r\nimport HTMLList from \"./html_list\";\r\n\r\n/**\r\n * A list of servers and channels to which the user is connected.\r\n */\r\nexport default class ChannelList extends EventEmitter {\r\n    constructor() {\r\n        super();\r\n        this._handleClick = this._handleClick.bind(this);\r\n        this._handleMiddleClick = this._handleMiddleClick.bind(this);\r\n        this.$surface = $(\"#rooms-container .rooms\");\r\n        this.roomsByServer = {};\r\n        this._addFooter();\r\n    }\r\n\r\n    _addFooter() {\r\n        this._footerHtml = this._createAndAppendServerHTML(\"+ add server\");\r\n        var serverRoomHtml = $(\".server\", this._footerHtml);\r\n        serverRoomHtml.addClass(\"footer\");\r\n        serverRoomHtml.mousedown(event => {\r\n            if (event.which == 1) {\r\n                this._handleAddServerClick();\r\n            }\r\n        });\r\n    }\r\n\r\n    select(server, channel) {\r\n        this._removeLastSelected();\r\n        this._addClass(server, channel, \"selected\");\r\n        this._addClass(server, null, \"current-server\");\r\n        this._removeClass(server, channel, \"activity\");\r\n        return this._removeClass(server, channel, \"mention\");\r\n    }\r\n\r\n    _removeLastSelected() {\r\n        this.removeFirstInstanceOfClass(\"selected\");\r\n        this.removeFirstInstanceOfClass(\"current-server\");\r\n    }\r\n\r\n    removeFirstInstanceOfClass(cssClass) {\r\n        var elementWithClass = $(`.${cssClass}`, this.$surface);\r\n        if (elementWithClass) {\r\n            elementWithClass.removeClass(cssClass);\r\n        }\r\n    }\r\n\r\n    activity(server, opt_channel) {\r\n        return this._addClass(server, opt_channel, \"activity\");\r\n    }\r\n\r\n    mention(server, opt_channel) {\r\n        return this._addClass(server, opt_channel, \"mention\");\r\n    }\r\n\r\n    remove(server, opt_channel) {\r\n        if (opt_channel != null) {\r\n            return this.roomsByServer[server].channels.remove(opt_channel);\r\n        } else {\r\n            this.roomsByServer[server].html.remove();\r\n            return delete this.roomsByServer[server];\r\n        }\r\n    }\r\n\r\n    insertChannel(i, server, channel) {\r\n        this.roomsByServer[server].channels.insert(i, channel);\r\n        return this.disconnect(server, channel);\r\n    }\r\n\r\n    /**\r\n     * Adds a server that will never have any channels, e.g. when we add the\r\n     * welcome window.\r\n     */\r\n    addAlwaysEmptyServer(serverName) {\r\n        this.addServer(serverName);\r\n        this._addClass(serverName, null, \"always-empty\");\r\n    }\r\n\r\n    addServer(serverName) {\r\n        var channels, html, server;\r\n        html = this._createAndAppendServerHTML(serverName);\r\n        server = $(\".server\", html);\r\n        channels = this._createChannelList(html);\r\n        this._handleMouseEvents(serverName, server, channels);\r\n        this.roomsByServer[serverName.toLowerCase()] = {\r\n            html: html,\r\n            server: server,\r\n            channels: channels\r\n        };\r\n        return this.disconnect(serverName);\r\n    }\r\n\r\n    _createAndAppendServerHTML(serverName) {\r\n        var html;\r\n        html = $(\"#templates .server-channels\").clone();\r\n        $(\".server .content-item\", html).text(serverName);\r\n        if (this._footerHtml) {\r\n            html.insertBefore(this._footerHtml);\r\n        } else {\r\n            this.$surface.append(html);\r\n        }\r\n        return html;\r\n    }\r\n\r\n    _createChannelList(html) {\r\n        var channelList, channelTemplate;\r\n        channelTemplate = $(\"#templates .channel\");\r\n        channelList = new HTMLList($(\".channels\", html), channelTemplate);\r\n        channelList.setFooterNodeText(\"+ add channel\");\r\n        return channelList;\r\n    }\r\n\r\n    _handleMouseEvents(serverName, server, channels) {\r\n        server.mousedown(event => {\r\n            if (event.which == 1) {\r\n                if ($(event.target).hasClass(\"remove-button\")) {\r\n                    this._handleRemoveRoom(serverName);\r\n                } else {\r\n                    this._handleClick(serverName);\r\n                }\r\n            }\r\n        });\r\n        channels.on(\"clicked\", channelName => this._handleClick(serverName, channelName));\r\n        channels.on(\"midclicked\", channelName => this._handleMiddleClick(serverName, channelName));\r\n        channels.on(\"footer_clicked\", () => this._handleAddChannelClick());\r\n        channels.on(\"remove_button_clicked\", channelName => this._handleRemoveRoom(serverName, channelName));\r\n    }\r\n\r\n    disconnect(server, opt_channel) {\r\n        return this._addClass(server, opt_channel, \"disconnected\");\r\n    }\r\n\r\n    connect(server, opt_channel) {\r\n        return this._removeClass(server, opt_channel, \"disconnected\");\r\n    }\r\n\r\n    _addClass(server, channel, c) {\r\n        if (channel != null) {\r\n            return this.roomsByServer[server].channels.addClass(channel.toLowerCase(), c);\r\n        } else {\r\n            return this.roomsByServer[server].server.addClass(c);\r\n        }\r\n    }\r\n\r\n    _removeClass(server, channel, c) {\r\n        if (channel != null) {\r\n            return this.roomsByServer[server].channels.removeClass(channel.toLowerCase(), c);\r\n        } else {\r\n            return this.roomsByServer[server].server.removeClass(c);\r\n        }\r\n    }\r\n\r\n    _handleClick(server, channel) {\r\n        return this.emit(\"clicked\", server, channel);\r\n    }\r\n\r\n    _handleMiddleClick(server, channel) {\r\n        return this.emit(\"midclicked\", server, channel);\r\n    }\r\n\r\n    _handleAddChannelClick() {\r\n        this.emit(\"help_type_command\", \"/join #\");\r\n    }\r\n\r\n    _handleAddServerClick() {\r\n        this.emit(\"help_type_command\", \"/server \");\r\n    }\r\n\r\n    _handleRemoveRoom(server, channel) {\r\n        this.emit(\"remove_button_clicked\", server, channel);\r\n    }\r\n}\r\n\r\n","import EventEmitter from \"../utils/event_emitter\";\r\nimport {truncateIfTooLarge} from \"../utils/utils\";\r\nimport Notification from \"./notification\";\r\n\r\nexport default class NotificationGroup extends EventEmitter {\r\n    constructor(opt_channel) {\r\n        super();\r\n        this._channel = opt_channel;\r\n        this._size = 0;\r\n        this._notification = null;\r\n        this._stubs = [];\r\n    }\r\n\r\n    add(item) {\r\n        var _ref1;\r\n        if ((_ref1 = this._notification) != null) {\r\n            _ref1.cancel();\r\n        }\r\n        this._size++;\r\n        this._createNotification(item);\r\n        return this._notification.show();\r\n    }\r\n\r\n    _createNotification(item) {\r\n        var body, title;\r\n        this._addStubIfUnique(item.getStub());\r\n        if (this._size === 1) {\r\n            title = item.getTitle();\r\n            body = item.getBody();\r\n        } else {\r\n            if (this._channel) {\r\n                title = `${this._size} notifications in ${this._channel}`;\r\n            } else {\r\n                title = `${this._size} notifications`;\r\n            }\r\n            body = this._stubs.join(\", \");\r\n        }\r\n        body = truncateIfTooLarge(body, 75);\r\n        this._notification = new Notification(title, body);\r\n        return this._addNotificationListeners();\r\n    }\r\n\r\n    _addStubIfUnique(stub) {\r\n        if (this._stubs.indexOf(stub) < 0) {\r\n            return this._stubs.push(stub);\r\n        }\r\n    }\r\n\r\n    _addNotificationListeners() {\r\n        this._notification.on(\"clicked\", () => this.emit(\"clicked\"));\r\n        return this._notification.on(\"close\", () => this._clear());\r\n    }\r\n\r\n    clear() {\r\n        var _ref1;\r\n        if ((_ref1 = this._notification) != null) {\r\n            _ref1.cancel();\r\n        }\r\n        this._size = 0;\r\n        return this._stubs = [];\r\n    }\r\n}\r\n","import {escape} from \"../utils/html\";\r\nimport iter from \"lazy.js\";\r\n\r\n/**\r\n * Displays help messages to the user, such as listing the available commands or\r\n *  keyboard shortcuts.\r\n */\r\nexport default class HelpMessageRenderer {\r\n    /**\r\n     * @param {function(opt_message, opt_style)} postMessage\r\n     */\r\n    constructor(postMessage) {\r\n        this._postMessage = postMessage;\r\n        this._commands = {};\r\n    }\r\n    /**\r\n     * Displays a help message for the given commands, grouped by category.\r\n     * @param {Object.<string: {category: string}>} commands\r\n     */\r\n    render(commands) {\r\n        this._commands = commands;\r\n        this._postMessage();\r\n        this._printCommands();\r\n        this._postMessage(escape(\"Type '/help <command>' to see details about a specific command.\"), \"notice help\");\r\n        return this._postMessage(\"Type '/hotkeys' to see the list of keyboard shortcuts.\", \"notice help\");\r\n    }\r\n\r\n    _printCommands() {\r\n        return this._groupCommandsByCategory().map(group => {\r\n            this._postMessage(`${this._getCommandGroupName(group.category)} Commands:`, HelpMessageRenderer.COMMAND_STYLE);\r\n            this._postMessage();\r\n            this._printCommandGroup(group.commands.sort());\r\n            return this._postMessage();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @return {number} Returns the number of characters in the longest command.\r\n     */\r\n    _getMaxCommandLength() {\r\n        return Object.keys(this._commands)\r\n            .reduce((max, command) => command.length > max ? command.length : max, 0);\r\n    }\r\n\r\n    /**\r\n     * Returns a map of categories mapped to command names.\r\n     * @return {Array.<{string: Array.<string>}>}\r\n     */\r\n    _groupCommandsByCategory() {\r\n        let categories = iter(this._commands)\r\n            .pairs()\r\n            .reduce((categories, [name, command]) => {\r\n                if (command.category === \"hidden\") return categories;\r\n                let category = command.category || \"misc\";\r\n                if (categories[category] == null) categories[category] = [];\r\n                categories[category].push(name);\r\n                return categories;\r\n            }, {});\r\n\r\n        return this._orderGroups(categories);\r\n    }\r\n\r\n    /**\r\n     * Given a map of categories to commands, order the categories in the order\r\n     *  we'd like to display to the user.\r\n     * @param {{category: string[]}} categoryToCommands\r\n     * @return {{category: string, commands: string[]}[]}\r\n     */\r\n    _orderGroups(categoryToCommands) {\r\n        return HelpMessageRenderer.CATEGORY_ORDER\r\n            .map(category => ({category, commands: categoryToCommands[category]}));\r\n    }\r\n\r\n    /**\r\n     * Given a category, return the name to display to the user.\r\n     * @param {string} category\r\n     * @return {string}\r\n     */\r\n    _getCommandGroupName(category) {\r\n        switch (category) {\r\n        case \"common\":\r\n            return \"Basic IRC\";\r\n        case \"uncommon\":\r\n            return \"Other IRC\";\r\n        case \"one_identity\":\r\n            return \"One Identity\";\r\n        case \"scripts\":\r\n            return \"Script\";\r\n        default:\r\n            return \"Misc\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Print an array of commands.\r\n     * @param {string[]} commands\r\n     */\r\n    _printCommandGroup(commands) {\r\n        let line = commands\r\n            .map(command => `<span class=\"help-command\">${command}</span>`)\r\n            .join(\"\");\r\n        this._postMessage(line, HelpMessageRenderer.COMMAND_STYLE);\r\n    }\r\n\r\n    /**\r\n     * Display a help message detailing the available hotkeys.\r\n     * @param {{description: string, group: string, readableName: string}} hotkeys\r\n     */\r\n    renderHotkeys(hotkeys) {\r\n        var groupsVisited, hotkeyInfo, id, name, _results;\r\n        this._postMessage();\r\n        this._postMessage(\"Keyboard Shortcuts:\", \"notice help\");\r\n        this._postMessage();\r\n        groupsVisited = {};\r\n        _results = [];\r\n        for (id in hotkeys) {\r\n            hotkeyInfo = hotkeys[id];\r\n            if (hotkeyInfo.group) {\r\n                if (hotkeyInfo.group in groupsVisited) {\r\n                    continue;\r\n                }\r\n                groupsVisited[hotkeyInfo.group] = true;\r\n                name = hotkeyInfo.group;\r\n            } else {\r\n                name = hotkeyInfo.readableName;\r\n            }\r\n            _results.push(this._postMessage(`  ${name}: ${hotkeyInfo.description}`, \"notice help\"));\r\n        }\r\n        return _results;\r\n    }\r\n}\r\n/**\r\n * The total width of the help message, in number of characters (excluding\r\n *  spaces)\r\n */\r\nHelpMessageRenderer.TOTAL_WIDTH = 50;\r\n/**\r\n * The order that command categories are displayed to the user.\r\n */\r\nHelpMessageRenderer.CATEGORY_ORDER = [\"common\", \"uncommon\", \"one_identity\", \"scripts\", \"misc\"];\r\nHelpMessageRenderer.COMMAND_STYLE = \"notice help group\";\r\n","import HelpMessageRenderer from \"./help_message_renderer\";\r\nimport {VERSION, PROJECT_URL} from \"../utils/globals\";\r\nimport {display} from \"../utils/html\";\r\nimport {hashString} from \"../irc/irc_util\";\r\n\r\n/**\r\n * Handles outputing text to the window and provides functions to display\r\n * some specific messages like help and about.\r\n */\r\nexport default class MessageRenderer {\r\n    constructor(win) {\r\n        this.win = win;\r\n        this.systemMessage = this.systemMessage.bind(this);\r\n\r\n        this._userSawMostRecentMessage = false;\r\n        this._activityMarkerLocation = void 0;\r\n        this._helpMessageRenderer = new HelpMessageRenderer(this.systemMessage);\r\n    }\r\n    onFocus() {\r\n        return this._userSawMostRecentMessage = this.win.$messages.children().length > 0;\r\n    }\r\n\r\n    displayWelcome() {\r\n        this.systemMessage(\"Welcome to CIRC!\");\r\n        return this.systemMessage(this._getWebsiteBlurb());\r\n    }\r\n\r\n    /**\r\n     * Display available commands, grouped by category.\r\n     * @param {Object.<string: {category: string}>} commands\r\n     */\r\n    displayHelp(commands) {\r\n        return this._helpMessageRenderer.render(commands);\r\n    }\r\n\r\n    displayHotkeys(hotkeys) {\r\n        return this._helpMessageRenderer.renderHotkeys(hotkeys);\r\n    }\r\n\r\n    displayAbout() {\r\n        this._addWhitespace();\r\n        this.systemMessage(`CIRC is a packaged Chrome app developed by Google Inc. ${this._getWebsiteBlurb()}`, \"notice about\");\r\n        this.systemMessage(`Version: ${VERSION}`, \"notice about\");\r\n        this.systemMessage(\"Contributors:\", \"notice about group\");\r\n        this.systemMessage(\"    * Icon by Michael Cook (themichaelcook@gmail.com)\", \"notice about group\");\r\n        return this.systemMessage(\"    * UI mocks by Fravic Fernando (fravicf@gmail.com)\", \"notice about group\");\r\n    }\r\n\r\n    _getWebsiteBlurb() {\r\n        return `Documentation, issues and source code live at ${PROJECT_URL}.`;\r\n    }\r\n\r\n    /**\r\n     * Display content and the source it was from with the given style.\r\n     * @param {string} from\r\n     * @param {string} msg\r\n     * @param {...string} styles\r\n     */\r\n    message(from, msg, ...styles) {\r\n        from = from || \"\";\r\n        msg = msg || \"\";\r\n        var isHelpMessage = styles[0] && styles[0].split(\" \").indexOf(\"help\") != -1,\r\n            fromNode = this._createSourceFromText(from),\r\n            msgNode = this._createContentFromText(msg, /* allowHtml */isHelpMessage);\r\n\r\n        this.rawMessage(fromNode, msgNode, styles.join(\" \"));\r\n        if (this._shouldUpdateActivityMarker()) {\r\n            return this._updateActivityMarker();\r\n        }\r\n    }\r\n\r\n    _createContentFromText(msg, allowHtml) {\r\n        if (!msg)  return \"\";\r\n        var node = $(\"<span>\");\r\n        node.html(display(msg, allowHtml));\r\n        return node;\r\n    }\r\n\r\n    _createSourceFromText(from) {\r\n        var node;\r\n        if (!from) {\r\n            return \"\";\r\n        }\r\n        node = $(\"<span>\");\r\n        node.text(from);\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * Display a system message to the user. A system message has no from field.\r\n     */\r\n    systemMessage(msg, style) {\r\n        if (msg == null) {\r\n            msg = \"\";\r\n        }\r\n        if (style == null) {\r\n            style = \"system\";\r\n        }\r\n        return this.message(\"\", msg, style);\r\n    }\r\n\r\n    /**\r\n     * Display a message without escaping the from or msg fields.\r\n     */\r\n    rawMessage(from, msg, style) {\r\n        var message = this._createMessageHTML(from, msg, style);\r\n        this.win.emit(\"message\", this.win.getContext(), style, message[0].outerHTML);\r\n        this.win.$messages.append(message);\r\n        this.win.$messagesContainer.restoreScrollPosition();\r\n        return this._trimMessagesIfTooMany();\r\n    }\r\n\r\n    // mock-hookable function\r\n    _createTimestamp() {\r\n        return new Date();\r\n    }\r\n\r\n    _createMessageHTML(from, msg, style) {\r\n        var message = $(\"#templates .message\").clone();\r\n        message.addClass(style);\r\n        $(\".timestamp\", message).append(this._createTimestamp().toLocaleTimeString());\r\n        $(\".source\", message).append(from);\r\n        $(\".content\", message).append(msg);\r\n        if (!(typeof from.text === \"function\" ? from.text() : void 0)) {\r\n            $(\".source\", message).addClass(\"empty\");\r\n        }\r\n        if (typeof from.text === \"function\") {\r\n            $(\".source\", message).attr(\"colornumber\", hashString(from.text().toLocaleLowerCase()) % 31);\r\n        }\r\n        return message;\r\n    }\r\n\r\n    /**\r\n     * Trim chat messages when there are too many in order to save on memory.\r\n     */\r\n    _trimMessagesIfTooMany() {\r\n        var messages = this.win.$messagesContainer.children().children();\r\n        if (!(messages.length > MessageRenderer.MAX_MESSAGES)) {\r\n            return;\r\n        }\r\n        return messages.map(message => message.remove());\r\n    }\r\n\r\n    _addWhitespace() {\r\n        return this.message();\r\n    }\r\n\r\n    /*\r\n     * Update the activity marker when the user has seen the most recent messages\r\n     * and then received a message while the window wasn't focused.\r\n     */\r\n    _shouldUpdateActivityMarker() {\r\n        return !this.win.isFocused() && this._userSawMostRecentMessage;\r\n    }\r\n\r\n    _updateActivityMarker() {\r\n        this._userSawMostRecentMessage = false;\r\n        if (this._activityMarkerLocation) {\r\n            this._activityMarkerLocation.removeClass(\"activity-marker\");\r\n        }\r\n        this._activityMarkerLocation = this.win.$messages.children().last();\r\n        return this._activityMarkerLocation.addClass(\"activity-marker\");\r\n    }\r\n}\r\n// The max number of messages a room can display at once.\r\nMessageRenderer.MAX_MESSAGES = 3500;\r\n","/**\r\n * Indicates that a dom element can be scrolled and provides scroll utility\r\n * functions.\r\n */\r\nexport default class Scrollable {\r\n    /**\r\n     * @param {Node} element The jquery DOM element to wrap.\r\n     */\r\n    constructor(node) {\r\n        this._onScroll = this._onScroll.bind(this);\r\n\r\n        this._restoreScrollPosition = this._restoreScrollPosition.bind(this);\r\n        this._node = node;\r\n        node.restoreScrollPosition = this._restoreScrollPosition;\r\n        this._scrollPosition = 0;\r\n        this._wasScrolledDown = true;\r\n        $(window).resize(this._restoreScrollPosition);\r\n        $(node).scroll(this._onScroll);\r\n    }\r\n\r\n    node() {\r\n        return this._node;\r\n    }\r\n\r\n    /**\r\n     * Restore the scroll position to where the user last scrolled. If the node\r\n     *  was scrolled to the bottom it will remain scrolled to the bottom.\r\n     *\r\n     * This is useful for restoring the scroll position after adding content or\r\n     *  resizing the window.\r\n     */\r\n    _restoreScrollPosition() {\r\n        if (this._wasScrolledDown) {\r\n            return this._scrollToBottom();\r\n        }\r\n        else {\r\n            return this._node.scrollTop(this._scrollPosition);\r\n        }\r\n    }\r\n\r\n    _scrollToBottom() {\r\n        return this._node.scrollTop(this._getScrollHeight());\r\n    }\r\n\r\n    _onScroll() {\r\n        this._wasScrolledDown = this._isScrolledDown();\r\n        return this._scrollPosition = this._node.scrollTop();\r\n    }\r\n\r\n    _isScrolledDown() {\r\n        var scrollPosition;\r\n        scrollPosition = this._node.scrollTop() + this._node.height();\r\n        return scrollPosition >= this._getScrollHeight() - Scrollable.SCROLLED_DOWN_BUFFER;\r\n    }\r\n\r\n    _getScrollHeight() {\r\n        return this._node[0].scrollHeight;\r\n    }\r\n}\r\n/**\r\n * The screen will auto scroll as long as the user didn't scroll up more then\r\n *  this many pixels.\r\n */\r\nScrollable.SCROLLED_DOWN_BUFFER = 8;\r\n","import HTMLList from \"./html_list\";\r\n\r\n// TODO sort first by op status, then name\r\nexport default class NickList extends HTMLList {\r\n    constructor(surface) {\r\n        super(surface, $(\"#templates .nick\"));\r\n\r\n    }\r\n    add(nick) {\r\n        return this.insert(this._getClosestIndex(nick), nick);\r\n    }\r\n\r\n    _getClosestIndex(nick) {\r\n        nick = nick.toLowerCase();\r\n        for (let i = 0, l = this.nodeNames.length; i < l; ++i) {\r\n            let name = this.nodeNames[i];\r\n            if (name.toLowerCase() > nick) {\r\n                return i;\r\n            }\r\n        }\r\n        return this.nodeNames.length;\r\n    }\r\n}\r\n","import EventEmitter from \"../utils/event_emitter\";\r\nimport NotificationGroup from \"./notification_group\";\r\nimport MessageRenderer from \"./window_message_renderer\";\r\nimport Context from \"./context\";\r\nimport Scrollable from \"./scrollable\";\r\nimport NickList from \"./nick_list\";\r\n\r\n/**\r\n * A window for a specific IRC channel.\r\n */\r\nexport default class Window extends EventEmitter {\r\n    constructor(server, opt_channel) {\r\n        super();\r\n        this._onBlur = this._onBlur.bind(this);\r\n        this._onFocus = this._onFocus.bind(this);\r\n        this.name = server + (opt_channel ? \" \" + opt_channel : \"\");\r\n        this.messageRenderer = new MessageRenderer(this);\r\n        this._addUI();\r\n        this.notifications = new NotificationGroup(opt_channel);\r\n        this._isVisible = false;\r\n        this._isFocused = false;\r\n        this._height = 0;\r\n        this._private = false;\r\n\r\n        $(window).focus(this._onFocus);\r\n        $(window).blur(this._onBlur);\r\n\r\n        var dragging;\r\n        $(\".dragbar\").mousedown(e => {\r\n            e.preventDefault();\r\n            dragging = true;\r\n            var main = $(\"#messages-and-input\");\r\n            var ghostbar = $(\"<div>\", {\r\n                id: \"ghostbar\",\r\n                css: {\r\n                    height: main.outerHeight(),\r\n                    top: main.offset().top,\r\n                    left: main.offset().left - 4\r\n                }\r\n            }).appendTo(\"body\");\r\n            $(document).mousemove(e => {\r\n                ghostbar.css(\"left\", e.pageX);\r\n            });\r\n        });\r\n\r\n        $(document).mouseup(e => {\r\n            if (dragging) {\r\n                $(\"#rooms-and-nicks\").css(\"width\", e.pageX);\r\n                $(\"#ghostbar\").remove();\r\n                $(document).unbind(\"mousemove\");\r\n                dragging = false;\r\n            }\r\n        });\r\n    }\r\n\r\n    getContext() {\r\n        if (this._context == null)\r\n            this._context = new Context(this.conn != null ? this.conn.name : void 0, this.target);\r\n\r\n        return this._context;\r\n    }\r\n\r\n    _onFocus() {\r\n        if (!this._isVisible)\r\n            return;\r\n\r\n        this._isFocused = true;\r\n        this.notifications.clear();\r\n        return this.messageRenderer.onFocus();\r\n    }\r\n\r\n    _onBlur() {\r\n        return this._isFocused = false;\r\n    }\r\n\r\n    isFocused() {\r\n        return this._isFocused && this._isVisible;\r\n    }\r\n\r\n    _addUI() {\r\n        this._addMessageUI();\r\n        this._addNickUI();\r\n        return this.$roomsAndNicks = $(\"#rooms-and-nicks\");\r\n    }\r\n\r\n    _addMessageUI() {\r\n        this.$messagesContainer = (new Scrollable($(\"#messages-container\"))).node();\r\n        return this.$messages = $(\"#templates .messages\").clone();\r\n    }\r\n\r\n    _addNickUI() {\r\n        this.$nicksContainer = $(\"#nicks-container\");\r\n        this.$nicks = $(\"#templates .nicks\").clone();\r\n        return this.nicks = new NickList(this.$nicks);\r\n    }\r\n\r\n    /**\r\n     * Sets the window's channel.\r\n     * @param {string} target\r\n     */\r\n    setTarget(target) {\r\n        this.target = target;\r\n        if (this.isPrivate()) {\r\n            return;\r\n        }\r\n        return this.$roomsAndNicks.removeClass(\"no-nicks\");\r\n    }\r\n\r\n    isServerWindow() {\r\n        return !this.target;\r\n    }\r\n\r\n    equals(win) {\r\n        return this.name === win.name;\r\n    }\r\n\r\n    /**\r\n     * Marks the window as private.\r\n     * Private windows are used for direct messages from /msg.\r\n     */\r\n    makePrivate() {\r\n        return this._private = true;\r\n    }\r\n\r\n    isPrivate() {\r\n        return this._private;\r\n    }\r\n\r\n    detach() {\r\n        this.$roomsAndNicks.addClass(\"no-nicks\");\r\n        this.$messages.detach();\r\n        this.$nicks.detach();\r\n        return this._isVisible = false;\r\n    }\r\n\r\n    remove() {\r\n        this.detach();\r\n        this.$messages.remove();\r\n        return this.$nicks.remove();\r\n    }\r\n\r\n    attach() {\r\n        this._isVisible = true;\r\n        this._onFocus();\r\n        if (this.target && !this.isPrivate()) {\r\n            this.$roomsAndNicks.removeClass(\"no-nicks\");\r\n        }\r\n        this.$messagesContainer.append(this.$messages);\r\n        this.$nicksContainer.append(this.$nicks);\r\n        return this.$messagesContainer.restoreScrollPosition();\r\n    }\r\n    /**\r\n     * @param  {any} from\r\n     * @param  {any} msg\r\n     * @param  {any} ...style\r\n     */\r\n    message(...args) {\r\n        return this.messageRenderer.message(...args);\r\n    }\r\n\r\n    /**\r\n     * Display a raw html to the user.\r\n     * This is useful for scripts to embed images or video.\r\n     */\r\n    rawMessage(from, node, ...style) {\r\n        return this.messageRenderer.rawMessage(from, node, style.join(\" \"));\r\n    }\r\n\r\n    /**\r\n     * Append raw html to the message list.\r\n     * This is useful for adding a large number of messages quickly, such as\r\n     * loading chat history.\r\n     */\r\n    rawHTML(html) {\r\n        this.$messages.html(this.$messages.html() + html);\r\n        return this.$messagesContainer.restoreScrollPosition();\r\n    }\r\n\r\n    clear() {\r\n        return this.$messages.html(\"\");\r\n    }\r\n}\r\n","import EventEmitter from \"../utils/event_emitter\";\r\n\r\n/**\r\n * Walks first time users through the basics of CIRC.\r\n *\r\n * TODO: It would be awesome if this was implemented as a script.\r\n */\r\nexport default class Walkthrough extends EventEmitter {\r\n    /**\r\n     * @param {{getCurrentContext: function(), displayMessage: function()}} messageDisplayer\r\n     * @param {Storage} storageState The current state of what's loaded from storage\r\n     */\r\n    constructor(messageDisplayer, storageState) {\r\n        super();\r\n        this._handleIRCEvent = this._handleIRCEvent.bind(this);\r\n        this._messageDisplayer = messageDisplayer;\r\n        this._steps = [\"start\", \"server\", \"channel\", \"end\"];\r\n        this._findWalkthroughPoisition(storageState);\r\n        this._beginWalkthrough();\r\n    }\r\n    /**\r\n         * Determine which step the user is on in the walkthrough. They may have left\r\n         *  half way through.\r\n         */\r\n    _findWalkthroughPoisition(storageState) {\r\n        if (storageState.channelsLoaded) {\r\n            this._currentStep = 3;\r\n        } else if (storageState.serversLoaded) {\r\n            this._currentStep = 2;\r\n        } else if (storageState.nickLoaded) {\r\n            this._currentStep = 1;\r\n        } else {\r\n            this._currentStep = 0;\r\n        }\r\n        return this._startingStep = this._currentStep;\r\n    }\r\n\r\n    /**\r\n     * Based on where the user is in the walkthrough, determine the first message\r\n     *  the user sees.\r\n     */\r\n    _beginWalkthrough() {\r\n        var step;\r\n        step = this._steps[this._currentStep];\r\n        if (step === \"end\") {\r\n            this.emit(\"tear_down\");\r\n            return;\r\n        }\r\n        if (step === \"channel\") {\r\n            // Wait for the server to connect before displaying anything.\r\n            this._currentStep--;\r\n            return;\r\n        }\r\n        return this._displayStep(step);\r\n    }\r\n\r\n    /**\r\n     * @param {EventEmitter} ircEvents\r\n     */\r\n    listenToIRCEvents(ircEvents) {\r\n        return ircEvents.on(\"server\", this._handleIRCEvent);\r\n    }\r\n\r\n    _handleIRCEvent(event) {\r\n        this._context = event.context;\r\n        switch (event.name) {\r\n        case \"nick\":\r\n            return this._displayWalkthrough(\"server\");\r\n        case \"connect\":\r\n            return this._displayWalkthrough(\"channel\");\r\n        case \"joined\":\r\n            return this._displayWalkthrough(\"end\");\r\n        }\r\n    }\r\n\r\n    _displayWalkthrough(type) {\r\n        var position;\r\n        position = this._steps.indexOf(type);\r\n        if (position > this._currentStep) {\r\n            this._currentStep = position;\r\n            return this._displayStep(type);\r\n        }\r\n    }\r\n\r\n    _displayStep(name) {\r\n        return this[`_${name}Walkthrough`](this._context || this._messageDisplayer.getCurrentContext());\r\n    }\r\n\r\n    _isFirstMessage() {\r\n        return this._currentStep === this._startingStep;\r\n    }\r\n\r\n    /**\r\n     * Display a message to the user.\r\n     */\r\n    _message(msg, style) {\r\n        var context = this._messageDisplayer.getCurrentContext();\r\n        style = style || \"system\";\r\n        return this._messageDisplayer.displayMessage(style, context, msg);\r\n    }\r\n\r\n    _startWalkthrough() {\r\n        return this._message(\"To get started, set your nickname with /nick <my_nick>.\");\r\n    }\r\n\r\n    _serverWalkthrough() {\r\n        if (this._isFirstMessage()) {\r\n            this._message(\"Join a server by typing /server <server> [port].\");\r\n        } else {\r\n            this._message(\"Great! Now join a server by typing /server <server> [port].\");\r\n        }\r\n        return this._message(\"For example, you can connect to freenode by typing /server chat.freenode.net.\");\r\n    }\r\n\r\n    _channelWalkthrough(context) {\r\n        /**\r\n         * Display after a delay to allow for MOTD and other output to be displayed.\r\n         */\r\n        return setTimeout(() => {\r\n            return this._displayChannelWalkthough(context);\r\n        }, Walkthrough.SERVER_OUTPUT_DELAY);\r\n    }\r\n\r\n    _displayChannelWalkthough(context) {\r\n        this._message(`You've successfully connected to ${context.server}.`);\r\n        return this._message(\"Join a channel with /join <#channel>.\");\r\n    }\r\n\r\n    _endWalkthrough(context) {\r\n        if (!this._isFirstMessage()) {\r\n            this._message(`Awesome, you've connected to ${context.channel}.`);\r\n        }\r\n        this._message(\"If you're ever stuck, type /help to see a list of all commands.\");\r\n        this._message(\"You can switch windows with alt+[0-9] or click in the channel list on the left.\");\r\n        return this.emit(\"tear_down\");\r\n    }\r\n}\r\n/**\r\n * Number of ms to wait after joining a server so the MTOD and other output can be displayed.\r\n */\r\nWalkthrough.SERVER_OUTPUT_DELAY = 1000;\r\n","import EventEmitter from \"../utils/event_emitter\";\r\nimport {getLogger, getFieldOrNull} from \"../utils/utils\";\r\nimport {randomName} from \"../irc/irc_util\";\r\nimport ScriptLoader from \"../script/script_loader\";\r\nimport iter from \"lazy.js\";\r\n\r\n/**\r\n * Manages storage\r\n */\r\nexport default class Storage extends EventEmitter {\r\n    constructor(chat) {\r\n        super();\r\n        this._restoreScripts = this._restoreScripts.bind(this);\r\n        this._onChanged = this._onChanged.bind(this);\r\n        this._chat = chat;\r\n        this._log = getLogger(this);\r\n        this._scripts = [];\r\n        this._channels = [];\r\n        this._servers = [];\r\n        this._nick = void 0;\r\n        this._autostart = void 0;\r\n        this.password = void 0;\r\n        this.serverDevice = void 0;\r\n        chrome.storage.onChanged.addListener(this._onChanged);\r\n        this.pause();\r\n    }\r\n\r\n    /**\r\n     * Save an object to sync storage for the script with the given name.\r\n     * @param {string} name A unique name representing the script.\r\n     * @param {Object} item The item to store.\r\n     */\r\n    saveItemForScript(name, item) {\r\n        return this._store(this._getScriptStorageHandle(name), item);\r\n    }\r\n\r\n    /**\r\n     * Load an object from sync storage for the script with the given name.\r\n     * @param {string} name A unique name representing the script.\r\n     * @param {function(Object)} onLoaded The function that is called once the item\r\n     *     is loaded.\r\n     */\r\n    loadItemForScript(name, onLoaded) {\r\n        var storageHandle = this._getScriptStorageHandle(name);\r\n        return chrome.storage.sync.get(storageHandle, state => onLoaded(state[storageHandle]));\r\n    }\r\n\r\n    /**\r\n     * Clears the item stored for the given script. This is called after a script\r\n     *  is uninstalled.\r\n     * @param {string} name A unique name representing the script.\r\n     */\r\n    clearScriptStorage(name) {\r\n        return chrome.storage.sync.remove(this._getScriptStorageHandle(name));\r\n    }\r\n\r\n    _getScriptStorageHandle(name) {\r\n        return `script_${name}`;\r\n    }\r\n\r\n    /**\r\n     * Listen for storage changes.\r\n     * If the password updated then change our own. If the password was cleared\r\n     *  then restore it.\r\n     * @param  {any} changeMap\r\n     * @param  {any} areaName\r\n     */\r\n    _onChanged(changeMap) {\r\n        if (changeMap.password) {\r\n            this._onPasswordChange(changeMap.password);\r\n        }\r\n        if (changeMap.server_device) {\r\n            this._onServerDeviceChange(changeMap.server_device);\r\n        }\r\n        return this._scripts\r\n            .map(script => {\r\n                let change = changeMap[this._getScriptStorageHandle(script.getName())];\r\n                if (change) return this._chat.scriptHandler.storageChanged(script, change);\r\n                return void 0;\r\n            });\r\n    }\r\n\r\n    _onPasswordChange(passwordChange) {\r\n        this._log(\"password changed from\", passwordChange.oldValue, \"to\", passwordChange.newValue);\r\n        if (passwordChange.newValue === this.password) return;\r\n        if (passwordChange.newValue) {\r\n            this.password = passwordChange.newValue;\r\n            return this._chat.setPassword(this.password);\r\n        } else {\r\n            this._log(\"password was cleared. Setting password back to\", this.password);\r\n            return this._store(\"password\", this.password);\r\n        }\r\n    }\r\n\r\n    _onServerDeviceChange(serverChange) {\r\n        this._log(\r\n            \"device server changed from\",\r\n            getFieldOrNull(serverChange, [\"oldValue\", \"addr\"]),\r\n            getFieldOrNull(serverChange, [\"oldValue\", \"port\"]),\r\n            \"to\",\r\n            getFieldOrNull(serverChange, [\"newValue\", \"addr\"]),\r\n            getFieldOrNull(serverChange, [\"newValue\", \"port\"])\r\n        );\r\n        if (serverChange.newValue) {\r\n            this.serverDevice = serverChange.newValue;\r\n            return this._chat.remoteConnectionHandler.determineConnection(this.serverDevice);\r\n        } else if (this.serverDevice) {\r\n            return this._store(\"server_device\", this.serverDevice);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stops storing state items (channel, server, nick).\r\n     * This is used when the client is resuming it's IRC state and doesn't want\r\n     *  to make redudant writes to storage.\r\n     */\r\n    pause() {\r\n        return this._paused = true;\r\n    }\r\n\r\n    resume() {\r\n        return this._paused = false;\r\n    }\r\n\r\n    setAutostart(opt_enabled) {\r\n        var enabled;\r\n        enabled = opt_enabled != null ? opt_enabled : !this._autostart;\r\n        this._autostart = enabled;\r\n        this._store(\"autostart\", enabled);\r\n        return this._autostart;\r\n    }\r\n\r\n    finishedWalkthrough() {\r\n        return this._store(\"completed_walkthrough\", true, \"local\");\r\n    }\r\n\r\n    finishedLoadingPrepackagedScripts() {\r\n        return this._store(\"loaded_prepackaged_scripts\", true, \"local\");\r\n    }\r\n\r\n    nickChanged(nick) {\r\n        if (this._nick === nick) {\r\n            return;\r\n        }\r\n        this._nick = nick;\r\n        return this._store(\"nick\", nick);\r\n    }\r\n\r\n    channelJoined(server, name, type, key) {\r\n        var chan, channelObj, i, _i, _len, _ref1;\r\n        type = type || \"normal\";\r\n        _ref1 = this._channels;\r\n        for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {\r\n            chan = _ref1[i];\r\n            if (chan.server === server && chan.name === name) {\r\n                if (chan.key !== key) {\r\n                    this._channels.splice(i, 1);\r\n                    break;\r\n                }\r\n                return;\r\n            }\r\n        }\r\n        channelObj = {\r\n            server: server,\r\n            name: name,\r\n            key: key\r\n        };\r\n        if (type !== \"normal\") {\r\n            channelObj.type = type;\r\n        }\r\n        this._channels.push(channelObj);\r\n        return this._store(\"channels\", this._channels);\r\n    }\r\n\r\n    serverJoined(name, port, password) {\r\n        if (this._isDuplicateServer(name, port)) {\r\n            return;\r\n        }\r\n        this._servers.push({\r\n            name: name,\r\n            port: port,\r\n            password: password\r\n        });\r\n        return this._store(\"servers\", this._servers);\r\n    }\r\n\r\n    _isDuplicateServer(name, port) {\r\n        return this._servers\r\n            .some((server, i) => {\r\n                if (server.name === name) {\r\n                    if (server.port === port) {\r\n                        return true;\r\n                    }\r\n                    this._servers.splice(i, 1);\r\n                    return false;\r\n                }\r\n            });\r\n    }\r\n\r\n    parted(server, channel) {\r\n        if (channel != null) {\r\n            return this._channelParted(server, channel);\r\n        } else {\r\n            return this._serverParted(server);\r\n        }\r\n    }\r\n\r\n    _channelParted(server, name) {\r\n        let index = this._channels.findIndex(channel => {\r\n            return channel.server === server\r\n                    && channel.name.toLowerCase() === name.toLowerCase();\r\n        });\r\n        this._channels.splice(index, 1);\r\n        return this._store(\"channels\", this._channels);\r\n    }\r\n\r\n    _serverParted(name) {\r\n        let index = this._servers.findIndex(server => server.name === name);\r\n        if (index >= 0) {\r\n            this._servers.splice(index, 1);\r\n            return this._store(\"servers\", this._servers);\r\n        }\r\n    }\r\n\r\n    ignoredMessagesChanged() {\r\n        return this._store(\"ignored_messages\", this._getIgnoredMessages());\r\n    }\r\n\r\n    _getIgnoredMessages() {\r\n        return this._chat.messageHandler.getIgnoredMessages();\r\n    }\r\n\r\n    scriptAdded(script) {\r\n        if (this._isDuplicateScript(script)) return;\r\n        this._scripts.push(script);\r\n        return this._store(\"scripts\", this._scripts, \"local\");\r\n    }\r\n\r\n    scriptRemoved(scriptToRemove) {\r\n        let index = this._scripts.findIndex(script => script.id === scriptToRemove.id);\r\n        if (index >= 0) {\r\n            this._scripts.splice(index, 1);\r\n            this._store(\"scripts\", this._scripts, \"local\");\r\n        }\r\n    }\r\n\r\n    _isDuplicateScript(newScript) {\r\n        return this._scripts.some(script => script.id === newScript.id);\r\n    }\r\n\r\n    _store(key, value, type) {\r\n        var storageObj;\r\n        type = type || \"sync\";\r\n        if (!this.shouldStore(key)) return;\r\n        this._log(\"storing\", key, \"=>\", value, \"to\", type);\r\n        storageObj = {};\r\n        storageObj[key] = value;\r\n        if (type === \"sync\") {\r\n            return chrome.storage.sync.set(storageObj);\r\n        } else {\r\n            return chrome.storage.local.set(storageObj);\r\n        }\r\n    }\r\n\r\n    shouldStore(key) {\r\n        return !(this._paused && Storage.STATE_ITEMS.indexOf(key) >= 0);\r\n    }\r\n\r\n    getState() {\r\n        return {\r\n            ircStates: this._createIRCStates(),\r\n            servers: this._servers,\r\n            channels: this._channels,\r\n            nick: this._nick,\r\n            ignoredMessages: this._getIgnoredMessages()\r\n        };\r\n    }\r\n\r\n    _createIRCStates() {\r\n        return iter(this._chat.connections)\r\n            .values()\r\n            .map(connection => ({\r\n                server: connection.name,\r\n                state: connection.irc.state,\r\n                channels: connection.irc.channels,\r\n                away: connection.irc.away,\r\n                nick: connection.irc.nick\r\n            }));\r\n    }\r\n\r\n    /**\r\n     * Load initial items, such as whether to show the walkthrough.\r\n     */\r\n    init() {\r\n        return chrome.storage.local.get(Storage.INITIAL_ITEMS_LOCAL, state => {\r\n            this._initializeLocalItems(state);\r\n            return chrome.storage.sync.get(Storage.INITIAL_ITEMS, state => {\r\n                this._initializeSyncItems(state);\r\n                return this.emit(\"initialized\");\r\n            });\r\n        });\r\n    }\r\n\r\n    _initializeSyncItems(state) {\r\n        this._state = state;\r\n        this._restorePassword();\r\n        this._loadServerDevice();\r\n        return this._autostart = state.autostart;\r\n    }\r\n\r\n    _initializeLocalItems(state) {\r\n        this.completedWalkthrough = state[\"completed_walkthrough\"];\r\n        this.loadedPrepackagedScripts = state[\"loaded_prepackaged_scripts\"];\r\n        return this._restoreScripts(state);\r\n    }\r\n\r\n    _restoreScripts(state) {\r\n        if (!state.scripts) return;\r\n        this._log(state.scripts.length, \"scripts loaded from storage:\", state.scripts);\r\n        return ScriptLoader.loadScriptsFromStorage(state.scripts, script => {\r\n            this._scripts.push(script);\r\n            return this._chat.scriptHandler.addScript(script);\r\n        });\r\n    }\r\n\r\n    restoreSavedState(opt_callback) {\r\n        return chrome.storage.sync.get(Storage.STATE_ITEMS, savedState => {\r\n            this.loadState(savedState);\r\n            return typeof opt_callback === \"function\" ? opt_callback() : void 0;\r\n        });\r\n    }\r\n\r\n    loadState(state) {\r\n        this._state = state;\r\n        this._restoreNick();\r\n        this._restoreServers();\r\n        this._restoreChannels();\r\n        this._restoreIgnoredMessages();\r\n        this._restoreIRCStates();\r\n        return this._markItemsAsLoaded(Storage.STATE_ITEMS, state);\r\n    }\r\n\r\n    _restorePassword() {\r\n        this.password = this._state.password;\r\n        if (!this.password) {\r\n            this.password = randomName();\r\n            this._log(\"no password found, setting new password to\", this.password);\r\n            this._store(\"password\", this.password);\r\n        } else {\r\n            this._log(\"password loaded from storage:\", this.password);\r\n        }\r\n        this._chat.setPassword(this.password);\r\n        return this._chat.remoteConnectionHandler.determineConnection();\r\n    }\r\n\r\n    _restoreServers() {\r\n        let servers = this._state.servers;\r\n        if (!servers) return;\r\n        this._servers = servers;\r\n        return servers.map(server => this._chat.connect(server.name, server.port, server.password));\r\n    }\r\n\r\n    _restoreChannels() {\r\n        var channels = this._state.channels;\r\n        if (!channels) return;\r\n        this._channels = channels;\r\n\r\n        return channels.reduce((cs, channel) => {\r\n            let connection = this._chat.connections[channel.server];\r\n            if (!connection) return cs;\r\n            if (channel.type === \"private\") {\r\n                cs.push(this._chat.createPrivateMessageWindow(connection, channel.name));\r\n            }\r\n            else {\r\n                cs.push(this._chat.join(connection, channel.name, channel.key));\r\n            }\r\n            return cs;\r\n        }, []);\r\n    }\r\n\r\n    _restoreIgnoredMessages() {\r\n        var ignoredMessages = this._state[\"ignored_messages\"];\r\n        if (!ignoredMessages) return;\r\n        this._log(\"restoring ignored messages from storage:\", ignoredMessages);\r\n        return this._chat.messageHandler.setIgnoredMessages(ignoredMessages);\r\n    }\r\n\r\n    _restoreNick() {\r\n        var nick = this._state.nick;\r\n        if (!(nick && typeof nick === \"string\")) return;\r\n        this._nick = nick;\r\n        return this._chat.setNick(nick);\r\n    }\r\n\r\n    _restoreIRCStates() {\r\n        var connectedServers,\r\n            ircStates = this._state.ircStates;\r\n        if (!ircStates) return;\r\n\r\n        connectedServers = ircStates.map(ircState => {\r\n            let connection = this._chat.connections[ircState.server];\r\n            if (connection) {\r\n                this._setIRCState(connection, ircState);\r\n            }\r\n            return ircState.server;\r\n        });\r\n        return this._disconnectServersWithNoState(connectedServers);\r\n    }\r\n\r\n    _disconnectServersWithNoState(connectedServers) {\r\n        return iter(this._chat.connections)\r\n            .pairs()\r\n            .filter(([name]) => connectedServers.indexOf(name) < 0)\r\n            .each(([, connection]) => connection.irc.state = \"disconnected\");\r\n    }\r\n\r\n    _getNicksInChannel(channel) {\r\n        return iter(channel.names).values();\r\n    }\r\n\r\n    /**\r\n     * Loads servers, channels and nick from the given IRC state.\r\n     * The state has the following format:\r\n     * {\r\n     *  nick: string,\r\n     *  channels: Array<{sevrer, name}>,\r\n     *  servers: Array<{name, port}>,\r\n     *  irc_state: object,\r\n     *  server_device: {port: number, addr: string},\r\n     *  password: string\r\n     * }\r\n     * @param {Object} ircState An object that represents the current state of an IRC client.\r\n     */\r\n    _setIRCState(conn, ircState) {\r\n        if (ircState.state === \"connected\") this._chat.onConnected(conn);\r\n        if (ircState.state) conn.irc.state = ircState.state;\r\n        if (ircState.away) conn.irc.away = ircState.away;\r\n        if (ircState.channels) conn.irc.channels = ircState.channels;\r\n        conn.irc.nick = ircState.nick;\r\n        if (!ircState.channels) return;\r\n\r\n        return iter(ircState.channels)\r\n            .pairs()\r\n            .each(([channelName, channel]) => {\r\n                this._chat.onJoined(conn, channelName);\r\n                return this._chat.onNames({\r\n                    context: {\r\n                        server: conn.name,\r\n                        channel: channelName\r\n                    }\r\n                }, this._getNicksInChannel(channel));\r\n            });\r\n    }\r\n\r\n    _loadServerDevice() {\r\n        this.loadedServerDevice = true;\r\n        this.serverDevice = this._state.server_device;\r\n        if (!this.serverDevice) {\r\n            this._log(\"no remote server found\", this._state);\r\n        }\r\n        if (this.serverDevice) {\r\n            this._log(\"loaded server device\", this.serverDevice);\r\n        }\r\n        return this._chat.remoteConnectionHandler.determineConnection();\r\n    }\r\n\r\n    /**\r\n     * Marks that a certain item has been loaded from storage.\r\n     */\r\n    _markItemsAsLoaded(items, state) {\r\n        return items.map(item => this[`${item}Loaded`] = state[item] != null);\r\n    }\r\n\r\n    becomeServerDevice(connectionInfo) {\r\n        this.serverDevice = {\r\n            addr: connectionInfo.addr,\r\n            port: connectionInfo.port\r\n        };\r\n        return this._store(\"server_device\", this.serverDevice);\r\n    }\r\n}\r\n/**\r\n * Items loaded from sync storage related to the user's IRC state\r\n */\r\nStorage.STATE_ITEMS = [\"nick\", \"servers\", \"channels\", \"ignored_messages\"];\r\n\r\n/**\r\n * Items loaded from sync storage on startup\r\n */\r\nStorage.INITIAL_ITEMS = [\"password\", \"server_device\", \"autostart\"];\r\n\r\n/**\r\n * Items loaded from local storage on startup\r\n */\r\nStorage.INITIAL_ITEMS_LOCAL = [\"completed_walkthrough\", \"scripts\", \"loaded_prepackaged_scripts\"];\r\n","\r\nclass KeyCodes {\r\n    /**\r\n     * Given one or more characters, return their ascii values.\r\n     * @param {string...} chars\r\n     * @return {string|Array.<string>|undefined}\r\n     */\r\n    toKeyCode(...args) {\r\n        var codes = args.map(char => this._charToKeyCode[char]);\r\n        if (args.length < 2) {\r\n            return codes[0];\r\n        } else {\r\n            return codes;\r\n        }\r\n    }\r\n}\r\n\r\nKeyCodes.prototype._charToKeyCode = {\r\n    \"BACKSPACE\": 8,\r\n    \"TAB\": 9,\r\n    \"ENTER\": 13,\r\n    \"SHIFT\": 16,\r\n    \"CONTROL\": 17,\r\n    \"ALT\": 18,\r\n    \"CAPSLOCK\": 20,\r\n    \"ESCAPE\": 27,\r\n    \"SPACE\": 32,\r\n    \"PAGEUP\": 33,\r\n    \"PAGEDOWN\": 34,\r\n    \"END\": 35,\r\n    \"HOME\": 36,\r\n    \"LEFT\": 37,\r\n    \"UP\": 38,\r\n    \"RIGHT\": 39,\r\n    \"DOWN\": 40,\r\n    \"INSERT\": 45,\r\n    \"DELETE\": 46,\r\n    \"0\": 48,\r\n    \"1\": 49,\r\n    \"2\": 50,\r\n    \"3\": 51,\r\n    \"4\": 52,\r\n    \"5\": 53,\r\n    \"6\": 54,\r\n    \"7\": 55,\r\n    \"8\": 56,\r\n    \"9\": 57,\r\n    \"A\": 65,\r\n    \"B\": 66,\r\n    \"C\": 67,\r\n    \"D\": 68,\r\n    \"E\": 69,\r\n    \"F\": 70,\r\n    \"G\": 71,\r\n    \"H\": 72,\r\n    \"I\": 73,\r\n    \"J\": 74,\r\n    \"K\": 75,\r\n    \"L\": 76,\r\n    \"M\": 77,\r\n    \"N\": 78,\r\n    \"O\": 79,\r\n    \"P\": 80,\r\n    \"Q\": 81,\r\n    \"R\": 82,\r\n    \"S\": 83,\r\n    \"T\": 84,\r\n    \"U\": 85,\r\n    \"V\": 86,\r\n    \"W\": 87,\r\n    \"X\": 88,\r\n    \"Y\": 89,\r\n    \"Z\": 90,\r\n    \"F1\": 112,\r\n    \"F2\": 113,\r\n    \"F3\": 114,\r\n    \"F4\": 115,\r\n    \"F5\": 116,\r\n    \"F6\": 117,\r\n    \"F7\": 118,\r\n    \"F8\": 119,\r\n    \"F9\": 110,\r\n    \"F10\": 121,\r\n    \"F11\": 122,\r\n    \"F12\": 123,\r\n    \"[\": 119,\r\n    \"]\": 121,\r\n    \";\": 186,\r\n    \"=\": 187,\r\n    \",\": 188,\r\n    \"-\": 189,\r\n    \".\": 190,\r\n    \"/\": 191,\r\n    \"`\": 192,\r\n    \"\\\\\": 220,\r\n    \"'\": 222\r\n};\r\n\r\nexport default new KeyCodes;\r\n","\r\nimport keyCodes from \"./keycodes\";\r\n\r\n/**\r\n * Maps keyboard shortcuts to commands and their arguments.\r\n */\r\nexport default class KeyboardShortcutMap {\r\n    constructor() {\r\n        this._hotkeyMap = {};\r\n        this._mapHotkeys();\r\n    }\r\n    /**\r\n     * Returns the mapping of hotkeys to commands.\r\n     * @param {Object.<string: {description: string, group: string,\r\n     *     readableName: string, command: string, args: Array<Object>}>} hotkeys\r\n     */\r\n    getMap() {\r\n        return this._hotkeyMap;\r\n    }\r\n\r\n    /**\r\n     * Get the command for the given shortcut if it is valid.\r\n     * @param {KeyboardEvent} shortcut\r\n     * @param {boolean} hasInput True if the input DOM element has text.\r\n     * @return {[string, Array.<Object>]} Returns the name of the command with its\r\n     *     arguments\r\n     */\r\n    getMappedCommand(shortcut, hasInput) {\r\n        var args, command, keyCombination;\r\n        if (!this._isValidShortcut(shortcut, hasInput)) {\r\n            return [];\r\n        }\r\n        keyCombination = KeyboardShortcutMap.getKeyCombination(shortcut);\r\n        if (!this._isMapped(keyCombination)) {\r\n            return [];\r\n        }\r\n        command = this._hotkeyMap[keyCombination].command;\r\n        args = this._hotkeyMap[keyCombination].args;\r\n        return [command, args];\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given keyboard input event is a valid keyboard shortcut.\r\n     * @param {KeyboardEvent} shortcut\r\n     * @param {boolean} hasInput True if the input DOM element has text.\r\n     * @return {boolean}\r\n     */\r\n    _isValidShortcut(keyEvent, hasInput) {\r\n        var key = keyEvent.which;\r\n        if (keyEvent.metaKey || keyEvent.ctrlKey || keyEvent.altKey) {\r\n            return true;\r\n        }\r\n        else if (KeyboardShortcutMap.NO_MODIFIER_HOTKEYS.indexOf(key) >= 0) {\r\n            return true;\r\n        }\r\n        else {\r\n            return !hasInput && (KeyboardShortcutMap.NO_INPUT_HOTKEYS.indexOf(key) >= 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given shortcut has a command mapped to it.\r\n     * @param {string} shortcutName\r\n     * @return {boolean}\r\n     */\r\n    _isMapped(keyCombination) {\r\n        return keyCombination in this._hotkeyMap;\r\n    }\r\n\r\n    /**\r\n     * Maps hotkeys to commands and their arguments.\r\n     * Note: The modifier key order is important and must be consistant with\r\n     *  getKeyCombination().\r\n     * * command: What command the hotkey maps to.\r\n     * * group: What group of hotkeys the hotkey belongs to.\r\n     * * description: A quick description of the command. The command name is used by default.\r\n     * * args: What args should be passed in to the command.\r\n     */\r\n    _mapHotkeys() {\r\n        for (let windowNumber = 1; windowNumber <= 9; windowNumber += 1) {\r\n            this._addHotkey(`Ctrl-${windowNumber}`, {\r\n                command: \"win\",\r\n                group: \"Ctrl-#\",\r\n                description: \"switch channels\",\r\n                args: [windowNumber]\r\n            });\r\n        }\r\n        var nextRoomArray = [\r\n            \"Alt-DOWN\",\r\n            \"Ctrl-TAB\",\r\n            \"Alt-PAGEDOWN\"\r\n        ];\r\n        var previousRoomArray = [\r\n            \"Alt-UP\",\r\n            \"Ctrl-Shift-TAB\",\r\n            \"Alt-PAGEUP\"\r\n        ];\r\n\r\n        nextRoomArray.forEach(keys => this._addHotkey(keys, {command: \"next-room\"}));\r\n        previousRoomArray.forEach(keys => this._addHotkey(keys, {command: \"previous-room\"}));\r\n        this._addHotkey(\"Ctrl-W\", {\r\n            command: \"part\",\r\n            description: \"close current channel/private chat\"\r\n        });\r\n        this._addHotkey(\"Alt-S\", {\r\n            command: \"next-server\"\r\n        });\r\n        return this._addHotkey(\"TAB\", {\r\n            command: \"reply\",\r\n            description: \"autocomplete or reply to last mention\"\r\n        });\r\n    }\r\n\r\n    /**\r\n     * TODO: Implement the following commands:\r\n     *\r\n     *    @_addHotkey 'PAGEUP',\r\n     *      command: 'pageup'\r\n     *\r\n     *    @_addHotkey 'PAGEDOWN',\r\n     *      command: 'pageup'\r\n     *\r\n     *   @_addHotkey 'Ctrl-F',\r\n     *     command: 'search'\r\n     *\r\n     *   @_addHotkey 'Ctrl-HOME',\r\n     *     command: 'scroll-to-top'\r\n     *\r\n     *   @_addHotkey 'Ctrl-END',\r\n     *     command: 'scroll-to-bottom'\r\n     */\r\n    _addHotkey(keyCombination, description) {\r\n        var hotkeyCode = this._getHotkeyCode(keyCombination);\r\n        if (description.args == null) description.args = [];\r\n        this._hotkeyMap[hotkeyCode] = description;\r\n        this._hotkeyMap[hotkeyCode].readableName = keyCombination;\r\n        if (description.description) {\r\n            return this._hotkeyMap[hotkeyCode].description = description.description;\r\n        } else {\r\n            return this._hotkeyMap[hotkeyCode].description = description.command.replace(/-/g, \" \");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert a readable key combination into its key code value.\r\n     * (e.g. 'Alt-S' becomes 'Alt-115').\r\n     */\r\n    _getHotkeyCode(keyCombination) {\r\n        var char, parts;\r\n        parts = keyCombination.split(\"-\");\r\n        char = parts[parts.length - 1];\r\n        parts[parts.length - 1] = keyCodes.toKeyCode(char);\r\n        return parts.join(\"-\");\r\n    }\r\n}\r\n/**\r\n * Returns the stringified name for the given keyboard shortcut.\r\n * @param {KeyboardEvent} e\r\n */\r\nKeyboardShortcutMap.getKeyCombination = function getKeyCombination(e) {\r\n    var name = [];\r\n    if (e.ctrlKey) {\r\n        name.push(\"Ctrl\");\r\n    }\r\n    if (e.metaKey) {\r\n        name.push(\"Meta\");\r\n    }\r\n    if (e.altKey) {\r\n        name.push(\"Alt\");\r\n    }\r\n    if (e.shiftKey) {\r\n        name.push(\"Shift\");\r\n    }\r\n    name.push(e.which);\r\n    return name.join(\"-\");\r\n};\r\n/**\r\n* These keys can be mapped to hotkeys without needing a modifier key to be down.\r\n*/\r\nKeyboardShortcutMap.NO_MODIFIER_HOTKEYS = keyCodes.toKeyCode(\"PAGEUP\", \"PAGEDOWN\", \"CAPSLOCK\", \"INSERT\", \"F1\", \"F2\", \"F3\", \"F4\", \"F5\", \"F6\", \"F7\", \"F8\", \"F9\", \"F10\", \"F11\", \"F12\");\r\n\r\n/**\r\n * These keys can be mapped to hotkeys without needing a modifier key to be\r\n * down, but only if there is no input entered.\r\n */\r\nKeyboardShortcutMap.NO_INPUT_HOTKEYS = [keyCodes.toKeyCode(\"TAB\")];\r\n","import AbstractTCPSocket from \"./abstract_tcp_socket.js\";\r\n\r\n/**\r\n * A fake socket used when using another device's IRC connection.\r\n */\r\nexport default class RemoteSocket extends AbstractTCPSocket {\r\n    constructor(...args) {\r\n        super(...args);\r\n    }\r\n    setTimeout() {}\r\n    _active() {}\r\n}\r\n","/*eslint no-console: 0*/\r\nimport ChromeSocket from \"./chrome_socket\";\r\n\r\nexport default class SslSocket extends ChromeSocket {\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    _onConnect(rc) {\r\n        try {\r\n            this.secure(status => {\r\n                if (status < 0) {\r\n                    this.emit(\"error\", `Socket #${this.socketId} failed to upgrade to a secure connection with code ${rc}`);\r\n                    this.close();\r\n                }\r\n                else {\r\n                    super._onConnect(rc);\r\n                    console.info(\"Successfully secured the connection\");\r\n                }\r\n            });\r\n        } catch (e) {\r\n            this.emit(\"error\", `Socket #${this.socketId} failed to upgrade to a secure connection with code ${rc}`);\r\n            console.error(e.stack);\r\n        }\r\n    }\r\n\r\n    secure(callback) {\r\n        if (!this.socketId) {\r\n            this.emit(\"error\", `Socket #${this.socketId} is not created. Failed to upgrade.`);\r\n            callback(-1);\r\n            return;\r\n        }\r\n        chrome.sockets.tcp.secure(this.socketId, callback);\r\n    }\r\n}","/**\r\n * Utility class for determining the time between events.\r\n */\r\nexport default class Timer {\r\n    /**\r\n     * Mark the start time of an event.\r\n     * @param {string} name The name of the event.\r\n     */\r\n    start(name) {\r\n        return this._events[name] = {\r\n            startTime: this._getCurrentTime()\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Destroy the event and return the elapsed time.\r\n     * @param {string} name The name of the event.\r\n     */\r\n    finish(name) {\r\n        var time = this.elapsed(name);\r\n        delete this._events[name];\r\n        return time;\r\n    }\r\n\r\n    /**\r\n     * Returns the elapsed time..\r\n     * @param {string} name The name of the event.\r\n     */\r\n    elapsed(name) {\r\n        if (!this._events[name]) {\r\n            return 0;\r\n        }\r\n        return this._getCurrentTime() - this._events[name].startTime;\r\n    }\r\n\r\n    _getCurrentTime() {\r\n        return new Date().getTime();\r\n    }\r\n}\r\n/**\r\n * Maps events to their timing information.\r\n */\r\nTimer.prototype._events = {};\r\n","import {getLogger, isOnline} from \"../utils/utils\";\r\nimport Timer from \"../utils/timer\";\r\n\r\n/**\r\n * Handles sharing an IRC connections between multiple devices.\r\n */\r\nexport default class RemoteConnectionHandler {\r\n    constructor(chat) {\r\n        this._useOwnConnectionWhileWaitingForServer = this._useOwnConnectionWhileWaitingForServer\r\n            .bind(this);\r\n        this._reconnect = this._reconnect.bind(this);\r\n        this._onOffline = this._onOffline.bind(this);\r\n        this._onOnline = this._onOnline.bind(this);\r\n        this._tearDown = this._tearDown.bind(this);\r\n\r\n        this._log = getLogger(this);\r\n        this._timer = new Timer();\r\n        this._chat = chat;\r\n        this._addConnectionChangeListeners();\r\n        chat.on(\"tear_down\", this._tearDown);\r\n        if (!isOnline()) {\r\n            this._chat.notice.prompt(\"No internet connection found. You will be unable to connect to IRC.\");\r\n        }\r\n    }\r\n\r\n    _tearDown() {\r\n        return this._removeConnectionChangeListeners();\r\n    }\r\n\r\n    _addConnectionChangeListeners() {\r\n        $(window).on(\"online\", this._onOnline);\r\n        return $(window).on(\"offline\", this._onOffline);\r\n    }\r\n\r\n    _removeConnectionChangeListeners() {\r\n        $(window).off(\"online\", this._onOnline);\r\n        return $(window).off(\"offline\", this._onOffline);\r\n    }\r\n\r\n    /**\r\n     * Set the storage handler which is used to store IRC states and which device\r\n     *  is acting as the server\r\n     * @param {Storage} storage\r\n     */\r\n    setStorageHandler(storage) {\r\n        this._storage = storage;\r\n        this._remoteConnection.setIRCStateFetcher(() => this._storage.getState());\r\n        return this._remoteConnection.setChatLogFetcher(() => this._chat.messageHandler.getChatLog());\r\n    }\r\n\r\n    /**\r\n     * Set the remote connection which handles sending and receiving data from\r\n     *  connected devices.\r\n     * @param {RemoteConnection} remoteConnection\r\n     */\r\n    setRemoteConnection(remoteConnection) {\r\n        this._remoteConnection = remoteConnection;\r\n        return this._listenToRemoteConnectionEvents();\r\n    }\r\n\r\n    _onOnline() {\r\n        this._chat.notice.close();\r\n        this._timer.start(\"started_connection\");\r\n        return this.determineConnection();\r\n    }\r\n\r\n    _onOffline() {\r\n        this._chat.notice.prompt(\"You lost connection to the internet. You will be unable to connect to IRC.\");\r\n        return this._chat.remoteConnection.disconnectDevices();\r\n    }\r\n\r\n    _listenToRemoteConnectionEvents() {\r\n        this._chat.userCommands.listenTo(this._remoteConnection);\r\n        this._remoteConnection.on(\"found_addr\", () => this.determineConnection());\r\n        this._remoteConnection.on(\"no_addr\", () => this.useOwnConnection());\r\n        this._remoteConnection.on(\"no_port\", () => this.useOwnConnection());\r\n        this._remoteConnection.on(\"server_found\", () => {\r\n            var abruptSwitch;\r\n            this._chat.notice.close();\r\n            abruptSwitch = this._timer.elapsed(\"started_connection\")\r\n                    > RemoteConnectionHandler.NOTIFY_BEFORE_CONNECTING;\r\n            return abruptSwitch ? this._notifyConnectionAvailable()\r\n                : this._remoteConnection.finalizeConnection();\r\n        });\r\n        this._remoteConnection.on(\"invalid_server\", connectInfo => {\r\n            if (this._chat.remoteConnection.isInitializing()) {\r\n                this._onConnected = () => this._displayFailedToConnect(connectInfo);\r\n            } else if (!this._reconnectionAttempt) {\r\n                this._displayFailedToConnect(connectInfo);\r\n            }\r\n            this._reconnectionAttempt = false;\r\n            this.useOwnConnection();\r\n            return this._tryToReconnectToServerDevice();\r\n        });\r\n        this._remoteConnection.on(\"irc_state\", state => {\r\n            this._timer.start(\"started_connection\");\r\n            this._reconnectionAttempt = false;\r\n            this._storage.pause();\r\n            this._chat.closeAllConnections();\r\n            this._stopServerReconnectAttempts();\r\n            return this._storage.loadState(state);\r\n        });\r\n        this._remoteConnection.on(\"chat_log\", chatLog => {\r\n            var connInfo;\r\n            this._chat.messageHandler.replayChatLog(chatLog);\r\n            connInfo = this._remoteConnection.serverDevice;\r\n            if (!connInfo) return;\r\n            return this._chat.displayMessage(\"notice\", this._chat.getCurrentContext(),\r\n                    `Connected through server device ${connInfo.toString()}`);\r\n        });\r\n        this._remoteConnection.on(\"server_disconnected\", () => {\r\n            this._timer.start(\"started_connection\");\r\n            if (!this.manuallyDisconnected) {\r\n                this._onConnected = () => this._displayLostConnectionMessage();\r\n            }\r\n            return this.determineConnection();\r\n        });\r\n        this._remoteConnection.on(\"client_joined\", client => {\r\n            this._chat.displayMessage(\"notice\", this._chat.getCurrentContext(),\r\n                    `${client.addr} connected to this device`);\r\n            return this._chat.updateStatus();\r\n        });\r\n        return this._remoteConnection.on(\"client_parted\", client => {\r\n            this._chat.displayMessage(\"notice\", this._chat.getCurrentContext(),\r\n                    `${client.addr} disconnected from this device`);\r\n            return this._chat.updateStatus();\r\n        });\r\n    }\r\n\r\n    isManuallyConnecting() {\r\n        return this._timer.start(\"started_connection\");\r\n    }\r\n\r\n    _notifyConnectionAvailable() {\r\n        var message = \"Device discovered. Would you like to connect and use its IRC connection? [connect]\";\r\n        return this._chat.notice.prompt(message, () => {\r\n            this._reconnectionAttempt = false;\r\n            return this._chat.remoteConnection.finalizeConnection();\r\n        });\r\n    }\r\n\r\n    _displayFailedToConnect(connectInfo) {\r\n        if (!connectInfo) return;\r\n        return this._chat.displayMessage(\"notice\", this._chat.getCurrentContext(),\r\n                `Unable to connect to server device ${connectInfo.addr} on port ${connectInfo.port}`);\r\n    }\r\n\r\n    _displayLostConnectionMessage() {\r\n        return this._chat.displayMessage(\"notice\", this._chat.getCurrentContext(),\r\n                \"Lost connection to server device. Attempting to reconnect...\");\r\n    }\r\n\r\n    /**\r\n     * Determine if we should connect directly to IRC or connect through another\r\n     *  device's IRC connection.\r\n     */\r\n    determineConnection() {\r\n        if (!isOnline()) return;\r\n        this._log(\"determining connection...\",\r\n                this._remoteConnection.getConnectionInfo().addr,\r\n                this._storage.loadedServerDevice,\r\n                this._storage.password\r\n        );\r\n        if (!(this._remoteConnection.getConnectionInfo().addr\r\n                && this._storage.loadedServerDevice\r\n                && this._storage.password)) return;\r\n        this._log(\"can make a connection - device:\",\r\n                this._storage.serverDevice,\r\n                \"- is server?\",\r\n                this.shouldBeServerDevice()\r\n        );\r\n\r\n        return this._storage.serverDevice && !this.shouldBeServerDevice()\r\n            ? this._useServerDeviceConnection()\r\n            : this.useOwnConnection();\r\n    }\r\n\r\n    _useServerDeviceConnection() {\r\n        clearTimeout(this._useOwnConnectionTimeout);\r\n        if (this._alreadyConnectedToServerDevice()) return;\r\n        this._log(\"automatically connecting to\", this._storage.serverDevice);\r\n        if (this._remoteConnection.isInitializing()) {\r\n            this._useOwnConnectionIfServerTakesTooLong();\r\n        }\r\n        return this._remoteConnection.connectToServer(this._storage.serverDevice);\r\n    }\r\n\r\n    _alreadyConnectedToServerDevice() {\r\n        var serverDevice = this._remoteConnection.serverDevice,\r\n            status = this._remoteConnection.getState(),\r\n            usingServerDeviceConnection = status === \"connected\" || status === \"connecting\",\r\n            isCurrentServerDevice = serverDevice != null\r\n                    ? serverDevice.usesConnection(this._storage.serverDevice) : void 0;\r\n        return usingServerDeviceConnection && isCurrentServerDevice;\r\n    }\r\n\r\n    _useOwnConnectionIfServerTakesTooLong() {\r\n        return this._useOwnConnectionTimeout =\r\n            setTimeout(() => this._useOwnConnectionWhileWaitingForServer(), RemoteConnectionHandler.SERVER_DEVICE_CONNECTION_WAIT);\r\n    }\r\n\r\n    _tryToReconnectToServerDevice() {\r\n        clearTimeout(this._serverDeviceReconnectTimeout);\r\n        if (this._serverDeviceReconnectBackoff == null) {\r\n            this._serverDeviceReconnectBackoff = RemoteConnectionHandler.SERVER_DEVICE_RECONNECTION_WAIT;\r\n        }\r\n        return this._serverDeviceReconnectTimeout = setTimeout(() => this._reconnect(), this._serverDeviceReconnectBackoff);\r\n    }\r\n\r\n    _reconnect() {\r\n        var status = this._remoteConnection.getState();\r\n        this._reconnectionAttempt = true;\r\n        this._serverDeviceReconnectBackoff *= 1.2;\r\n        if (this._serverDeviceReconnectBackoff > RemoteConnectionHandler.SERVER_DEVICE_RECONNECTION_MAX_WAIT) {\r\n            this._serverDeviceReconnectBackoff = RemoteConnectionHandler.SERVER_DEVICE_RECONNECTION_MAX_WAIT;\r\n        }\r\n        if (!(status === \"connecting\" || status === \"connected\")) {\r\n            return this.determineConnection();\r\n        }\r\n    }\r\n\r\n    _stopServerReconnectAttempts() {\r\n        clearTimeout(this._serverDeviceReconnectTimeout);\r\n        return this._serverDeviceReconnectBackoff = RemoteConnectionHandler.SERVER_DEVICE_RECONNECTION_WAIT;\r\n    }\r\n\r\n    _useOwnConnectionWhileWaitingForServer() {\r\n        var connectInfo;\r\n        if (!this._remoteConnection.isInitializing()) return;\r\n        this._remoteConnection.becomeIdle();\r\n        connectInfo = this._storage.serverDevice;\r\n        this._onConnected = () => this._displayFailedToConnect(connectInfo);\r\n        return this._resumeIRCConnection();\r\n    }\r\n\r\n    useOwnConnection() {\r\n        var shouldResumeIRCConn, usingServerDeviceConnection;\r\n        clearTimeout(this._useOwnConnectionTimeout);\r\n        usingServerDeviceConnection = this._remoteConnection.getState() === \"connected\";\r\n        if (usingServerDeviceConnection) {\r\n            this.manuallyDisconnected = true;\r\n            this._remoteConnection.disconnectFromServer();\r\n            this.manuallyDisconnected = false;\r\n            return;\r\n        }\r\n        if (this.shouldBeServerDevice()) {\r\n            this._chat.notice.close();\r\n            this._stopServerReconnectAttempts();\r\n            this._tryToBecomeServerDevice();\r\n            return;\r\n        }\r\n        shouldResumeIRCConn = this._notUsingOwnIRCConnection();\r\n        if (this._remoteConnection.isIdle()) {\r\n            return;\r\n        }\r\n        this._stopBeingServerDevice();\r\n        if (shouldResumeIRCConn) {\r\n            return this._resumeIRCConnection();\r\n        }\r\n    }\r\n\r\n    _tryToBecomeServerDevice() {\r\n        var shouldResumeIRCConn;\r\n        shouldResumeIRCConn = this._notUsingOwnIRCConnection();\r\n        if (this._remoteConnection.getState() === \"finding_port\") {\r\n            this._remoteConnection.waitForPort(() => this.determineConnection());\r\n            this._log(\"should be server, but havent found port yet...\");\r\n            return;\r\n        }\r\n        if (this._remoteConnection.getState() === \"no_port\") {\r\n            if (this._remoteConnection.isServer()) {\r\n                this._stopBeingServerDevice();\r\n            }\r\n        }\r\n        else if (!this._remoteConnection.isServer()\r\n                || this._storage.serverDevice.port !== this._remoteConnection.getConnectionInfo().port) {\r\n            this._becomeServerDevice();\r\n        }\r\n        else return;\r\n\r\n        if (shouldResumeIRCConn) {\r\n            return this._resumeIRCConnection();\r\n        }\r\n    }\r\n\r\n    _notUsingOwnIRCConnection() {\r\n        return this._remoteConnection.isInitializing() || this._remoteConnection.isClient();\r\n    }\r\n\r\n    _stopBeingServerDevice() {\r\n        if (this._remoteConnection.isServer()) {\r\n            this._log(\"stopped being a server device\");\r\n            return this._remoteConnection.disconnectDevices();\r\n        } else {\r\n            return this._remoteConnection.becomeIdle();\r\n        }\r\n    }\r\n\r\n    shouldBeServerDevice() {\r\n        /**\r\n         * TODO check something stored in local storage, not IP addr which can change\r\n         */\r\n        var _ref1, _ref2;\r\n        return _ref1 = (_ref2 = this._storage.serverDevice) != null\r\n                ? _ref2.addr\r\n                : void 0, this._remoteConnection.getConnectionInfo().possibleAddrs.indexOf(_ref1) >= 0;\r\n    }\r\n\r\n    _becomeServerDevice() {\r\n        this._log(\"becoming server device\");\r\n        if (!this._remoteConnection.isInitializing()) {\r\n            this._chat.displayMessage(\"notice\", this._chat.getCurrentContext(),\r\n                    \"Now accepting connections from other devices\");\r\n        }\r\n        this._remoteConnection.becomeServer();\r\n        return this._storage.becomeServerDevice(this._remoteConnection.getConnectionInfo());\r\n    }\r\n\r\n    _resumeIRCConnection() {\r\n        this._timer.start(\"started_connection\");\r\n        this._log(\"resuming IRC conn\");\r\n        this._chat.closeAllConnections();\r\n        return this._storage.restoreSavedState(() => this._onUsingOwnConnection());\r\n    }\r\n\r\n    _onUsingOwnConnection() {\r\n        this._selectFirstRoom();\r\n        this._chat.messageHandler.replayChatLog();\r\n        this._storage.resume();\r\n        if (typeof this._onConnected === \"function\") {\r\n            this._onConnected();\r\n        }\r\n        this._onConnected = void 0;\r\n        if (!this._storage.completedWalkthrough) {\r\n            return this._chat.startWalkthrough();\r\n        }\r\n    }\r\n\r\n    _selectFirstRoom() {\r\n        if (this._chat.winList.length > 1) {\r\n            return this._chat.switchToWindow(this._chat.winList.get(0));\r\n        }\r\n    }\r\n}\r\n/**\r\n * Number of ms to wait for a connection to be established to a server device\r\n *  before using our own IRC connection.\r\n */\r\nRemoteConnectionHandler.SERVER_DEVICE_CONNECTION_WAIT = 650;\r\n\r\n/**\r\n * If this many milliseconds go by after the user has connected to their own\r\n *  IRC connection, we will notify them before switching to a remote server\r\n *  connection.\r\n */\r\nRemoteConnectionHandler.NOTIFY_BEFORE_CONNECTING = 1500;\r\n\r\n/**\r\n * Number of ms to wait before trying to reconnect to the server device.\r\n */\r\nRemoteConnectionHandler.SERVER_DEVICE_RECONNECTION_WAIT = 500;\r\nRemoteConnectionHandler.SERVER_DEVICE_RECONNECTION_MAX_WAIT = 5 * 1000;\r\n","import EventEmitter from \"../utils/event_emitter\";\r\nimport DeveloperCommands from \"./developer_commands\";\r\nimport IRCMessageHandler from \"./irc_message_handler\";\r\nimport IRC from \"../irc/irc\";\r\nimport Context from \"./context\";\r\nimport UserCommandHandler from \"./user_command_handler\";\r\nimport WindowList from \"./window_list\";\r\nimport Notice from \"./notice\";\r\nimport ChannelList from \"./channel_list\";\r\nimport Window from \"./window\";\r\nimport Walkthrough from \"./walkthrough\";\r\nimport Storage from \"./storage\";\r\nimport ScriptLoader from \"../script/script_loader\";\r\n\r\nimport KeyboardShortcutMap from \"../input/keyboard_shortcut_map\";\r\n\r\nimport RemoteConnection from \"../net/remote_connection\";\r\nimport RemoteConnectionHandler from \"../net/remote_connection_handler\";\r\n\r\nimport Event from \"../utils/event\";\r\nimport {getFieldOrNull, pluralize, html} from \"../utils/utils\";\r\nimport {clientSocketSupported} from \"../utils/api\";\r\nimport {VERSION} from \"../utils/globals\";\r\nimport iter from \"lazy.js\";\r\n\r\n/**\r\n * Chat Application Class\r\n */\r\nexport default class Chat extends EventEmitter {\r\n    constructor() {\r\n        super();\r\n        // Binding Event Handlers to the instance\r\n        this.onMessageEvent = this.onMessageEvent.bind(this);\r\n        this.onServerEvent = this.onServerEvent.bind(this);\r\n        this.onIRCEvent = this.onIRCEvent.bind(this);\r\n\r\n        var devCommands = new DeveloperCommands(this);\r\n\r\n        this.connections = {};\r\n        this.messageHandler = new IRCMessageHandler(this);\r\n        this.userCommands = new UserCommandHandler(this);\r\n\r\n        this.userCommands.merge(devCommands);\r\n        this._initializeUI();\r\n        this._initializeRemoteConnection();\r\n        this._initializeStorage();\r\n        this._initializeScripts();\r\n        this._listenForUpdates();\r\n        this._keyboardShortcutMap = new KeyboardShortcutMap;\r\n        this.updateStatus();\r\n\r\n        window.webkitRequestFileSystem(PERSISTENT, 50 * 1024, function(fileSystem) {\r\n            fileSystem.root.getFile(\"custom_style.css\", { create: false },\r\n                fileEntry => $(\"#main-style\").attr(\"href\", fileEntry.toURL()));\r\n        });\r\n    }\r\n    /**\r\n     * Initialise the chat application\r\n     */\r\n    init() {\r\n        if (clientSocketSupported()) {\r\n            this.storage.init();\r\n            return this.remoteConnection.init();\r\n        } else {\r\n            return this._displaySocketSupportError();\r\n        }\r\n    }\r\n\r\n    getKeyboardShortcuts() {\r\n        return this._keyboardShortcutMap;\r\n    }\r\n\r\n    /**\r\n     * Tell the user that they need chrome.sockets support to run CIRC.\r\n     */\r\n    _displaySocketSupportError() {\r\n        var message = \"CIRC cannot run on this device. Support for chrome.sockets is required to connect to the IRC server. Please update your version of Chrome and try again.\";\r\n        return this.displayMessage(\"error\", this.getCurrentContext(), message);\r\n    }\r\n\r\n    tearDown() {\r\n        return this.emit(\"tear_down\");\r\n    }\r\n\r\n    _initializeUI() {\r\n        this.winList = new WindowList;\r\n        this.notice = new Notice;\r\n        this.toggleChannelDisplay = $(\"#hide-channels\");\r\n        this.toggleChannelDisplay.click(() => {\r\n            $(\"#rooms-and-nicks\")[0].classList.toggle(\"hidden\");\r\n        });\r\n        this.channelDisplay = new ChannelList();\r\n        this.channelDisplay.on(\"clicked\", (server, chan) => {\r\n            let win = this.winList.get(server, chan);\r\n            if (win != null)\r\n                return this.switchToWindow(win);\r\n        });\r\n        this.channelDisplay.on(\"midclicked\", (server, chan) => {\r\n            this.disconnectAndRemoveRoom(server, chan);\r\n        });\r\n        this.channelDisplay.on(\"remove_button_clicked\", (server, chan) => {\r\n            this.disconnectAndRemoveRoom(server, chan);\r\n        });\r\n        this.channelDisplay.on(\"help_type_command\", (text) => {\r\n            this.emit(\"set_input\", text);\r\n            this.emit(\"blink_input\");\r\n        });\r\n        this._addWelcomeWindow();\r\n    }\r\n\r\n    _addWelcomeWindow() {\r\n        this.emptyWindow = new Window(\"none\");\r\n        this.channelDisplay.addAlwaysEmptyServer(this.emptyWindow.name);\r\n        this.switchToWindow(this.emptyWindow);\r\n        return this.emptyWindow.messageRenderer.displayWelcome();\r\n    }\r\n\r\n    _initializeRemoteConnection() {\r\n        this.remoteConnection = new RemoteConnection;\r\n        this.remoteConnectionHandler = new RemoteConnectionHandler(this);\r\n        return this.remoteConnectionHandler.setRemoteConnection(this.remoteConnection);\r\n    }\r\n\r\n    _initializeStorage() {\r\n        this.storage = new Storage(this);\r\n        return this.remoteConnectionHandler.setStorageHandler(this.storage);\r\n    }\r\n\r\n    /**\r\n     * Load prepackaged scripts the first time the app is run. These scripts are\r\n     *  loaded from storage on subsequent runs.\r\n     */\r\n    _initializeScripts() {\r\n        return this.storage.on(\"initialized\", () => {\r\n            if (this.storage.loadedPrepackagedScripts) return;\r\n            ScriptLoader.loadPrepackagedScripts(script => this.addScript(script));\r\n            return this.storage.finishedLoadingPrepackagedScripts();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Inform listeners (like ScriptHandler) that a script has been loaded and\r\n     *  save the script to local storage.\r\n     * @param {Script} script\r\n     */\r\n    addScript(script) {\r\n        this.scriptHandler.addScript(script);\r\n        return this.storage.scriptAdded(script);\r\n    }\r\n\r\n    _listenForUpdates() {\r\n        var onUpdateAvailable;\r\n        if (chrome.runtime.reload === null) return;\r\n        return (onUpdateAvailable = chrome.runtime.onUpdateAvailable) != null\r\n                ? onUpdateAvailable.addListener(() => this._promptToUpdate())\r\n                : void 0;\r\n    }\r\n\r\n    _promptToUpdate() {\r\n        var message = \"A new version of CIRC is available. Would you like to restart and update? [update]\";\r\n        return this.notice.prompt(message, () => chrome.runtime.reload());\r\n    }\r\n\r\n    startWalkthrough() {\r\n        var walkthrough = new Walkthrough(this, this.storage);\r\n        walkthrough.listenToIRCEvents(this._ircEvents);\r\n        return walkthrough.on(\"tear_down\", () => this.storage.finishedWalkthrough());\r\n    }\r\n\r\n    setPassword(password) {\r\n        return this.remoteConnection.setPassword(password);\r\n    }\r\n\r\n    closeAllConnections() {\r\n        clearTimeout(this._useOwnConnectionTimeout);\r\n        return iter(this.connections).values().each(connection => this.closeConnection(connection));\r\n    }\r\n\r\n    closeConnection(conn, reason) {\r\n        if (conn.irc.state === \"reconnecting\") {\r\n            conn.irc.giveup();\r\n        } else {\r\n            conn.irc.quit(reason);\r\n        }\r\n        return this.removeWindow(this.winList.get(conn.name));\r\n    }\r\n\r\n    listenToCommands(commandEmitter) {\r\n        this.remoteConnection.broadcastUserInput(commandEmitter);\r\n        return this.userCommands.listenTo(commandEmitter);\r\n    }\r\n\r\n    listenToScriptEvents(scriptHandler) {\r\n        this.scriptHandler = scriptHandler;\r\n        scriptHandler.on(\"save\", (id, item) => this.storage.saveItemForScript(id, item));\r\n        return scriptHandler.on(\"load\", (id, onLoaded) => this.storage.loadItemForScript(id, onLoaded));\r\n    }\r\n\r\n    listenToIRCEvents(ircEvents) {\r\n        this._ircEvents = ircEvents;\r\n        this._ircEvents.on(\"server\", this.onIRCEvent);\r\n        return this._ircEvents.on(\"message\", this.onIRCEvent);\r\n    }\r\n\r\n    connect(server, port, password) {\r\n        var irc;\r\n        if (server in this.connections) {\r\n            irc = this.connections[server].irc.state;\r\n            /*\r\n             * TODO disconnect and reconnect if port changed\r\n             */\r\n            if (irc.state === \"connected\" || irc.state === \"connecting\") return;\r\n        } else {\r\n            this._createConnection(server, port);\r\n            this._createWindowForServer(server, port, password);\r\n        }\r\n        return this.connections[server].irc.connect(server, port, password);\r\n    }\r\n\r\n    _createConnection(server, port) {\r\n        var irc = new IRC(this.remoteConnection.createSocket(server, port));\r\n        if (this.preferredNick) {\r\n            irc.setPreferredNick(this.preferredNick);\r\n        }\r\n        if (this._ircEvents != null) {\r\n            this._ircEvents.addEventsFrom(irc);\r\n        }\r\n        return this.connections[server] = {\r\n            irc: irc,\r\n            name: server,\r\n            windows: {}\r\n        };\r\n    }\r\n\r\n    _createWindowForServer(server, port, password) {\r\n        var conn = this.connections[server],\r\n            win = this._makeWin(conn);\r\n\r\n        this._replaceEmptyWindowIfExists(win);\r\n        win.message(\"\", `Connecting to ${conn.name}...`);\r\n        this.channelDisplay.addServer(conn.name);\r\n        this.storage.serverJoined(conn.name, port, password);\r\n        return this.switchToWindow(win);\r\n    }\r\n\r\n    _replaceEmptyWindowIfExists(win) {\r\n        if (this.currentWindow.equals(this.emptyWindow)) {\r\n            this.channelDisplay.remove(this.emptyWindow.name);\r\n            return win.messageRenderer.displayWelcome();\r\n        }\r\n    }\r\n\r\n    join(conn, channel, opt_key) {\r\n        var win;\r\n        if (!conn.irc.isValidChannelPrefix(channel)) {\r\n            channel = \"#\" + channel;\r\n        }\r\n        win = this._createWindowForChannel(conn, channel);\r\n        this.switchToWindow(win);\r\n        this.storage.channelJoined(conn.name, channel, null, opt_key);\r\n        return conn.irc.join(channel, opt_key);\r\n    }\r\n\r\n    setNick(opt_server, nick) {\r\n        var server;\r\n        if (!nick) {\r\n            nick = opt_server;\r\n            server = void 0;\r\n        } else {\r\n            server = opt_server;\r\n        }\r\n        this._setNickLocally(nick);\r\n        this._tellServerNickChanged(nick, server);\r\n        return this._emitNickChangedEvent(nick);\r\n    }\r\n\r\n    _setNickLocally(nick) {\r\n        this.preferredNick = nick;\r\n        this.storage.nickChanged(nick);\r\n        return this.updateStatus();\r\n    }\r\n\r\n    _tellServerNickChanged(nick, server) {\r\n        var conn = this.connections[server];\r\n        if (conn != null) {\r\n            conn.irc.doCommand(\"NICK\", nick);\r\n        }\r\n        return conn != null ? conn.irc.setPreferredNick(nick) : void 0;\r\n    }\r\n\r\n    _emitNickChangedEvent(nick) {\r\n        var event;\r\n        event = new Event(\"server\", \"nick\", nick);\r\n        event.setContext(this.getCurrentContext());\r\n        return this.emit(event.type, event);\r\n    }\r\n\r\n    onIRCEvent(e) {\r\n        var conn = this.connections[e.context.server];\r\n        if (e.type === \"server\") {\r\n            return this.onServerEvent(conn, e);\r\n        } else {\r\n            return this.onMessageEvent(conn, e);\r\n        }\r\n    }\r\n\r\n    onServerEvent(conn, e) {\r\n        if (!conn) return;\r\n        switch (e.name) {\r\n        case \"connect\":\r\n            return this.onConnected(conn);\r\n        case \"disconnect\":\r\n            return this.onDisconnected(conn);\r\n        case \"joined\":\r\n            return this.onJoined(conn, e.context.channel, ...e.args);\r\n        case \"names\":\r\n            return this.onNames(e, ...e.args);\r\n        case \"parted\":\r\n            return this.onParted(e);\r\n        case \"nick\":\r\n            return this.updateStatus();\r\n        }\r\n    }\r\n\r\n    onMessageEvent(conn, e) {\r\n        var win = this.determineWindow(e);\r\n        if (win === Chat.NO_WINDOW) return;\r\n        this.messageHandler.setWindow(win);\r\n        this.messageHandler.setCustomMessageStyle(e.style);\r\n        return this.messageHandler.handle(e.name, ...e.args);\r\n    }\r\n    /**\r\n     * Determine the window for which the event belongs.\r\n     * @param {Event} e The event whose context we're looking at.\r\n     */\r\n    determineWindow(e) {\r\n        var chan,\r\n            conn = this.connections[e.context.server];\r\n        if (!conn) return this.emptyWindow;\r\n        if (e.context.channel === Chat.CURRENT_WINDOW\r\n                && e.context.server !== getFieldOrNull(this.currentWindow, [\"conn\", \"name\"])) {\r\n            e.context.channel = Chat.SERVER_WINDOW;\r\n        }\r\n        chan = e.context.channel;\r\n        if (this._isDirectMessageToUser(conn, chan, e.name)) {\r\n            let from = getFieldOrNull(e, [\"args\", 0]);\r\n            return this.createPrivateMessageWindow(conn, from);\r\n        }\r\n        if (!chan || chan === Chat.SERVER_WINDOW) {\r\n            return conn.serverWindow;\r\n        }\r\n        if (chan === Chat.CURRENT_WINDOW) {\r\n            return this.currentWindow;\r\n        }\r\n        if (conn.windows[chan.toLowerCase()]) {\r\n            return conn.windows[chan.toLowerCase()];\r\n        }\r\n        return Chat.NO_WINDOW;\r\n    }\r\n\r\n    /**\r\n     * Direct messages (e.g. /msg) have the channel set to the user\"s nick.\r\n     */\r\n    _isDirectMessageToUser(conn, chan, type) {\r\n        return (conn != null ? conn.irc.isOwnNick(chan) : void 0) && type === \"privmsg\";\r\n    }\r\n\r\n    createPrivateMessageWindow(conn, from) {\r\n        var win,\r\n            lowerCaseFrom = from.toLowerCase();\r\n\r\n        if (conn.windows[lowerCaseFrom]) {\r\n            return conn.windows[lowerCaseFrom];\r\n        }\r\n        this.storage.channelJoined(conn.name, from, \"private\");\r\n        win = conn.windows[lowerCaseFrom] = this._createWindowForChannel(conn, from);\r\n        win.makePrivate();\r\n        win.message(\"\", `You're in a private conversation with ${from}.`, \"notice\");\r\n        this.channelDisplay.connect(conn.name, from);\r\n        return win;\r\n    }\r\n    /**\r\n     * Keep track of the last person to mention the user\"s nick in each room.\r\n     * @param  {string} context\r\n     * @param  {any} user\r\n     */\r\n    recordLastUserToMention(context, user) {\r\n        if (this._lastUsersToMention == null) {\r\n            this._lastUsersToMention = {};\r\n        }\r\n        return this._lastUsersToMention[context] = user;\r\n    }\r\n    /**\r\n     * Returns the last person to mention the user\"s nick for a given room.\r\n     * @param  {string} context\r\n     */\r\n    getLastUserToMention(context) {\r\n        return getFieldOrNull(this, [\"_lastUsersToMention\", context]);\r\n    }\r\n\r\n    onConnected(conn) {\r\n        this.displayMessage(\"connect\", {\r\n            server: conn.name\r\n        });\r\n        this.updateStatus();\r\n        this.channelDisplay.connect(conn.name);\r\n\r\n        return iter(conn.windows).pairs().each(([channel, win]) => {\r\n            this.displayMessage(\"connect\", {\r\n                server: conn.name,\r\n                channel: win.target\r\n            });\r\n            if (win.isPrivate()) {\r\n                return this.channelDisplay.connect(conn.name, channel);\r\n            }\r\n            else {\r\n                return void 0;\r\n            }\r\n        });\r\n    }\r\n\r\n    onDisconnected(conn) {\r\n        this.displayMessage(\"disconnect\", {\r\n            server: conn.name\r\n        });\r\n        this.channelDisplay.disconnect(conn.name);\r\n\r\n        return iter(conn.windows).pairs().each(([channel, window]) => {\r\n            this.channelDisplay.disconnect(conn.name, channel);\r\n            return this.displayMessage(\"disconnect\", {\r\n                server: conn.name,\r\n                channel: window.target\r\n            });\r\n        });\r\n    }\r\n\r\n    onJoined(conn, chan) {\r\n        var win = this._createWindowForChannel(conn, chan);\r\n        this.channelDisplay.connect(conn.name, chan);\r\n        return win.nicks.clear();\r\n    }\r\n\r\n    _createWindowForChannel(conn, chan) {\r\n        var win = conn.windows[chan.toLowerCase()];\r\n        if (!win) {\r\n            win = this._makeWin(conn, chan);\r\n            this.channelDisplay.insertChannel(this.winList.localIndexOf(win), conn.name, chan);\r\n        }\r\n        return win;\r\n    }\r\n\r\n    onNames(e, nicks) {\r\n        var win = this.determineWindow(e);\r\n        if (win === Chat.NO_WINDOW) return;\r\n        return nicks.map(nick => win.nicks.add(nick));\r\n    }\r\n\r\n    onParted(e) {\r\n        var win = this.determineWindow(e);\r\n        if (win === Chat.NO_WINDOW) return;\r\n        return this.channelDisplay.disconnect(win.conn.name, win.target);\r\n    }\r\n\r\n    disconnectAndRemoveRoom(server, channel, opt_reason) {\r\n        var win = this.winList.get(server, channel);\r\n        if (win) {\r\n            if (!channel) {\r\n                this.closeConnection(win.conn, opt_reason);\r\n            }\r\n            else {\r\n                if (!win.isPrivate()) {\r\n                    win.conn.irc.part(channel, opt_reason);\r\n                }\r\n                this.removeWindow(win);\r\n            }\r\n        }\r\n    }\r\n\r\n    removeWindow(win) {\r\n        var index, removedWindows;\r\n        if (win == null) {\r\n            win = this.currentWindow;\r\n        }\r\n        index = this.winList.indexOf(win);\r\n        if (win.isServerWindow()) {\r\n            if (this._ircEvents != null) {\r\n                this._ircEvents.removeEventsFrom(win.conn.irc);\r\n            }\r\n        }\r\n        removedWindows = this.winList.remove(win);\r\n        removedWindows.forEach(window => this._removeWindowFromState(window));\r\n        return this._selectNextWindow(index);\r\n    }\r\n\r\n    _removeWindowFromState(win) {\r\n        this.channelDisplay.remove(win.conn.name, win.target);\r\n        this.storage.parted(win.conn.name, win.target);\r\n        win.notifications.clear();\r\n        if (win.target != null) {\r\n            delete this.connections[win.conn.name].windows[win.target];\r\n        } else {\r\n            delete this.connections[win.conn.name];\r\n        }\r\n        return win.remove();\r\n    }\r\n\r\n    _selectNextWindow(preferredIndex) {\r\n        if (this.winList.length === 0) {\r\n            this.channelDisplay.addAlwaysEmptyServer(this.emptyWindow.name);\r\n            return this.switchToWindow(this.emptyWindow);\r\n        }\r\n        else if (this.winList.indexOf(this.currentWindow) === -1) {\r\n            let windex = this.winList.get(preferredIndex);\r\n            let nextWin = windex != null ? windex : this.winList.get(preferredIndex - 1);\r\n            return this.switchToWindow(nextWin);\r\n        }\r\n        else {\r\n            return this.switchToWindow(this.currentWindow);\r\n        }\r\n    }\r\n\r\n    _makeWin(conn, opt_chan) {\r\n        var channel = getFieldOrNull(conn.irc, [\"channels\", opt_chan, \"channel\"]) || opt_chan,\r\n            win = new Window(conn.name, channel);\r\n        win.conn = conn;\r\n        if (opt_chan) {\r\n            let ocLowerCase = opt_chan.toLowerCase();\r\n            conn.windows[ocLowerCase] = win;\r\n            win.setTarget(ocLowerCase);\r\n            win.nicks.on(\"dblclicked\",\r\n                    nick => this.switchToWindow(this.createPrivateMessageWindow(win.conn, nick)));\r\n        } else {\r\n            conn.serverWindow = win;\r\n        }\r\n        this.winList.add(win);\r\n        this.messageHandler.logMessagesFromWindow(win);\r\n        return win;\r\n    }\r\n\r\n    updateStatus() {\r\n        var away, topic,\r\n            conn = this.currentWindow.conn,\r\n            nick = this.preferredNick;\r\n\r\n        if (conn) {\r\n            let channelName = this.currentWindow.target,\r\n                channel = channelName ? this.currentWindow.conn.irc.channels[channelName] : undefined;\r\n\r\n            nick = this.currentWindow.conn.irc.nick || this.preferredNick;\r\n            away = this.currentWindow.conn.irc.away;\r\n            if (channel) topic = channel.topic;\r\n        }\r\n\r\n        $(\"#nick\").html((nick ? `<span class=\"name\">${html.escape(nick)}</span>` : \"\")\r\n                + (away ? \"<span class=\\\"away\\\">away</span>\" : \"\"));\r\n        $(\"#status\").html(topic ? `<span title=\"${html.escape(topic)}\" class=\"topic\">${html.display(topic)}</span>`\r\n                : \"\");\r\n        return this._updateDocumentTitle();\r\n    }\r\n\r\n    _updateDocumentTitle() {\r\n        var connectedDevices,\r\n            remoteConnection = this.remoteConnection,\r\n            titleList = [];\r\n        titleList.push(`CIRC ${VERSION}`);\r\n\r\n        if (remoteConnection) {\r\n            if (remoteConnection.isClient()) {\r\n                titleList.push(`- Connected through ${this.remoteConnection.serverDevice.addr}`);\r\n            }\r\n            else if (this.remoteConnection.isServer()) {\r\n                connectedDevices = this.remoteConnection.devices.length;\r\n                titleList.push(`- Server for ${connectedDevices} other ${pluralize(\"device\", connectedDevices)}`);\r\n            }\r\n        }\r\n        return document.title = titleList.join(\" \");\r\n    }\r\n    /**\r\n     * Switch to a window that represents a channel by its position in the rooms\r\n     *  list.\r\n     * @param  {any} winNum\r\n     */\r\n    switchToChannelByIndex(winNum) {\r\n        var win = this.winList.getChannelWindow(winNum);\r\n        if (win != null) {\r\n            return this.switchToWindow(win);\r\n        }\r\n    }\r\n\r\n    switchToWindow(win) {\r\n        if (win == null)\r\n            throw new Error(\"switching to non-existant window\");\r\n\r\n        if (this.currentWindow)\r\n            this.currentWindow.detach();\r\n\r\n        this.currentWindow = win;\r\n        win.attach();\r\n        this._focusInput();\r\n        this._selectWindowInChannelDisplay(win);\r\n        return this.updateStatus();\r\n    }\r\n\r\n    _focusInput() {\r\n        var input = $(\"#input\");\r\n        if (input)\r\n            setTimeout(() => input.focus(), 0);\r\n    }\r\n\r\n    _selectWindowInChannelDisplay(win) {\r\n        if (win.conn) {\r\n            return this.channelDisplay.select(win.conn.name, win.target);\r\n        } else {\r\n            return this.channelDisplay.select(win.name);\r\n        }\r\n    }\r\n    /**\r\n     * Emits a message to the script handler, which decides if it should send it back\r\n     */\r\n    displayMessage(name, context, ...rest) {\r\n        var event = new Event(\"message\", name, ...rest);\r\n        event.setContext(context.server, context.channel);\r\n        return this.emit(event.type, event);\r\n    }\r\n\r\n    getCurrentContext() {\r\n        return new Context(getFieldOrNull(this.currentWindow.conn, [\"name\"]), Chat.CURRENT_WINDOW);\r\n    }\r\n}\r\n\r\nChat.SERVER_WINDOW = \"@server_window\";\r\nChat.CURRENT_WINDOW = \"@current_window\";\r\nChat.NO_WINDOW = \"NO_WINDOW\";","/**\r\n * A traversable stack of all input entered by the user.\r\n */\r\nexport default class InputStack {\r\n    constructor() {\r\n        this._previousInputs = [\"\"];\r\n        this._previousInputIndex = 0;\r\n    }\r\n    /**\r\n     * Keeps track of the unentered input that was present when the user\r\n     * began traversing the stack.\r\n     * @param {string} text\r\n     */\r\n    setCurrentText(text) {\r\n        if (this._previousInputIndex === 0) {\r\n            return this._previousInputs[0] = text;\r\n        }\r\n    }\r\n\r\n    showPreviousInput() {\r\n        if (!(this._previousInputIndex >= this._previousInputs.length - 1)) {\r\n            this._previousInputIndex++;\r\n            return this._previousInputs[this._previousInputIndex];\r\n        }\r\n        return void 0;\r\n    }\r\n\r\n    showNextInput() {\r\n        if (!(this._previousInputIndex <= 0)) {\r\n            this._previousInputIndex--;\r\n            return this._previousInputs[this._previousInputIndex];\r\n        }\r\n        return void 0;\r\n    }\r\n\r\n    /**\r\n     * Restarts the traversal position. Should be called when the user begins\r\n     *  typing a new command.\r\n     */\r\n    reset() {\r\n        return this._previousInputIndex = 0;\r\n    }\r\n\r\n    /**\r\n     * Add input to the stack.\r\n     * @param {string} input\r\n     */\r\n    addInput(input) {\r\n        return this._previousInputs.splice(1, 0, input);\r\n    }\r\n}\r\n","import iter from \"lazy.js\";\r\n/**\r\n * Finds completions for a partial word.\r\n * Completion candidates can be set using setCompletions() or by specifying a\r\n *  completion generator function.\r\n */\r\nexport default class CompletionFinder {\r\n    /**\r\n     * Create a new completion finder and optionally set a callback that can be\r\n     *  used to retrieve completion candidates.\r\n     * @param {function:string[]} opt_getCompletionsCallback\r\n     */\r\n    constructor(opt_getCompletionsCallback) {\r\n        this._emptyCompletions = () => iter([]);\r\n        this._completions = this._emptyCompletions();\r\n        this._getCompletions = opt_getCompletionsCallback;\r\n        this.reset();\r\n    }\r\n    /**\r\n     * Set a callback that can be used to retrieve completion candidates.\r\n     * @param {function:string[]} completionGenerator\r\n     */\r\n    setCompletionGenerator(completionGenerator) {\r\n        return this._getCompletions = completionGenerator;\r\n    }\r\n    /**\r\n     * Clear stored completion candidates.\r\n     */\r\n    clearCompletions() {\r\n        return this._completions = this._emptyCompletions();\r\n    }\r\n    /**\r\n     * Add completion candidates.\r\n     * @param {string[]} completions\r\n     */\r\n    addCompletions(completions) {\r\n        return this._completions = this._completions.concat(completions);\r\n    }\r\n\r\n    setCompletions(completions) {\r\n        this.clearCompletions();\r\n        return this.addCompletions(completions);\r\n    }\r\n    /**\r\n     * Get a completion for the current stub.\r\n     * The stub only needs to be passed in the first time getCompletion() is\r\n     *  called or after reset() is called.\r\n     * @param {string} opt_stub The partial word to auto-complete.\r\n     */\r\n    getCompletion(opt_stub) {\r\n        if (!this.hasStarted) {\r\n            this._generateCompletions();\r\n            this._currentStub = opt_stub;\r\n            this._findCompletions();\r\n            this.hasStarted = true;\r\n        }\r\n        return this._getNextCompletion();\r\n    }\r\n    /**\r\n     * Add completions from the completion generator, if set.\r\n     */\r\n    _generateCompletions() {\r\n        if (this._getCompletions != null) {\r\n            return this.setCompletions(this._getCompletions());\r\n        }\r\n    }\r\n    /**\r\n     * Create a list of all possible completions for the current stub.\r\n     */\r\n    _findCompletions() {\r\n        var ignoreCase = !/[A-Z]/.test(this._currentStub);\r\n\r\n        return this._currentCompletions = this._completions\r\n            .filter(completion => {\r\n                const text = ignoreCase ? completion.toString().toLowerCase() : completion.toString();\r\n                return text.indexOf(this._currentStub) === 0;\r\n            });\r\n    }\r\n    /**\r\n     * Get the next completion, or NONE if no completions are found.\r\n     * Completions are returned by iterating through the list of possible\r\n     *  completions.\r\n     * @returns {string|NONE}\r\n     */\r\n    _getNextCompletion() {\r\n        if (this._currentCompletions.isEmpty())\r\n            return CompletionFinder.NONE;\r\n\r\n        const result = this._currentCompletions.get(this._completionIndex);\r\n        this._completionIndex++;\r\n        if (this._completionIndex >= this._currentCompletions.size())\r\n            this._completionIndex = 0;\r\n\r\n        return result;\r\n    }\r\n    /**\r\n     * Reset the current stub and clear the list of possible completions.\r\n     * The current stub will be set again the next time getCompletion() is called.\r\n     */\r\n    reset() {\r\n        this._currentCompletions = null;\r\n        this._completionIndex = 0;\r\n        this.currentStub = \"\";\r\n        return this.hasStarted = false;\r\n    }\r\n}\r\n\r\n/**\r\n * Returned when no completion was found.\r\n */\r\nCompletionFinder.NONE = void 0;\r\n","import {getFieldOrNull} from \"../utils/utils\";\r\nimport CompletionFinder from \"./completion_finder\";\r\nimport iter from \"lazy.js\";\r\n\r\n/**\r\n * Simple storage class for completions which stores the completion text\r\n *  and type of completion.\r\n */\r\nclass Completion {\r\n    /**\r\n     * @param  {string} text\r\n     * @param  {number} type\r\n     */\r\n    constructor(text, type) {\r\n        this._text = text;\r\n        this._type = type;\r\n        if (this._type === Completion.CMD) {\r\n            this._text = \"/\" + this._text;\r\n        }\r\n    }\r\n    getText() {\r\n        return this._text;\r\n    }\r\n\r\n    getType() {\r\n        return this._type;\r\n    }\r\n\r\n    getSuffix(preCompletionLength) {\r\n        if (this._type === Completion.NICK && preCompletionLength === 0) {\r\n            return Completion.COMPLETION_SUFFIX + \" \";\r\n        }\r\n        return \" \";\r\n    }\r\n\r\n    toString() {\r\n        return this.getText();\r\n    }\r\n}\r\n/**\r\n * Completions can either be commands or nicks.\r\n */\r\nCompletion.CMD = 0;\r\nCompletion.NICK = 1;\r\nCompletion.COMPLETION_SUFFIX = \":\";\r\n\r\n\r\n/**\r\n * Takes a string and replaces a word with its completion based on the cursor position.\r\n * Currently only supports completion of nicks in the current window.\r\n */\r\nexport default class AutoComplete {\r\n    constructor() {\r\n        this._getPossibleCompletions = this._getPossibleCompletions.bind(this);\r\n        this._completionFinder = new CompletionFinder;\r\n    }\r\n    /**\r\n     * Set the context from which the list of nicks can be generated.\r\n     * @param {{currentWindow: {target: string, conn: Object}}} context\r\n     */\r\n    setContext(context) {\r\n        this._context = context;\r\n        return this._completionFinder.setCompletionGenerator(this._getPossibleCompletions);\r\n    }\r\n\r\n    /**\r\n     * Returns a list of possible auto-completions in the current channel.\r\n     * @return {Array.<Completion>}\r\n     */\r\n    _getPossibleCompletions() {\r\n        return this._getCommandCompletions().concat(this._getNickCompletions());\r\n    }\r\n\r\n    /**\r\n     * Returns a sorted list of visible commands.\r\n     * @return {Array<Completion>}\r\n     */\r\n    _getCommandCompletions() {\r\n        return iter(this._context.userCommands.getCommands())\r\n            .values()\r\n            .filter(command => command.category !== \"hidden\")\r\n            .sort()\r\n            .map(command => new Completion(command, Completion.CMD));\r\n    }\r\n\r\n    /**\r\n     * Returns a list of nicks in the current channel.\r\n     * @return {Array<Completion>}\r\n     */\r\n    _getNickCompletions() {\r\n        var irc = this._context.currentWindow.conn.irc,\r\n            chan = this._context.currentWindow.target,\r\n            nicks = getFieldOrNull(irc, [\"channels\", chan, \"names\"]);\r\n        if (nicks != null) {\r\n            return iter(nicks)\r\n                .values()\r\n                .map(nick => new Completion(nick, Completion.NICK));\r\n        }\r\n        return [];\r\n    }\r\n\r\n    /**\r\n     * Returns the passed in text, with the current stub replaced with its\r\n     *  completion.\r\n     * @param {string} text The text the user has input.\r\n     * @param {number} cursor The current position of the cursor.\r\n     */\r\n    getTextWithCompletion(text, cursor) {\r\n        let completion, textWithCompletion;\r\n        this._text = text;\r\n        this._cursor = cursor;\r\n        if (this._previousText !== this._text)\r\n            this._completionFinder.reset();\r\n\r\n        this._previousCursor = this._cursor;\r\n        if (!this._completionFinder.hasStarted)\r\n            this._extractStub();\r\n\r\n        completion = this._getCompletion();\r\n        textWithCompletion = this._preCompletion + completion + this._postCompletion;\r\n        this._updatedCursorPosition = this._preCompletion.length + completion.length;\r\n        this._previousText = textWithCompletion;\r\n        return textWithCompletion;\r\n    }\r\n\r\n    getUpdatedCursorPosition() {\r\n        return this._updatedCursorPosition || 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the completion for the current stub with the completion suffix and\r\n     *  or space after.\r\n     */\r\n    _getCompletion() {\r\n        const completion = this._completionFinder.getCompletion(this._stub);\r\n        if (completion === CompletionFinder.NONE)\r\n            return this._stub;\r\n\r\n        return completion.getText() + completion.getSuffix(this._preCompletion.length);\r\n    }\r\n\r\n    /**\r\n     * Finds the stub by looking at the cursor position, then finds the text before\r\n     *  and after the stub.\r\n     */\r\n    _extractStub() {\r\n        var preStubEnd,\r\n            stubEnd = this._findNearest(this._cursor - 1, /\\S/);\r\n        if (stubEnd < 0)\r\n            stubEnd = 0;\r\n\r\n        preStubEnd = this._findNearest(stubEnd, /\\s/);\r\n        this._preCompletion = this._text.slice(0, preStubEnd + 1);\r\n        this._stub = this._text.slice(preStubEnd + 1, +stubEnd + 1 || 9e9);\r\n        return this._postCompletion = this._text.slice(stubEnd + 1);\r\n    }\r\n\r\n    /**\r\n     * Searches backwards until the regex matches the current character.\r\n     * @return {number} The position of the matched character or -1 if not found.\r\n     */\r\n    _findNearest(start, regex) {\r\n        var i, _i;\r\n        for (i = _i = start; start <= 0 ? _i <= 0 : _i >= 0; i = start <= 0 ? ++_i : --_i) {\r\n            if (regex.test(this._text[i])) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n\r\nAutoComplete.COMPLETION_SUFFIX = \":\";\r\n","import EventEmitter from \"../utils/event_emitter\";\r\nimport InputStack from \"./input_stack\";\r\nimport AutoComplete from \"./auto_complete\";\r\nimport keyCodes from \"./keycodes\";\r\nimport Event from \"../utils/event\";\r\n\r\n/**\r\n * Manages keyboard and hotkey input from the user, including autocomplete and\r\n * traversing through previous commands.\r\n */\r\nexport default class UserInputHander extends EventEmitter {\r\n    /**\r\n     * Initialise the User Input\r\n     * @param  {jQueryElement} input\r\n     * @param  {jQueryWindow} window\r\n     */\r\n    constructor(input, window) {\r\n        super();\r\n        this.input = input;\r\n        this.window = window;\r\n        // Binding Event Handlers and methods to the instance\r\n        this._sendUserCommand = this._sendUserCommand.bind(this);\r\n        this._handleKeydown = this._handleKeydown.bind(this);\r\n        this._handleGlobalKeydown = this._handleGlobalKeydown.bind(this);\r\n\r\n        this.input.focus();\r\n        this._inputStack = new InputStack;\r\n        this._autoComplete = new AutoComplete;\r\n        this.input.keydown(this._handleKeydown);\r\n        this.window.keydown(this._handleGlobalKeydown);\r\n    }\r\n\r\n    setContext(context) {\r\n        this._context = context;\r\n        this._autoComplete.setContext(this._context);\r\n        this._context.on(\"set_input_if_empty\", text => {\r\n            if (!this.input.val()) {\r\n                this.setInput(text);\r\n            }\r\n        });\r\n        this._context.on(\"set_input\", text => this.setInput(text));\r\n        this._context.on(\"blink_input\", () => {\r\n            this.input.css(\"-webkit-transition\", \"0\");\r\n            this.input.addClass(\"blink\");\r\n            setTimeout(() => {\r\n                this.input.css(\"-webkit-transition\", \"300ms\");\r\n                this.input.removeClass(\"blink\");\r\n            }, 0);\r\n        });\r\n    }\r\n\r\n    setInput(text) {\r\n        this.input.val(text);\r\n        // If setInput was called because of a click, we need to wait for the\r\n        // click to propagate before setting focus.\r\n        setTimeout(() => this.input.focus(), 0);\r\n    }\r\n\r\n    setKeyboardShortcuts(keyboardShortcuts) {\r\n        return this._keyboardShortcutMap = keyboardShortcuts;\r\n    }\r\n\r\n    _handleGlobalKeydown(e) {\r\n        this.text = this.input.val();\r\n        this._focusInputOnKeyPress(e);\r\n        this._handleKeyboardShortcuts(e);\r\n        if (e.isDefaultPrevented()) {\r\n            return false;\r\n        }\r\n        this._showPreviousCommandsOnArrowKeys(e);\r\n        this._autoCompleteOnTab(e);\r\n        return !e.isDefaultPrevented();\r\n    }\r\n\r\n    _focusInputOnKeyPress(e) {\r\n        if (!(e.metaKey || e.ctrlKey)) {\r\n            e.currentTarget = this.input[0];\r\n            return this.input.focus();\r\n        }\r\n    }\r\n\r\n    _handleKeyboardShortcuts(e) {\r\n        var event,\r\n            [command, args] = this._keyboardShortcutMap.getMappedCommand(e, this.input.val());\r\n\r\n        if (!command) {\r\n            return;\r\n        }\r\n        e.preventDefault();\r\n        event = new Event(\"command\", command, ...args);\r\n        return this._emitEventToCurrentWindow(event);\r\n    }\r\n\r\n    _showPreviousCommandsOnArrowKeys(e) {\r\n        if (e.which === keyCodes.toKeyCode(\"UP\") || e.which === keyCodes.toKeyCode(\"DOWN\")) {\r\n            let input;\r\n            e.preventDefault();\r\n            if (e.which === keyCodes.toKeyCode(\"UP\")) {\r\n                this._inputStack.setCurrentText(this.text);\r\n                input = this._inputStack.showPreviousInput();\r\n            } else {\r\n                input = this._inputStack.showNextInput();\r\n            }\r\n            if (input != null) {\r\n                return this.input.val(input);\r\n            }\r\n        } else {\r\n            return this._inputStack.reset();\r\n        }\r\n    }\r\n\r\n    _autoCompleteOnTab(e) {\r\n        if (e.which === keyCodes.toKeyCode(\"TAB\")) {\r\n            e.preventDefault();\r\n            if (this.text) {\r\n                const textWithCompletion = this._autoComplete\r\n                    .getTextWithCompletion(this.text, this._getCursorPosition());\r\n                this.input.val(textWithCompletion);\r\n                return this._setCursorPosition(this._autoComplete.getUpdatedCursorPosition());\r\n            }\r\n        }\r\n    }\r\n\r\n    _setCursorPosition(pos) {\r\n        return this.input[0].setSelectionRange(pos, pos);\r\n    }\r\n\r\n    _getCursorPosition() {\r\n        return this.input[0].selectionStart;\r\n    }\r\n\r\n    _handleKeydown(e) {\r\n        this.text = this.input.val();\r\n        if (e.which === keyCodes.toKeyCode(\"ENTER\")) {\r\n            if (this.text.length > 0) {\r\n                this.input.val(\"\");\r\n                this._sendUserCommand();\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Wrap the input in an event and emit it.\r\n     */\r\n    _sendUserCommand() {\r\n        var event, name, words;\r\n        this._inputStack.addInput(this.text);\r\n        words = this.text.split(/\\s/);\r\n        if (this.text[0] === \"/\") {\r\n            name = words[0].slice(1).toLowerCase();\r\n            words = words.slice(1);\r\n        } else {\r\n            name = \"say\";\r\n        }\r\n        event  = new Event(\"command\", name, ...words);\r\n        return this._emitEventToCurrentWindow(event);\r\n    }\r\n\r\n    _emitEventToCurrentWindow(event) {\r\n        event.context = this._context.currentWindow.getContext();\r\n        return this.emit(event.type, event);\r\n    }\r\n}\r\n","import EventEmitter from \"../utils/event_emitter\";\r\nimport Event from \"../utils/event\";\r\nimport {getLogger, removeFromArray} from \"../utils/utils\";\r\nimport Script from \"./script\";\r\nimport iter from \"lazy.js\";\r\n\r\n/**\r\n * Handles currently running scripts. Events sent from the user and IRC servers\r\n *  are intercepted by this class, passed to scripts, and then forwarded on to\r\n *  their destination.\r\n */\r\nexport default class ScriptHandler extends EventEmitter {\r\n    constructor() {\r\n        super();\r\n        this._handleMessage = this._handleMessage.bind(this);\r\n        this._handleEvent = this._handleEvent.bind(this);\r\n\r\n        this._scripts = {};\r\n        this._pendingEvents = Object.create(null);\r\n        this._eventCount = 0;\r\n        this._emitters = [];\r\n        this._propagationTimeoutTimerId = null;\r\n        this._log = getLogger(this);\r\n        addEventListener(\"message\", this._handleMessage);\r\n    }\r\n\r\n    listenToScriptEvents(emitter) {\r\n        return emitter.on(\"script_loaded\", this.addScript);\r\n    }\r\n\r\n    /**\r\n     * Add a script to the list of currently active scripts. Once added, the script\r\n     *  will receive events from the user and IRC server.\r\n     * @param {Script} script\r\n     */\r\n    addScript(script) {\r\n        return this._scripts[script.id] = script;\r\n    }\r\n\r\n    /**\r\n     * Remove a script to the list of currently active scripts. Once removed,\r\n     * the script will not longer receive events from the user or IRC server.\r\n     * @param {Script} script\r\n     */\r\n    removeScript(script) {\r\n        this._getPendingEventsForScript(script)\r\n            .each(eventID => this._stopHandlingEvent(script, eventID));\r\n\r\n        return delete this._scripts[script.id];\r\n    }\r\n    /**\r\n     * @param  {Script} script\r\n     * @return {Sequence}\r\n     */\r\n    _getPendingEventsForScript(script) {\r\n        return iter(this._pendingEvents)\r\n            .values()\r\n            .filter(pendingEvent =>\r\n                !pendingEvent.scripts.some(pendingScript => pendingScript.id === script.id))\r\n            .map(({id}) => id);\r\n    }\r\n\r\n    on(ev, cb) {\r\n        if (ScriptHandler.HOOKABLE_EVENTS.indexOf(ev) >= 0\r\n        || ScriptHandler.SCRIPTING_EVENTS.indexOf(ev) >= 0) {\r\n            return super.on.call(this, ev, cb);\r\n        } else {\r\n            return this._forwardEvent(ev, cb);\r\n        }\r\n    }\r\n\r\n    _forwardEvent(ev, cb) {\r\n        return this._emitters.map(emitter => emitter.on(ev, cb));\r\n    }\r\n\r\n    addEventsFrom(emitter) {\r\n        this._emitters.push(emitter);\r\n        return ScriptHandler.HOOKABLE_EVENTS.map(event => emitter.on(event, this._handleEvent));\r\n    }\r\n\r\n    removeEventsFrom(emitter) {\r\n        this._emitters.splice(this._emitters.indexOf(emitter), 1);\r\n        return ScriptHandler.HOOKABLE_EVENTS.map(event => emitter.removeListener(event, this._handleEvent));\r\n    }\r\n\r\n    _handleEvent(event) {\r\n        event.id = this._eventCount++;\r\n        if (this._eventCanBeForwarded(event)) {\r\n            this._offerEventToScripts(event);\r\n        }\r\n        if (!this._eventIsBeingHandled(event.id)) {\r\n            return this._emitEvent(event);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Certain events are not allowed to be intercepted by scripts for security reasons.\r\n     * @param {Event} event\r\n     * @return {boolean} Returns true if the event can be forwarded to scripts.\r\n     */\r\n    _eventCanBeForwarded(event) {\r\n        return !(event.hook in ScriptHandler.UNINTERCEPTABLE_EVENTS);\r\n    }\r\n\r\n    _offerEventToScripts(event) {\r\n        return iter(this._scripts)\r\n            .values()\r\n            .filter(script => script.shouldHandle(event))\r\n            .each(script => this._sendEventToScript(event, script));\r\n    }\r\n\r\n    _sendEventToScript(event, script) {\r\n        script.postMessage(event);\r\n        this._markEventAsPending(event, script);\r\n        if (!this._propagationTimeoutTimerId) {\r\n            this._propagationTimeoutTimerId = setTimeout(\r\n                this._checkPropagationTimeout.bind(this), ScriptHandler.PROPAGATION_TIMEOUT);\r\n        }\r\n    }\r\n\r\n    _markEventAsPending(event, script) {\r\n        if (!this._pendingEvents[event.id]) {\r\n            this._pendingEvents[event.id] = {};\r\n            this._pendingEvents[event.id].event = event;\r\n            this._pendingEvents[event.id].scripts = [];\r\n            this._pendingEvents[event.id].timestamp = Date.now();\r\n        }\r\n        return this._pendingEvents[event.id].scripts.push(script);\r\n    }\r\n\r\n    _checkPropagationTimeout() {\r\n        iter(this._getUnresponsiveScripts())\r\n            .values()\r\n            .each(script => {\r\n                this._log(\"e\", `Removing unresponsive script ${script.getName()}`);\r\n                this.removeScript(script);\r\n            });\r\n        this._propagationTimeoutTimerId = null;\r\n        if (!this._isPendingEventQueueEmpty()) {\r\n            this._propagationTimeoutTimerId = setTimeout(\r\n                this._checkPropagationTimeout.bind(this), this._getNextPendingEventTimeout());\r\n        }\r\n    }\r\n\r\n    _getUnresponsiveScripts() {\r\n        var now = Date.now();\r\n\r\n        return iter(this._pendingEvents)\r\n            .values()\r\n            .filter(pendingEvent => pendingEvent.timestamp + ScriptHandler.PROPAGATION_TIMEOUT <= now)\r\n            .map(pendingEvent => pendingEvent.scripts)\r\n            .flatten()\r\n            .indexBy(\"id\")\r\n            .toObject();\r\n    }\r\n\r\n    _isPendingEventQueueEmpty() {\r\n        for (let id in this._pendingEvents) {\r\n            id;\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    _getNextPendingEventTimeout() {\r\n        var smallestTimestamp = iter(this._pendingEvents)\r\n            .values()\r\n            .reduce((smallest, pendingEvent) => pendingEvent.timestamp < smallest\r\n                ? pendingEvent.timestamp\r\n                : smallest, Number.MAX_VALUE);\r\n\r\n        var nextTimeout = smallestTimestamp\r\n                          + ScriptHandler.PROPAGATION_TIMEOUT\r\n                          - Date.now();\r\n        if (nextTimeout > ScriptHandler.PROPAGATION_TIMEOUT || nextTimeout <= 0) {\r\n            nextTimeout = ScriptHandler.PROPAGATION_TIMEOUT;\r\n        }\r\n        return nextTimeout;\r\n    }\r\n\r\n    _eventIsBeingHandled(eventId) {\r\n        if (!(eventId in this._pendingEvents)) {\r\n            return false;\r\n        }\r\n        return this._pendingEvents[eventId].scripts.length > 0;\r\n    }\r\n\r\n    _handleMessage(message) {\r\n        var type,\r\n            event = message.data,\r\n            script = Script.getScriptFromFrame(this._scripts, message.source);\r\n\r\n        if (script == null) return;\r\n\r\n        switch (event.type) {\r\n        case \"hook_command\":\r\n        case \"hook_server\":\r\n        case \"hook_message\":\r\n            type = event.type.slice(5);\r\n            return script.beginHandlingType(type, event.name);\r\n        case \"command\":\r\n        case \"sevrer\":\r\n        case \"message\":\r\n            return this._emitEvent(Event.wrap(event));\r\n        case \"propagate\":\r\n            return this._handleEventPropagation(script, event);\r\n        case \"meta\":\r\n            return this._handleMetaData(script, event);\r\n        case \"storage\":\r\n            return this._handleStorageRequest(script, event);\r\n        }\r\n    }\r\n\r\n    _handleEventPropagation(script, propagatationEvent) {\r\n        var eventId, scriptsHandlingEvent, _ref1;\r\n        eventId = (_ref1 = propagatationEvent.args) != null ? _ref1[0] : void 0;\r\n        if (!this._eventIsBeingHandled(eventId)) {\r\n            return;\r\n        }\r\n        scriptsHandlingEvent = this._pendingEvents[eventId].scripts;\r\n        if (scriptsHandlingEvent.indexOf(script) < 0) {\r\n            return;\r\n        }\r\n        switch (propagatationEvent.name) {\r\n        case \"none\":\r\n            return delete this._pendingEvents[eventId];\r\n        case \"all\":\r\n            return this._stopHandlingEvent(script, eventId);\r\n        default:\r\n            return this._log(\"w\", \"received unknown propagation type:\", propagatationEvent.name);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles a meta data event, such as setting the script name.\r\n     * @param {Script} script\r\n     * @param {Event} event\r\n     */\r\n    _handleMetaData(script, event) {\r\n        var name, uniqueName;\r\n        switch (event.name) {\r\n        case \"name\":\r\n            name = event.args[0];\r\n            if (!this._isValidName(name)) {\r\n                return;\r\n            }\r\n            uniqueName = this._getUniqueName(name);\r\n            return script.setName(uniqueName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns true if the given script name contains only valid characters.\r\n     * @param {string} name The script name.\r\n     * @return {boolean}\r\n     */\r\n    _isValidName(name) {\r\n        return name && /^[a-zA-Z0-9\\/_-]+$/.test(name);\r\n    }\r\n\r\n    /**\r\n     * Appends numbers to the end of the script name until it is unique.\r\n     * @param {string} name\r\n     */\r\n    _getUniqueName(name) {\r\n        var originalName, suffix;\r\n        originalName = name = name.slice(0, +(ScriptHandler.MAX_NAME_LENGTH - 1) + 1 || 9e9);\r\n        suffix = 1;\r\n        while (this.getScriptNames().indexOf(name) >= 0) {\r\n            suffix++;\r\n            name = originalName + suffix;\r\n        }\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * Handles loading or saving information to storage for the given script.\r\n     * @param {Script} script The script wishing to use the storage.\r\n     * @param {Event} event The event which contains the object to save.\r\n     */\r\n    _handleStorageRequest(script, event) {\r\n        switch (event.name) {\r\n        case \"save\":\r\n            // itemToSave = event.args[0];\r\n            return this.emit(\"save\", script.getName(), event.args[0]);\r\n        case \"load\":\r\n            return this.emit(\"load\", script.getName(), item => script.postMessage(new Event(\"system\", \"loaded\", item)));\r\n        }\r\n    }\r\n\r\n    storageChanged(script, change) {\r\n        return script.postMessage(new Event(\"system\", \"storage_changed\", change));\r\n    }\r\n\r\n    getScriptNames() {\r\n        return iter(this._scripts).values().map(script => script.getName());\r\n    }\r\n\r\n    getScriptByName(name) {\r\n        return iter(this._scripts).find(script => script.getName() === name);\r\n    }\r\n\r\n    _emitEvent(event) {\r\n        return this.emit(event.type, event);\r\n    }\r\n\r\n    _stopHandlingEvent(script, eventId) {\r\n        var scriptsHandlingEvent = this._pendingEvents[eventId].scripts;\r\n        removeFromArray(scriptsHandlingEvent, script);\r\n        if (!this._eventIsBeingHandled(eventId)) {\r\n            let event = this._pendingEvents[eventId].event;\r\n            delete this._pendingEvents[eventId];\r\n            return this._emitEvent(event);\r\n        }\r\n    }\r\n\r\n    tearDown() {\r\n        return removeEventListener(\"message\", this._handleEvent);\r\n    }\r\n}\r\n/**\r\n * Script names that are longer this this are truncated.\r\n */\r\nScriptHandler.MAX_NAME_LENGTH = 20;\r\n\r\n/**\r\n * The amount of time a script has to acknowlege an event by calling\r\n * propagate. If it fails to call propagate within this many milliseconds\r\n * of receiving the event, the script will be uninstalled.\r\n */\r\nScriptHandler.PROPAGATION_TIMEOUT = 5000; // 5 seconds\r\n\r\n\r\n/**\r\n * A set of events that cannot be intercepted by scripts.\r\n */\r\nScriptHandler.UNINTERCEPTABLE_EVENTS = {\r\n    \"command help\": \"command help\",\r\n    \"command about\": \"command about\",\r\n    \"command install\": \"command install\",\r\n    \"command uninstall\": \"command uninstall\",\r\n    \"command scripts\": \"command scripts\"\r\n};\r\n\r\n/**\r\n * Events that a script can listen for.\r\n */\r\nScriptHandler.HOOKABLE_EVENTS = [\"command\", \"server\", \"message\"];\r\n\r\n/**\r\n * Events that are generated and sent by the script handler.\r\n */\r\nScriptHandler.SCRIPTING_EVENTS = [\"save\", \"load\"];\r\n","import Chat from \"./chat/chat\";\r\nimport UserInputHandler from \"./input/user_input_handler\";\r\nimport ScriptHandler from \"./script/script_handler\";\r\n\r\n(function () {\r\n    \"use strict\";\r\n    var chat, scriptHandler, userInput;\r\n    userInput = new UserInputHandler($(\"#input\"), $(window));\r\n    scriptHandler = new ScriptHandler;\r\n    chat = new Chat;\r\n\r\n    userInput.setContext(chat);\r\n    userInput.setKeyboardShortcuts(chat.getKeyboardShortcuts());\r\n\r\n    scriptHandler.addEventsFrom(chat);\r\n    scriptHandler.addEventsFrom(userInput);\r\n\r\n    chat.listenToCommands(scriptHandler);\r\n    chat.listenToScriptEvents(scriptHandler);\r\n    chat.listenToIRCEvents(scriptHandler);\r\n    chat.init();\r\n\r\n}).call(this);\r\n"],"names":["escape","html","escaped","String","replace","character","_ref","stripColorCodes","parseColorCodes","colors","color","background","bold","italics","underline","res","match","gr1","gr2","gr3","gr4","parseInt","_display","text","allowHtml","regx","canonicalise","innerEscape","textIndex","escapeHTML","url","str","longWords","map","word","reduce","result","replacement","n","indexOf","length","slice","m","exec","substr","index","makeDisplay","rurl","args","getFieldOrNull","arguments","getLoggerForType","apply","getReadableList","array","setTime","window","onLine","removeFromArray","toRemove","i","chooseFile","fileEntry","chrome","runtime","unregisterSocketId","remove","socketId","BB","bb","Blob","resultView","arrayBufferConversionCount","e","readAsText","hashString","s","ret","abs","nick","makeCommand","params","cmd","randomName","nicksEqual","a","fromSocketData","arrayBuffer2String","ab","cb","emptySocketData","sockets","errorHandler","c","rstr2hex","input","x","output","fromCharCode","olda","oldb","b","oldc","oldd","d","md5_ff","md5_gg","md5_hh","display","this","ObjectWrapper","MappedSequence","FilteredSequence","filterFn","sequence","parent","TakeSequence","count","predicate","keyFn","arrays","WithoutSequence","values","UniqueMemoizer","undefined","ChunkedSequence","size","callback","IndexedDropSequence","other","mapFn","AssignSequence","others","Array","PickSequence","OmitSequence","StringMatchSequence","pattern","cloneRegex","delimiter","GeneratedSequence","promise","then","value","thenableState","RESOLVED","consumeListeners","getOnNextCallback","Lazy","propertyValue","propertyName","name","ctor","override","factory","strict","source","prototype","root","fn","each","reverse","iterator","getIterator","getIndex","moveNext","ConcatenatedSequence","Sequence","first","takeWhile","skipWhile","done","descending","SortedSequence","Set","shuffled","includedInAll","set","memo","currentValue","every","createCallback","indexed","upper","lower","tail","currentChunk","min","max","sum","begin","ArrayLikeSequence","IndexedUniqueSequence","key","MemoizedSequence","cache","cachedResult","get","UniqueArrayWrapper","toArray","arrayContainsBefore","find","push","j","sourceLength","ObjectLikeSequence","define","parentValue","call","MergedSequence","merged","forEach","iteratedFullSource","properties","arrayContains","valFn","val","counted","isAsync","StringLikeSequence","start","last","end","leftIndex","rightIndex","StringWrapper","charAt","cancellationId","cancelCallback","onNextCallback","_resolve","PENDING","onRejected","state","REJECTED","reason","watch","propertyNames","WatchedPropertySequence","SplitStreamSequence","getEachForDelimiter","chunk","buffer","pieceIndex","piece","handle","onComplete","listener","listeners","repeat","add","contents","_key2","_handlers","type","handler","message","userCommands","DeveloperCommands","channel","NickMentionedNotification","RegExp","msg","parsePrefix","toSocketData","createClass","_message","_from","_content","youPlaceholders","_nick","Object","_formatter","setContent","_topic","addStyle","setMessage","topic","from","to","setFromUs","setContentMessage","setToUs","ChatLog","_chat","ignoredMessages","contextList","_win","customStyle","pre","_ref1","_nickWasMentioned","activity","win","app","current","_base","hasStyle","shouldNotify","style","Event$1","_key","param","irc","nameList","names","async","iter","pairs","filter","Chat","emitMessage","channels","chanName","console","target","event","payload","warn","toLowerCase","modeList","modes","mode","user","_emitUserNotice","loggedin","space","newNick","ServerResponseHandler","possibleConstructorReturn","_this","_this2","setPaused","data","opt_socket","on","socket","onEnd","password","send","pdata","util","_this3","rest","classCallCheck","_params","descriptionText","_description","server","conn","chat","_trimQuotes","Script","error","sourceCode","document","port","join","_ret","messageRenderer","customCommandParser","displayMessage","_ref2","setModeArgs","addr","_this4","createPrivateMessageWindow","_this5","requestFileSystem","webkitRequestFileSystem","fileSystem","winList","nextWin","serverWindow","chan","_servers","concat","_i","_len","_ref3","candidate","equals","_hide","$","trim","removeClass","HTMLList","newNode","content","node","ChannelList","_footerHtml","mousedown","emit","_postMessage","hotkeyInfo","systemMessage","outerHTML","_scrollPosition","_node","scrollPosition","Scrollable","babelHelpers","nodeNames","_EventEmitter","_onFocus","focus","css","ghostbar","_isFocused","_addNickUI","nicks","restoreScrollPosition","Walkthrough","_currentStep","position","bind","changeMap","enabled","_store","some","_channels","splice","script","findIndex","local","connection","storage","_restoreChannels","_restoreIgnoredMessages","Storage","STATE_ITEMS","_state","ircState","item","KeyCodes","F7","readableName","KeyboardShortcutMap","id","RemoteDevice","_this6","_socketId","_onAccept","Uint8Array","JSON","close","_this8","tcp","_onConnect","receiveInfo","partialMessage","_onReceive","_log","stringify","_parseReceivedMessages","RemoteSocket","_getAuthToken","_thisDevice","newDevice","isValid","device","getState","closedDevice","blacklistedDevice","once","startTime","_useOwnConnectionWhileWaitingForServer","_storage","_remoteConnection","remoteConnection","useOwnConnection","_timer","closeAllConnections","_stopServerReconnectAttempts","disconnectFromServer","manuallyDisconnected","isServer","shouldResumeIRCConn","_resumeIRCConnection","becomeServerDevice","RemoteConnectionHandler","devCommands","init","notice","toggleChannelDisplay","toggle","ScriptLoader$1","loadPrepackagedScripts","scriptHandler","connections","_ircEvents","updateStatus","clear","channelDisplay","determineWindow","opt_reason","removedWindows","_this11","setTarget","currentWindow","connectedDevices","devices","title","_getCompletions","_currentCompletions","currentStub","Completion","AutoComplete","UserInputHander","_sendUserCommand","_showPreviousCommandsOnArrowKeys","_keyboardShortcutMap","toKeyCode","_stopHandlingEvent","ScriptHandler","_markEventAsPending","_propagationTimeoutTimerId","setTimeout","_checkPropagationTimeout","_pendingEvents","scripts","removeScript","now","smallestTimestamp","PROPAGATION_TIMEOUT","_emitEvent","wrap","_handleEventPropagation","setName"],"mappings":"wBACO,SAASA,GAAOC,MACfC,QACK,YACA,WACA,WACC,aACD,gBAEFC,QAAOF,GAAMG,QAAQ,YAAa,SAASC,MAC1CC,SACkC,QAA9BA,EAAOJ,EAAQG,IAAsBC,EAAOD,IAIrD,QAASE,GAAgBN,SACrBA,GAAKG,QAAQ,4BAA6B,IAAIA,QAAQ,sBAAuB,IAOjF,QAASI,GAAgBP,MACxBQ,IACA,qBACA,eACA,iBACA,iBACA,iBACA,kBACA,mBACA,oBACA,mBACA,mBACA,mBACA,mBACA,iBACA,mBACA,qBACA,sBAGAC,EAAQ,KACRC,EAAa,KACbC,GAAO,EACPC,GAAU,EACVC,GAAY,EAEZC,EAAMd,EAAKG,QAAQ,oFAAqF,SAASY,EAAOC,EAAKC,EAAKC,EAAKC,SAC5H,KAAPH,KACQ,OACK,QACN,KACG,KACE,GACE,KAAPA,KACCL,EACM,KAAPK,KACMH,EACC,KAAPG,KACIJ,GAEPK,IACAR,EAAQD,EAAOY,SAASH,KAExBC,IACAR,EAAaF,EAAOY,SAASF,MAGhCC,EAGE,iBACFV,EAAQ,UAAYA,EAAQ,IAAM,KAClCC,EAAa,qBAAuBA,EAAa,IAAM,KACvDC,EAAO,qBAAuB,KAC9BE,EAAY,8BAAgC,KAC5CD,EAAU,sBAAwB,IACnC,KACAO,EACA,UAVO,WAaRL,GAGJ,QAASO,GAASC,EAAMC,EAAWC,MAClCC,GAAcC,EAAaZ,EAAKa,EAChCC,EAAa7B,IAEF,qBACLO,EAAgBuB,KAChBD,EAAWC,GACbA,EAAId,MAAM,kBACHc,YAEUA,KAIX,eACNN,EAAW,MAAOO,MAGlBC,IAAaD,EAAIf,MAAM,iBAAmBiB,IAAI,kBAAQJ,GAAWK,cAE/DL,EAAWE,GAEVC,EAAUG,OAAO,SAACC,EAAQF,MACzBG,UAAaC,4CACuBJ,cAClCH,EAAI3B,QAAQ8B,EAAMG,KACpBN,EAAIQ,QAAQF,GAAeA,EAAYG,UACjCT,EAAIU,MAAM,IAAKH,EAAI,GAAK,GAAK,OACjCP,EAAIU,MAAMH,GACTF,GACR,IAAML,KAGP,KACM,MACP,GAAIW,GAAIjB,EAAKkB,KAAKpB,GAAOmB,EAAGA,EAAIjB,EAAKkB,KAAKpB,MACpCI,EAAYJ,EAAKqB,OAAOhB,EAAWc,EAAEG,MAAQjB,mCACjBF,EAAagB,EAAE,SAAQ1C,EAAO0C,EAAE,aACvDA,EAAEG,MAAQH,EAAE,GAAGF,iBAExBb,EAAYJ,EAAKqB,OAAOhB,MACzBpB,EAAgBO,GAK1B,QAAS+B,GAAYC,SACV,UAACxB,EAAMC,SAAcF,GAASC,EAAMC,EAAWuB,yHCrH1CC,2EAID,qOAqBX,QAAKC,gFAMqB,wDACtB,0CAIiBC,uJAYKC,KAAAC,sEAG1B,yRAcC,gCAI6B,4GAoBH,4VAoBxB,QAASC,GAAgBC,SAC5B,KAAIA,sEAOJ,sCAGYC,wBAIX,mBACMC,kBAAAC,OAGJ,QAASC,KAATC,MACCC,KAAUrB,oCAIH,GAGV,2LAmCO,uCACiBsB,+CACjBC,8GAWL,8HAcCC,OAAOC,0BAA0B,qCACgBC,qBACzCC,uBAAAC,4RC9Mf,uEAGO,MAAS,GAAIC,SACbC,mCAGOC,4EAKPC,4FAOH,iEAKU,kBACPC,iDAMH,kDAIQA,yCAGOC,oBAEPC,cAiCN,QAASC,GAATC,UACCC,8BAEM,oCAEEC,qBAIV,wDAEEC,+BA6BD,QAASC,gEAERC,IAAJ,sBACOC,oBAIJ,QAASC,YACA,8FACH3C,iFAIZ,2GAUM,QAAS4C,wCAC4BC,uIAK3C,qDAMM,QAASC,cACLC,GAAmBC,EAAnBC,GAGJ,QAASC,WACL,+JC/IC,6DAYJ,2BACUC,4BAGN,yDAIH,QAXKC,iCCNF,kCACGC,ECmDV,oBACMC,uDA4EP,gHAUQC,8DA0CR,WAAmBA,iBACN,8JAaNC,uPASP,8DAGIC,qCAEAA,KAAJ,0EASQrC,EAAA,YAAAA,eACasC,aAAMH,0BACnBE,GAMJ,yBAEW,OAAc,aACrB,GAAa,mBAEb,aACA,2BAEA,cAEArC,IAAApB,UAAmB,OACnB2D,GAAOd,EACPe,EAAOC,EACPC,EAAOT,EACPU,EAAOC,IAEPC,GAAOpB,EAAGgB,EAAGR,EAAGW,EAAGR,EAAEpC,EAAI,GAAI,EAAG,cAChC6C,GAAOD,EAAGnB,EAAGgB,EAAGR,EAAGG,EAAEpC,EAAI,MAAQ,cACjC6C,GAAOZ,EAAGW,EAAGnB,EAAGgB,EAAGL,EAAEpC,EAAI,GAAI,GAAI,aACjC6C,GAAOJ,EAAGR,EAAGW,EAAGnB,EAAGW,EAAEpC,EAAI,GAAI,GAAI,eACjC6C,GAAOpB,EAAGgB,EAAGR,EAAGW,EAAGR,EAAEpC,EAAI,mBACzB6C,GAAOD,EAAGnB,EAAGgB,EAAGR,EAAGG,EAAEpC,EAAI,GAAI,GAAI,cACjC6C,GAAOZ,EAAGW,EAAGnB,EAAGgB,EAAGL,EAAEpC,EAAI,GAAI,GAAI,eACjC6C,GAAOJ,EAAGR,EAAGW,EAAGnB,EAAGW,EAAEpC,EAAI,qDAEzB6C,GAAOD,EAAGnB,EAAGgB,EAAGR,EAAGG,EAAEpC,EAAI,GAAI,GAAI,eACjC6C,GAAOZ,EAAGW,EAAGnB,EAAGgB,EAAGL,EAAEpC,EAAI,OAAS,UAClC6C,GAAOJ,EAAGR,EAAGW,EAAGnB,EAAGW,EAAEpC,EAAI,IAAK,GAAI,eAClC6C,GAAOpB,EAAGgB,EAAGR,EAAGW,EAAGR,EAAEpC,EAAI,IAAK,gBAC9B6C,GAAOD,EAAGnB,EAAGgB,EAAGR,EAAGG,EAAEpC,EAAI,IAAzB,gBACA6C,GAAOZ,EAAGW,EAAGnB,EAAGgB,EAAGL,EAAEpC,EAAI,sBACzB6C,GAAOJ,EAAGR,EAAGW,EAAGnB,EAAGW,EAAEpC,EAAI,OAAS,cAElC8C,GAAOrB,EAAGgB,EAAGR,EAAGW,EAAGR,EAAEpC,EAAI,mBACzB8C,GAAOF,EAAGnB,EAAGgB,EAAGR,EAAGG,EAAEpC,EAAI,GAAI,iBAC7B8C,GAAOb,EAAGW,EAAGnB,EAAGgB,EAAGL,EAAEpC,EAAI,OAAS,aAClC8C,GAAOL,EAAGR,EAAGW,EAAGnB,EAAGW,EAAEpC,EAAI,GAAI,GAAI,cACjC8C,GAAOrB,EAAGgB,EAAGR,EAAGW,EAAGR,EAAEpC,EAAI,GAAI,EAAG,cAChC8C,GAAOF,EAAGnB,EAAGgB,EAAGR,EAAGG,EAAEpC,EAAI,IAAK,cAC9B8C,GAAOb,EAAGW,EAAGnB,EAAGgB,EAAGL,EAAEpC,EAAI,IAAK,GAAI,cAClC8C,GAAOL,EAAGR,EAAGW,EAAGnB,EAAGW,EAAEpC,EAAI,GAAI,GAAI,+CAEjC8C,GAAOF,EAAGnB,EAAGgB,EAAGR,EAAGG,EAAEpC,EAAI,IAAzB,EAAiC,eACjC8C,GAAOb,EAAGW,EAAGnB,EAAGgB,EAAGL,EAAEpC,EAAI,GAAI,GAAI,cACjC8C,GAAOL,EAAGR,EAAGW,EAAGnB,EAAGW,EAAEpC,EAAI,oBACzB8C,GAAOrB,EAAGgB,EAAGR,EAAGW,EAAGR,EAAEpC,EAAI,MAAQ,eACjC8C,GAAOF,EAAGnB,EAAGgB,EAAGR,EAAGG,EAAEpC,EAAI,kBACzB8C,GAAOb,EAAGW,EAAGnB,EAAGgB,EAAGL,EAAEpC,EAAI,GAAI,GAAI,cACjC8C,GAAOL,EAAGR,EAAGW,EAAGnB,EAAGW,EAAEpC,EAAI,IAAK,GAAI,eAElC+C,GAAOtB,EAAGgB,EAAGR,EAAGW,EAAGR,EAAEpC,EAAI,GAAI,EAAG,WAChC+C,GAAOH,EAAGnB,EAAGgB,EAAGR,EAAGG,EAAEpC,EAAI,qBACzB+C,GAAOd,EAAGW,EAAGnB,EAAGgB,EAAGL,EAAEpC,EAAI,OAAS,cAClC+C,GAAON,EAAGR,EAAGW,EAAGnB,EAAGW,EAAEpC,EAAI,IAAK,GAAI,aAClC+C,GAAOtB,EAAGgB,EAAGR,EAAGW,EAAGR,EAAEpC,EAAI,GAAI,EAAG,eAChC+C,GAAOH,EAAGnB,EAAGgB,EAAGR,EAAGG,EAAEpC,EAAI,oBACzB+C,GAAOd,EAAGW,EAAGnB,EAAGgB,EAAGL,EAAEpC,EAAI,GAAI,GAAI,cACjC+C,GAAON,EAAGR,EAAGW,EAAGnB,EAAGW,EAAEpC,EAAI,OAAS,iDAElC+C,KAAAtB,IAAAQ,0BACAc,KAAAH,IAAAH,0BACAM,KAAAd,IAAAR,wBACAsB,KAAAN,IAAAG,sEAERH,oLAMJzC,8BAC4B4C,MAAS,2DAElBX,EAAGW,EAAGnB,EAAGgB,EAAGL,IAAM,sBACjBK,MAAYhB,IAArBzB,KAAoC,GAApC,oDAEQ4C,EAAGnB,EAAGgB,EAAGR,EAAGG,IAAM,uBACjBH,QAAeG,EAAxBpC,KAAoC,GAApC,sDAEQyB,EAAGgB,EAAGR,EAAGW,EAAGR,IAAM,sBAClBQ,MAARX,EAAAG,EAAsBpC,EAAtB,IAA+B,uDAEvByC,EAAGR,EAAGW,EAAGnB,EAAGW,IAAM,uMAmBpC,wICnVoB,miENgId,IAAMY,IAAU9D,EAAY,yLCzI/B9C,SACAO,kBACEC,8aMgCoDgC,6QAa1C,iBACC,wKAaa,6DAEfqE,ycC+CT,MAAO,6BAGP,gFAQA,yBAKSC,qGA6fJC,QACPF,sFAuBAA,sBAuGOG,QACPH,0FA8BgBI,EAChBJ,yCA2HF,WAA0BK,GACxBL,qCAmDKM,+BA+DEC,KAAqBC,GAC5BR,yEAiCAA,WAAgBQ,qCAuCXC,uBA4CkBH,KACvBN,cACAA,8DAkFcM,OACTE,0TAiXAE,MAASA,uBA8DTJ,SACLN,KAAKW,mDA6ELX,sBA4DOY,KAAwBC,QAC1BP,SACLN,yBAwD4BM,yCAiCrBQ,MACPd,6CAGAA,kBAAoBe,eA+ZbC,KAAwBC,GAC/BjB,6EAeAA,UAAgBiB,kBA+ChBjB,4BACgBkB,EAqLlB,WAAoCZ,KAClCN,mBACKvD,iIA8CLuD,yBACcvD,8CAgNduD,yBAmH6BM,0HAiG7BN,cACAA,qBA0BOmB,GAAoBb,KAC3BN,gEAsCAA,KAAKM,oBACSc,EA6BhB,WAA+Bd,kCAG7BN,uJA6JAA,KAAKqB,MAASA,gDAiEhB,WAA4Bf,KAC1BN,kQA6RAA,wBAmDOsB,QACPtB,4CAwDAA,cACAA,4BAoDwBM,iBAkG1B,YAAwBA,EAAQiB,KAC9BvB,uDAsDoBxB,mCAGTgB,2EAOmCgC,sBAO9C,QAAahD,oHA8ENiD,IAAanB,KACpBN,wCA8CO0B,IAAapB,KACpBN,4GA2TAA,cAuEF,YAAuBM,OACrBN,cACAA,iFA+OF,eACEA,sBA+BO2B,MAA4BC,GACnC5B,4DAeAA,aAAe6B,oBAkCoBD,iBAEnC5B,8CA0BAA,KAAK4B,6CAoCL5B,KAAK8B,iDAyEEC,SACP/B,0EA2DAA,kBAAoB,0GAmEEM,EACtBN,gBACAA,oDAwGF,kHA6HMgC,MAEF,0EAGF,IAAI7C,gBAKF,cAJE8C,oDAOJ,IAAIA,EACJ,KACEA,0DACOrE,2FASHuB,WACwB+C,YAItBC,EAAgBC,qKA+BpBC,qBAKGC,aACiB,kTAiIxBtC,kDAGkBuC,yDAQO,eACnBC,KAAuBC,2BAEGA,OACvB,iIA6BX,eAeA,YAA6BnC,KAC3BN,yGAqFK4B,gDAqPH,IAAK,WACH,MAAOV,mCAIL,6CAKA,+eA+GSnE,SAAW,EACtB,OAAO,4IAqCGA,8GAiCZ2D,YACa1E,oZAwRKwF,UACpBxB,wCA0CgC0C,yCAQhC,gBACEC,YAAeC,eAObC,gCAIFxC,wMAlnMCyC,gCAED,2EAIA,oBAAWC,0WA+KNC,iCACP,sPA+CgBC,iBAIhB,6cA4GOD,0BACP,uSAkFME,+BACK,uJA6CX,yEAcA,0FAKOlD,2BAA0BpC,qBACRb,wYA2GzB,iEAauC,iFAKvC,uBAGA,OAAOiD,MAAKM,OAAO6C,gBAAiBpG,gDAOXqG,mBACzB,mFAaA,MAAOpD,6CAQP,UAJIqD,EAAWrD,mbA4GUsD,oDAWVN,mCACRhD,MAAKuD,8BAGGP,UAAUQ,oBACzB,kCAOA,wCAHExD,KAAKhE,uBAGiB,yJA6BxB,UAAWyH,uGAiBCN,4BACApG,4GAqCd2G,EAASV,UAAUW,kBACjB,yBAAWnD,2BAMbkD,EAASV,4CAEP,0CAaWA,iCACX,aAAwBhD,KAAKM,YAAaE,gKAkBpBjF,oKAsCLqI,sBACjB,wBAWgBZ,kBAEAA,qHAOD,0cA2GjBU,EAASV,4CAEP,iCAWuB,GAAIU,gCAG3B,iKAwBiBG,sBACjB,8FAeIC,GAAY,sCAGd,MAAW,iJAkGb,eADIC,gBACOC,wBAWc,mNAoEzB,0DAyCA,wDAsCA,wGAwDA,iCAWyB,QAEZhB,UAAUG,0BACPc,iBAEZlH,cAGF2D,KAAuBA,QACXJ,uCACU1C,sbA0FO8F,eAENP,wBACrBe,6OAwCAlI,GAAQ,wCAGV,8PA6CF,oBAAoBO,2YAuEDyG,eAAiB,iDAElC,UAAWlC,GAAeyB,EAAK1B,sBAGf,+DAIhB,GAAIsD,eACQhB,yIA2BDH,8BAMb,UALIK,gBACAe,WACAC,EAAOrE,KAAKqE,KAGThB,wCAKH,iBADArD,sBAIJ,QAAO,qGAcP,WAAYwD,cACHxD,KAAKsE,+JAyChBZ,EAASV,UAAUuB,wBACjB9D,GAAY+D,GAAe/D,sIAmC3B,6CAEMA,GAAU7C,+KAoEToF,UAAUtH,oBACjB,qOAyDA,UALI+I,sBAEAC,EAAUD,aAGPE,qLA2DOC,iPA8Cd,aAAcjJ,SACZ,MAAOqE,2CAKT,gZAyDA,qDAawBsD,YAAc,WACtC,yEAYA,MAAOtD,MAAK6E,8CAQZ,IAJA,GAAIxB,GAAYrD,KAAKqD,qJAgCrB,uQAiEFK,EAASV,UAAU8B,gBACjB,yLA8BFpB,EAASV,UAAU+B,gBACjB,4LA0BFrB,EAASV,UAAUgC,gBACjB;8DA8BOhC,iCACPlB,4BAEO9B,qBAAqB9E,wHA0B5B,mFAeA,4CAGA,aAAYoF,gIAYZ,yBAAwB,YACtB,uBAAA,uYA8MF,yCAM0BiD,oBAC1B,mGAuBA,MAAOvD,MAAKK,4WA6EZ,GAAI1E,mBAEAsJ,oHA0BJ,uJAwBgBjC,6BAChB,yEAqBA,YAPahD,KAAKM,SACHN,KAAKI,SAChBzE,0cAmFJ,aAA+BqE,oZAqD/B,8EAQA,+CAMFkF,6BACE,UAAWC,gFAuBPC,GAAKlD,kBAJIlC,eACOrE,mBAIhBoB,EAAI,4IA8BVsI,EAAiBrC,UAAUsC,iBACzB,MAAOtF,MAAKuF,yDAGdF,EAAiBrC,UAAUwC,gBACzB,MAAOxF,MAAKsF,QAAQvI,IAGtBsI,EAAiBrC,UAAUrH,kBACzB,MAAOqE,MAAKsF,QAAQ3J,+SA+CU,WAC9B,6BAMWqH,2BACX,4BAMWA,0BACX,4BAMWA,iBAAmB,YAC9B,iEAOWyC,GAAmBzF,kHAYHgD,0CAOhBA,UAAU0C,mBACrB,mBAAmB9J,gFAgBnB,cAAkBmH,EAAOpH,QAIzB,kBAAkBoH,EAAOhG,uEAORiG,2HAYjB,+BAamBA,2BAQnB,YAPahD,qBACEA,KAAKI,SAChBzE,mEAYJ,iEA0BA,UAXIoH,qBACArC,0BAESiF,oCAUc5I,iFAgBvBqI,0BAJA1E,6BAGAkF,KAEA7I,EAAI,6DASI8I,YACQC,WACZ,gDASID,kIA0CZ,mCAGA,gIAW2B1C,gCACT7C,cACdyF,uCAIAD,OAEKA,YACOA,0BAKhBA,qEA0EFE,EAAmBC,OAAS,cAC1B,+aAwEFD,6BACE,uIAI2D5F,6QAkD3D,mBAAmBgB,MAWN4B,uDAGChD,MAAKoB,WAAaA,0EAKnB,mDAGJc,gKAkCT,wEAcA,GAAIgE,0GAMS,iCAGX,0BAES,2BAGEhE,oUA0HgC7F,kCAClC8J,oBACX,WAAWC,sFAeP7E,wEAKF,GAAI8E,WAEJC,MAAgB,wDAWdC,+BAMJD,6RA+GA,6CAaWtD,uBAA6BoC,kBACdoB,uEAI1B,6HA6BA,6CAaWxD,uBAA6BoC,SACjCqB,gFAIP,mXAgFIlL,GAFAmF,2CAIKV,iCACP,GAAIoF,wBAEUA,uGAWH,4DASCZ,eACVkC,iBACAjC,wFAQUkC,WAKA3D,gDAGVtC,0DAIQA,kBAERkG,yLA2DN3G,GAAc+C,UAAUC,gBACtB,MAAOjD,OAGTC,GAAc+C,UAAU6D,mBACtB,aAGY7D,6CACOoC,yHAgFrB0B,GAAmBb,OAAS,cAC1B,sMAiB2B3C,uBAC3B,sVAyEA,mBAA+ByD,ySAwDjCD,GAAmB9D,UAAUgE,KAAO,SAAcxG,GAChD,MAAqB,mBAAVA,wuBAgKX,0VAwDA,8EAcA,+NAoCA,oLAiBoCR,aAAa+C,4HAqBjD,YAAYA,iBAAiB/C,KAAK+G,MAAO/G,wBAGTwD,6BACtB5B,QACR,4BAGuB9F,4BAGvBkE,KAAK+G,sCACL/G,KAAKiH,YACLjH,uLAuBKA,sCAAsCA,0EAK3CA,KAAKkH,kDACEC,6MA6BXC,GAAcpE,UAAUC,gBACtB,MAAOjD,OAGToH,GAAcpE,UAAU6D,mBACtB,OAAO,GAGTO,GAAcpE,UAAUwC,gBACtB,MAAOxF,MAAK+C,OAAOsE,6VA+DMtK,iBACd,gKA6BX,2ZAkGIA,wBAGEuK,GACFC,SAIiBC,yEAQRC,iDA2DXC,cAEW,6DAyCb,mDAlCI,0HAcA,sDAKiBC,eAGjB3F,2DAQAhC,KAAK4H,QAAUC,IACjB7H,sFAWO4H,QAAUF,mBAEjB1H,cAGFqC,sKAa4CyF,gOAwC5C,uTA2JE,sBAAA,iHAuBA,uBAAA,4EAeF,0BAMsBC,MAAQ,SAAeC,SACtC,IAAIC,+JAwDMjF,4BACjB,0CAcFkF,GAAoBlF,UAAUmF,gCAC5B,MAAIrG,2FAUWmF,6BAAXF,IACA/K,sCAGQoM,CAGV,aAAetG,EAAUhG,eACjB3B,gDAIE8M,cAGVoB,kEAMEnF,uEASAoF,IACAD,EAAS,sCAMX,KADA,+CAIE,6BAAOE,+BAWX,OAJAC,GAAOC,WAAW,sBAIXD,yFAQP,cAAiCxI,YAWbgD,0DAGDpB,aAEf7E,8CAGFwF,kMAkE6BmG,uBACTA,iCAMpB,2BAAeC,EAAUhN,0KA2D3B,GAAIoL,+NAgCNxE,EAAKqG,wDACsC1G,kOAoC1B,yJA6VH2G,qEAYV,IAAK,uCAMI,gDAQL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,4BAIL,IAAK,IACL,oBAEK,6GA4BT7F,2CACgBd,+GAiBZ,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,IACL,IAAK,wBAGA,wCAKA,yHAgEI4G,EAASnN,oJAmBTqE,wCAQf,ksBC5tMW,qNAUH5B,IAAJ,aAAqB2K,cAGUC,UAAUC,wIAKrC,+CACwCC,GAAQV,sMCtCpDW,s4BA4CK,4ZC7B2BC,aAAhC7M,iFAMA8M,2GAOmB,gYCrBPC,qDAIZC,0oBVrBDC,+BAEPC,EAAAlQ,qfAuGYyN,YAAU,aACqB,4TW7FtB0C,mFAGbC,6NAyBKC,6CAEE1L,+QA8BP2L,4HAgBKC,6JAWE9J,MAAK+J,o9BAiFJ,IAAK,uCAaV,oOAiBIC,sJAUc,6hBCjNdC,qLCPGjK,m2BAoDVoF,sHC7CK,kCAED,MAAJ8E,yFAMO,6GAcP,mCAxBSlK,gCA2BJmK,WAAWC,cACXC,6HA5BIC,wBAiCOH,kDAJZnK,8DACJ,uIA9BSA,gBA+CRuK,iGAGMjB,IAAAkB,oCAlDExK,gBAoDRoK,iBACGX,KAAgB,oDAChBA,iCAGCU,WAAWG,SAAS,eACpBH,WAAWI,WAAW,kEAGXrM,GA7DP,wIAwEOuM,KAxEP,2IA2EMC,kBAECD,4DAEc,qCAGzBN,WAAWG,SAAS,eACpBH,WAAWI,WAAW,mIAMpBG,uDAGFP,WAAWC,4MAMZD,iEAEGrC,0VApGE,eAiHJqC,WAAWI,wBACTvK,KAAKmK,WAAWQ,uLAUvB3K,oEAGYmK,0DAGLnK,MAAKmK,WAAWS,qDAGlBT,icAqBLA,yVAkBAU;wEAoBA,qBACOC,qTAoBA9K,KAAK+K,8VAmBMC,qTAsBXC,qKAWFC,OACElL,kHAGWmL,2EAKDlC,ogBAuBVmC,+DAIH,uCAEA,eACW,4BACN,0BAGD,kGAMA,+IASWC,kBACnBC,8OAUItL,0BAA0BuL,iQAavBC,gJAIAC,WAAsCC,iBAAkCC,6LAYtExB,WAAWyB,oBACT,8BAKHC,oaAkBJ7L,KAAJmK,uCACgBA,yPC5YEnK,o0BCiCRyJ,GAAK,4PAuBX,qMAkBZ,+JCtEa,0GAcR,yQAwBCrE,iBACElD,uGCnCSV,gCAGOsK,mCAOPC,8MAQb,4HAIenE,MACD,qFAE4C6B,0FAQlD,0GASJpN,mBAEkBmF,oCACawK,qGAOpBC,EAAM,gCACDC,8HAQZC,EAAoB,MAATd,wBAEGe,+EAEYC,cAAc,SAAd3J,oBAG1BwJ,2DAKJ5C,iQAK8BgD,sBAAwBC,QAA7BC,OAA4C,8DAGnEJ,sDAIWlO,2DAEoBuO,iBAAAhC,oGAWdrP,IAAR,4DAIOsR,oEAKEC,SAASC,kIAUzB5M,uFAIQkM,IAAVQ,2VAQWG,2EAIRC,EAAAxD,wCACDmD,mEAGYhC,+NAcE,4LAWdqC,2GAQAC,mKAMAC,eACAd,wJAKOlM,SAAS0M,yCAEfO,oEAALxC,+EAIgCyC,eAAmCd,qNAMnD3B,IAAY0C,+GAS3B,yCACeC,4CACTA,0EAKPC,wWA0BWnB,IAAVQ,YAA0B,2DAcfjC,MAAgB6C,gHAOrBtN,MAAKuN,gBAAgB7C,EAAIxM,EAAM,oCAIrC,SAAUuM,EAAMC,EAAIxM,EAAMuL,SAEpBzJ,MAAKuN,gBAAgB7C,EAAIxM,EAAMuL,QAIrC,SAAUgB,EAAMC,EAAIxM,EAAMoP,wBACpB,IAAAA,wLAcHnE,gEACGnJ,MAAKuN,gBAAgB7C,IAAUvB,QAIrC,SAAUsB,EAAMC,EAAIxM,WAEd8B,MAAKuN,gBAAgB7C,IAAUjB,QAIrC,SAAUgB,EAAMC,EAAIxM,EAAMyO,SACpB3M,MAAKuN,gBAAgB7C,EAAIxM,EAAS,mBAAzCyO,kRAoBWT,IAAVQ,+DAKUa,gBAAgB7C,UAA1B8C,qBAUGlE,SACGtJ,MAAKwI,0BAIX,SAAUiC,EAAMC,EAAIpB,EAApBkB,yPAiBGiD,oEAGK,+BAATA,6IAOWF,gBAAgB7C,wEAYvBgD,eAECxB,mDACDwB,oFAQFhD,IAAgCjB,0lBCpWtBS,uYAqBA1P,cAAA,meC5CDmT,yfA+BL,iYClCN3N,8KAYA4N,wHAGeC,qLAQXC,8BAGG5Q,4JASH8C,KAAK1C,kDAEcyQ,sLAQd,8GAGL,+WAeiB/N,gMAajBgO,oCAIG9Q,4dC7EP4B,gKAEuCxB,iBACvCwB,2QAeA+O,4FACYI,wbAaEC,4BACdJ,oBAEKK,8BACD,gEAGcC,WAEXpO,KAAKmO,6oBAgCsC,0ZA8B/B,gQAkBfnO,MAAKqO,eACAC,KAAK,kPAQL1G,kLAOJ8E,6UAYL9E,OAAkD,0BAC9C5H,iXAqBeuO,4LAcf,CAAA,cAEQ,uIAKZC,wCACYC,aAAkB,qLAWC,qbAkB3BzO,qDACJwI,4eAkBYuE,yEAIcvL,6BACtBkN,4OAQJtJ,sBACAlD,MAAJ,glBC9OI,sCAESyM,eAAe3O,mSA4BpBA,2SAmBJA,0WAkBAyM,8kBA8BO,8PAmBHtQ,mWAwBAkP,8CAGGuD,4PAmBqClM,yKAiBjC,mFAYP,0BACa1C,qCAEGA,iGAIIwL,wHAYpBqD,OAAJC,4jBA8BA,6LAUiD,wEAMrC,2QAYRC,YAAOC,UACP1F,gBAEY2F,wNAWhB,gDAAO9S,KAAPE,gBAGI4M,wBAC+BrN,MAAD,gBAEtBQ,kQAgBZ,+CACYD,yWAeZ,gVC1VW,sBAAwBK,oIAelBH,kEAKHF,sXCrBGd,oCACQ0L,kDACHmI,yUAoBjBtF,yXCvBTuF,uBAAc,2EAIbA,42BA+CgBC,iGAUaC,uTzBjDtBC,4FA8BS,0BACH,iBACD,6DAGqBjE,+RAOnB,8FAIE0D;2DAKyBQ,gNAO3B,uEAGEjG,wBAEJA,oCACE,mCAGPkG,mWAmBS,0EACH,iBACD,UAAD,0SAmBLxP,wMAMC,kIAIAA,sFAIOA,ouBAyBA,mCAEPA,2hCAoCI6N,0DAGW,gIASC4B,8JAQV,oLAMMrG,qKASVsG,+aAWYC,kmBAyBP3P,uHAIEiP,mCADTW,kLAKEA,0aAiB6B,gjBAoBpBC,0JAMP7P,+lBA4BD8P,2VAsBI9P,MAAK8P,yCAIH,0CAEF,gCAEA,aAAc,yLAOf,8LAUC9P,uzBAqCAA,MAAKgP,mBAAL,mDAIE,0DACH,uFAIW9C,gLAMZ,qBAAsB,0IAOlB,2mCAgCL,+SASAtE,4HAE2B,uEAIpB5H,gQAGU,iBAAV4H,yCACuC,8hCA6B9C5H,+FAEaA,sOAKjB+P,SACWC,q5BAkCRJ,4OAYCpE,aAHFyE,sDAIKjQ,6aAoBE,iWAILkQ,+PASH5D,uLAIoC,8qBA2BtB6D,iXAsBN,0EAGKC,yCAAQ,SAATC,gUAsBbC,mOAUC,sDAGC5U,oBACEM,0KAWAA,GAHHuU,gFASO/K,mCACIyJ,y2B0BlsBD/E,yBAA4B/D,uBAF3C8I,iTAiBenB,SAAfvR,sVAY6CyM,UAAjBC,ktBCTf8F,GAAOyB,YAChB,2DAEI,eAAJC,iVAqBA1T,qPAqBuByO,sGAObxL,KAAK0Q,oDAEN,kQAYc,8CACe5D,gWAsB9B,2EAAZ6D,gFAK0B7D,8HAmBd8D,EAAIC,EAAJxF,2DAKCwF,WAA0BA,IAA/BD,+BAEkBf,kPAeA,QAA1B/C,wBAIQgE,YACK/T,UAA0BpB,iBAE3B,UAAJoV,EAAkBC,OAAOxF,oCAMrB7P,4HAWR,oBAEA+U,qCAESb,YACInN,yDAMT,iJCpNO,yBAGfkO,EAAkB,eAAFA,kBAEJpF,ieAmCZrP,2PAUI2R,GAAJmD,2mBChDJC,EAA8BC,yGAK1BC,iJAYcC,+WAgBiB,0UAsB3BC,oBAA2B5O,4QAarB1C,4BAENoF,EAAMA,qmBAkCV,uYA4BKmM,8IAILC,wHASI,0CAAA,wEAQCA,EAAM,qaC5IXC,8KASuB5D,0CACR,+OAUQ6D,wxBAuCnB1R,krBAoCI0R,oKASiCL,kBAAXjY,4GAKvBuY,gGAIKlD,gDAIR,iEAGOA,2IAKP,8eAuBUM,GAAQA,8OChKT,6KAOR6C,6lBAmCwB,4yBCV7BC;iBASIhE,+FAQG,shBA2CF,uTAiBDgE,0PC3GSC,4qBAiCRC,cAAc,s3BAqCd,GAALlB,qDACW7E,8SAYD,6SAiCN7C,sEACAqC,wBAAqDwG,+OAazC,sDAAhB,kuBCnIqC,saAuB5BR,2DAATS,8mBCxBMC,sCACCC,mGAIAnS,MAAKkS,8BAKPE,oNCRQC,8IAGEnF,wBACC,gFAGhB,qBAGAoF,wCAUeC,cAGHxD,QACCJ,6IAFT6D,mBAQE9P,mHAKN,YACI,0BAGM+P,+KAONC,4HAOAC,8PAgBC,sSAcE3S,MAAK4S,4JAQPC,yVAYE7S,KAAK8S,smBA4CL9S,mrBCjJmB+S,yHAenBC,WAGErE,eAAe3O,iBAEpB4N,qWAgBA5N,kBAAoB,uBAEfiT,uNAgBJrB,6cA8BDsB,ibAsBGlT,uBAAiB4P,+RAWpB5P,0tBChHa,oHAMjBgT,+MAS0BG,srBA6CYzQ,wDAaf0Q,qFAanBpT,0DAEO5E,yEAEY0S,unBAkBvB9N,8XAwByBqT,GAClBrT,0EAKKsT,sNAUHrJ,+LAaT8E,sLAeiC/O,uBAN1B,mNAqB8BuP,mCAIrCgE,4OAiBYvT,KAALwT,oRAUHxX,qBAAiDyX,OAAOzX,6SAWpD0X,SACJ1T,qKAOsB2T,mBAAtBD,gWAuBoBxW,0CAEE0W,+NAUvBJ,gQAWWK,oFAYFrO,+jBAsBPoC,2QAWSkM,+BAAsC,8KAQ/CC,wBACAC,2EACwBC,EAA0BC,YAAatM,kLAIhE5H,sEACAA,mEAIsBqO,yTAmBf1B,oCAIJA,iQAWCwH,oRAQD,inBA6CP,2DACoBnF,EAAK9C,mBACrBkI,WAAoBlI,mBACpBS,kYAgBC3M,sMAeLoF,0FAKuBiP,YAAD,QAA0BA,gOCvejCJ,0DAEfA,wBAAA,+DAEC,0GAWM,0IALqB,8BAAAK,IAyBhCA,IAAKtR,0CAzB2B,mCAAA,4DAAA,gEA6C3B,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,iEAaA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,UAEA,uDCzFYuR,sgDAyJmBC,4IAcpC,uMvCxKJ,mHAWQC,6CAAA,+FAMAA,wEAWO1E,EAAaR,gdAsBRmF,oQAYgD,wBACxD,6EAMCnF,wdAwBE,4PAeQ,6cAgCXvP,qBAGO2U,2LAOuBzT,6IAS9BqO,oDACJ,mYAUQqF,EAAOC,yBACNC,gcAgCKC,kCACVtL,GAAMuL,2CACVrZ,aACOgO,IAAkB,uFAGjB,iKAEOsL,SAAPC,sLAqBe,eACIhU,kDAEnB,OAAOiU,2DACPC,4UAkBeD,+LAIRrW,QAAKqW,IAALF,MAAAjV,+HAMXA,oHASJA,kBAEeqV,gBAAfC,QAII,4FACJ/Y,iLAQI8Y,YAAErV,6GAGcA,2GAMwBuV,4LAOTha,0HAI/ByE,KAAKwV,mVAQjBC,sCACI,iTAQ+CC,gTwClU9Cf,oFCLgBgB;mBxCUrB,4qBC4BgBC,iSAkBDjB,uRAeH,iBAAA3U,KAAKmU,OACAnU,KAAK6V,oMAaP7V,kEAIH8N,mDAGK+H,2MAOJjE,60BA0BkBkE,oaAgBnB9V,wJAQAiJ,qLAWA8M,GACAC,uKAUAA,+BACKC,iBACAT,yJAQM,yFAKRxV,4DAGKkW,SACRlW,4EAGqBkW,+XAYR,WAAblF,yEAOAgF,4NAmBAjH,iFAGuBZ,mGAKvB,QAAJzL,IACI,0GAAA,2EAUKyL,sQAULkE,6BAEA8D,EAAoB,iFAMpB,ucAuBGnW,KAAKoW,eAAgB,ugBAyBbpW,qBAAAiV,6gBAgCR,koBwC3UAjV,oFAQH0C,IACA2T,iICrBC,6GASA,0MAcLC,gpBAgB2DpI,oPAetDqI,2PAYAC,kBAALC,yFAEK1L,+FAAL,mRAeS3B,wJAIL8E,8BACKJ,6EAGAA,uRAQEI,iOAQAwI,sGAGkC9O,YAElC+O,OAAK5P,MAAM,qEAGbgE,MAAM6L,wBAEJC,odAUC,2PAQL7W,KAAKwW,qBAAqB,mcAoB7B,iCAAO/H,qgCAmCyD,ooBAehEuB,mEAGA,05CA8CAhQ,oDACuB8W,4BACvB9W,KAAK+W,4DAEAhM,irBAgCUiM,sIAIfC,QACYC,6yBA8BXV,+CACMW,mBAAPnX,uyBCtSJoX,mCAAA,8CAOA,6WAcIC,mbAoBaC,8JAWjB,qRAQA,sIAWKC,mBACAC,8CACAA,yEACEC,qIAIqB3J,4EAErB2C,sLAK+C/V,uXAUlD+b,4DACOzW,iUAeP,0CAAA,QACA0X,GAAeC,mCACX,wBAARlJ,+zBAmCyCJ,obAiBzCrO,0IAQmC0U,EAA/BL,sCACAK,OAEGkD,KAAiB,OAAQ,2LAQT1J,iMAYnBlO,4EAGQ6X,2BAAZ9I,8KAQI,WAAK+I,0IAU0B/I,IAAnCV,2TAYI2C,uKAQChC,qNAcDD,yEAGGA,yEAIqB7Q,2DAGrB8B,kHAMHgP,EAAJ9C,4MAUAa,kcAkBYxQ,oDACR,qCAEA,KAAJ,4EAOiCqB,SAG7B4N,wqCAiDwBwD,qQAUrB,sGAeF+I,ySAgBL/I,oIAOU7L,wCACiC2N,EAAL,mHAOrBnU,gIAKjB+F,gBACiBsV,yGAMbxM,0BACKyM,qPAcLzM,QAAJ0M,sJAMQC,qDAKI3M,gBAAkBlC,yGAUnB8O,wLAUwB5M,sBAClB7O,wCAIZqD,oPAMS0C,8BAEH1C,uRAUMA,4KAQbqY,QAEA/O,gHAMIgP,gQAgBJ9N,6DAMIxK,mBAA+B8M,iEAGvByL,uBAAuBra,6WASnCsa,kFAOM,2HAGNC,4EAIJC,wDAQoC,uGAIpC,+SAUIxZ,iDAEauT,miBChmBjBhG,kBAAS,iBACLA,oCACHA,wBAKG,4tBCPgB;mHA2BbzM,MAAK2Y,gaA6BR3Y,ofAwCZ4Y,sTC9FY5Y,KAAK6Y,yDAUZ,2HAUU7Y,8GAOf,uIAUa,0DAQL8Y,QAAK,EACLA,UACHA,gtBAgDO5M,wHAIA4G,2KAmBE9S,iCAAaA,k7BChHnB+Y,yBAOA,2DAK8BC,SAEtB3G,GAACzE,qHAI2CqL,4kCA2CtCrb,gCAETsb,gSAgB4BC,iKAWUpN,0hBAuBnCqN,gYAcG,iMAWJ,yYC9IPpZ,mDACA+M,2mBAoCO,uGAQH,SAAcsM,4DASX,uvBA6BAC,kBAA8Ble,6JAMf2R,4bA8BjBwM,yBACAvZ,KAAKwZ,kCACDA,2BAA6BC,WAC9BzZ,KAAK0Z,yBAAyBvG,KAAKnT,MAAOsZ,qFAKxCK,oFAIL5M,sBAAoCA,qFAIpCA,MANL6M,qMAcAC,wQAaIC,6VAkBAC,gMAMwBC,2MAgBxBtG,EAASvE,uDAETuE,oCAIA,qCAGI,2DACH,2BAEA,gBACM1T,MAAKia,cAAmBC,+BAExBla,MAAKma,oSAaLze,sDAKOsE,4SAmBH0T,EAAO0G,uPAyBf1X,iDAOWgR,qOASSA,iCACW,y3BC9R7C4F"}